package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.Render3DEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getBlock
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.material.Material
import net.minecraft.client.renderer.GlStateManager
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import net.minecraft.util.MathHelper
import net.minecraft.util.MovingObjectPosition
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11
import java.awt.Color
import java.util.*
import javax.vecmath.Vector3f
import kotlin.math.atan2
import kotlin.math.roundToInt

/**
 * LiquidBounce Hacked Client
 * A minecraft forge injection client using Mixin
 *
 * @game Minecraft
 * @author CCBlueX
 */
@ModuleInfo(name = "ItemTeleport", description = "Allows you to pick up items far away.", category = ModuleCategory.EXPLOIT)
class ItemTeleport : Module() {
    private val modeValue = ListValue("Mode", arrayOf("New", "Old"), "New")
    private val resetAfterTp = BoolValue("ResetAfterTP", true)
    private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")
    private var delay = 0
    private var endPos: BlockPos? = null
    private var objectPosition: MovingObjectPosition? = null

    override fun onDisable() {
        delay = 0
        endPos = null
        super.onDisable()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent?) {
        if (mc.currentScreen == null && Mouse.isButtonDown(listOf(*buttonValue.values).indexOf(buttonValue.get())) && delay <= 0) {
            endPos = objectPosition!!.blockPos

            if (getBlock(endPos)!!.material === Material.air) {
                endPos = null
                return
            }

            ClientUtils.displayChatMessage("§7[§8§lItemTeleport§7] §3Position was set to §8${endPos!!.x}§3, §8${endPos!!.y}§3, §8${endPos!!.z}")

            delay = 6
        }

        if (delay > 0)
            --delay

        if (endPos != null && mc.thePlayer.isSneaking) {
            if (!mc.thePlayer.onGround) {
                val endX = endPos!!.x.toDouble() + 0.5
                val endY = endPos!!.y.toDouble() + 1.0
                val endZ = endPos!!.z.toDouble() + 0.5

                when (modeValue.get().toLowerCase()) {
                    "old" -> {
                        for (vector3f in vanillaTeleportPositions(endX, endY, endZ, 4.0)) {
                            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(vector3f.getX().toDouble(), vector3f.getY().toDouble(), vector3f.getZ().toDouble(), false))
                        }
                    }
                    "new" -> {
                        for (vector3f in vanillaTeleportPositions(endX, endY, endZ, 5.0)) {
                            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(vector3f.x.toDouble(), vector3f.y.toDouble(), vector3f.z.toDouble(), true))
                            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 4.0, mc.thePlayer.posZ, true))
                            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(vector3f.x.toDouble(), vector3f.y.toDouble(), vector3f.z.toDouble(), true))

                            MovementUtils.forward(0.04)
                        }
                    }
                }
                if (resetAfterTp.get())
                    endPos = null

                ClientUtils.displayChatMessage("§7[§8§lItemTeleport§7] §3Tried to collect items")
            } else {
                mc.thePlayer.jump()
            }
        }
    }

    @EventTarget
    fun onRender3D(event: Render3DEvent) {
        objectPosition = mc.thePlayer.rayTrace(1000.0, event.partialTicks)
        if (objectPosition!!.blockPos == null) return
        val x = objectPosition!!.blockPos.x
        val y = objectPosition!!.blockPos.y
        val z = objectPosition!!.blockPos.z
        if (getBlock(objectPosition!!.blockPos)!!.material !== Material.air) {
            val renderManager = mc.renderManager
            GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
            GL11.glEnable(GL11.GL_BLEND)
            GL11.glLineWidth(2f)
            GL11.glDisable(GL11.GL_TEXTURE_2D)
            GL11.glDisable(GL11.GL_DEPTH_TEST)
            GL11.glDepthMask(false)
            RenderUtils.glColor(if (getBlock(objectPosition!!.blockPos.up())!!.material !== Material.air) Color(255, 0, 0, 90) else Color(0, 255, 0, 90))
            RenderUtils.drawFilledBox(AxisAlignedBB(x - renderManager.renderPosX, y + 1 - renderManager.renderPosY, z - renderManager.renderPosZ, x - renderManager.renderPosX + 1.0, y + 1.2 - renderManager.renderPosY, z - renderManager.renderPosZ + 1.0))
            GL11.glEnable(GL11.GL_TEXTURE_2D)
            GL11.glEnable(GL11.GL_DEPTH_TEST)
            GL11.glDepthMask(true)
            GL11.glDisable(GL11.GL_BLEND)
            RenderUtils.renderNameTag(mc.thePlayer.getDistance(x.toDouble(), y.toDouble(), z.toDouble()).roundToInt().toString() + "m", x + 0.5, y + 1.7, z + 0.5)
            GlStateManager.resetColor()
        }
    }

    private fun vanillaTeleportPositions(tpX: Double, tpY: Double, tpZ: Double, speed: Double): List<Vector3f> {
        val positions: MutableList<Vector3f> = ArrayList()

        val posX = tpX - mc.thePlayer.posX
        val posZ = tpZ - mc.thePlayer.posZ

        val yaw = (atan2(posZ, posX) * 180 / Math.PI - 90f).toFloat()

        var tmpX: Double
        var tmpY = mc.thePlayer.posY
        var tmpZ: Double

        var steps = 1.0

        run {
            var d = speed
            while (d < getDistance(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, tpX, tpY, tpZ)) {
                steps++
                d += speed
            }
        }
        var d = speed
        while (d < getDistance(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, tpX, tpY, tpZ)) {
            tmpX = mc.thePlayer.posX - Math.sin(Math.toRadians(yaw.toDouble())) * d
            tmpZ = mc.thePlayer.posZ + Math.cos(Math.toRadians(yaw.toDouble())) * d
            tmpY -= (mc.thePlayer.posY - tpY) / steps
            positions.add(Vector3f(tmpX.toFloat(), tmpY.toFloat(), tmpZ.toFloat()))
            d += speed
        }
        positions.add(Vector3f(tpX.toFloat(), tpY.toFloat(), tpZ.toFloat()))
        return positions
    }

    private fun getDistance(x1: Double, y1: Double, z1: Double, x2: Double, y2: Double, z2: Double): Double {
        val d0 = x1 - x2
        val d1 = y1 - y2
        val d2 = z1 - z2
        return MathHelper.sqrt_double(d0 * d0 + d1 * d1 + d2 * d2).toDouble()
    }
}