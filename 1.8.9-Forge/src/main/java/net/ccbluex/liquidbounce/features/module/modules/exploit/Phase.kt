package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.block.BlockUtils.Collidable
import net.ccbluex.liquidbounce.utils.block.BlockUtils.collideBlockIntersects
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getBlock
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.Block
import net.minecraft.block.BlockAir
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import net.minecraft.util.MathHelper
import kotlin.math.cos
import kotlin.math.sin

/**
 * LiquidBounce Hacked Client
 * A minecraft forge injection client using Mixin
 *
 * @game Minecraft
 * @author CCBlueX
 */
@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
class Phase : Module() {
    private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"), "Vanilla")
    private val tickTimer = TickTimer()
    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()

    @EventTarget
    fun onUpdate(event: UpdateEvent?) {
        val isInsideBlock = collideBlockIntersects(mc.thePlayer.entityBoundingBox, object : Collidable {
            override fun collideBlock(block: Block?): Boolean {
                return block !is BlockAir
            }
        })

        if (isInsideBlock && !modeValue.get().equals("Mineplex", ignoreCase = true)) {
            mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = true
        }

        val netHandlerPlayClient = mc.netHandler

        run L@{
            when (modeValue.get().toLowerCase()) {
                "vanilla" -> {
                    if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking))
                        return@L

                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.2, mc.thePlayer.posZ, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true))

                    val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())

                    val x = -sin(yaw) * 0.04
                    val z = cos(yaw) * 0.04
                    mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                    tickTimer.reset()
                }
                "skip" -> {
                    if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking))
                        return@L

                    val direction = MovementUtils.getDirection()

                    val posX = -sin(direction) * 0.3
                    val posZ = cos(direction) * 0.3
                    var i = 0

                    while (i < 3) {
                        mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.06, mc.thePlayer.posZ, true))
                        mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + posX * i, mc.thePlayer.posY, mc.thePlayer.posZ + posZ * i, true))
                        ++i
                    }

                    mc.thePlayer.entityBoundingBox = mc.thePlayer.entityBoundingBox.offset(posX, 0.0, posZ)
                    mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX + posX, mc.thePlayer.posY, mc.thePlayer.posZ + posZ)
                    tickTimer.reset()
                }
                "spartan" -> {
                    if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking))
                        return@L

                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 0.2, mc.thePlayer.posZ, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                    netHandlerPlayClient.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true))

                    val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())

                    val x = -sin(yaw) * 0.04
                    val z = cos(yaw) * 0.04

                    mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                    tickTimer.reset()
                }
                "clip" -> {
                    if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return@L
                    val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                    val oldX = mc.thePlayer.posX
                    val oldZ = mc.thePlayer.posZ
                    var i = 1
                    while (i <= 10) {
                        val x = -sin(yaw) * i
                        val z = cos(yaw) * i

                        if (getBlock(BlockPos(oldX + x, mc.thePlayer.posY, oldZ + z)) is BlockAir && getBlock(BlockPos(oldX + x, mc.thePlayer.posY + 1, oldZ + z)) is BlockAir) {
                            mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                            break
                        }
                        i++
                    }
                    tickTimer.reset()
                }
                "aac3.5.0" -> {
                    if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)) return@L
                    val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())

                    val oldX = mc.thePlayer.posX
                    val oldZ = mc.thePlayer.posZ

                    val x = -sin(yaw)
                    val z = cos(yaw)
                    mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                    tickTimer.reset()
                }
            }
        }
        tickTimer.update()
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent) {
        if (mc.thePlayer != null && collideBlockIntersects(mc.thePlayer.entityBoundingBox, object : Collidable {
                    override fun collideBlock(block: Block?): Boolean {
                        return block !is BlockAir
                    }
                }) && event.boundingBox != null && event.boundingBox!!.maxY > mc.thePlayer.entityBoundingBox.minY && !modeValue.get().equals("Mineplex", ignoreCase = true)) {
            val axisAlignedBB = event.boundingBox
            event.boundingBox = AxisAlignedBB(axisAlignedBB!!.maxX, mc.thePlayer.entityBoundingBox.minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ)
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (packet is C03PacketPlayer) {
            if (modeValue.get().equals("AAC3.5.0", ignoreCase = true)) {
                val yaw = MovementUtils.getDirection().toFloat()
                packet.x = packet.x - MathHelper.sin(yaw) * 0.00000001
                packet.z = packet.z + MathHelper.cos(yaw) * 0.00000001
            }
        }
    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        if (modeValue.get().equals("mineplex", ignoreCase = true)) {
            if (mc.thePlayer.isCollidedHorizontally) mineplexClip = true
            if (!mineplexClip) return
            mineplexTickTimer.update()
            event.x = 0.0
            event.z = 0.0
            if (mineplexTickTimer.hasTimePassed(3)) {
                mineplexTickTimer.reset()
                mineplexClip = false
            } else if (mineplexTickTimer.hasTimePassed(1)) {
                val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                val direction = MovementUtils.getDirection()
                mc.thePlayer.setPosition(mc.thePlayer.posX + -Math.sin(direction) * offset, mc.thePlayer.posY, mc.thePlayer.posZ + Math.cos(direction) * offset)
            }
        }
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent) {
        event.cancelEvent()
    }

    override val tag: String
        get() = modeValue.get()
}