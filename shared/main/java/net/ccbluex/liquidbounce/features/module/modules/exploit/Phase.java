/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit;

import net.ccbluex.liquidbounce.api.minecraft.client.network.IINetHandlerPlayClient;
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket;
import net.ccbluex.liquidbounce.api.minecraft.network.play.client.ICPacketPlayer;
import net.ccbluex.liquidbounce.api.minecraft.util.IAxisAlignedBB;
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos;
import net.ccbluex.liquidbounce.event.*;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.ccbluex.liquidbounce.utils.timer.TickTimer;
import net.ccbluex.liquidbounce.value.ListValue;

@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
public class Phase extends Module
{

	private final ListValue modeValue = new ListValue("Mode", new String[]
	{
			"Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"
	}, "Vanilla");

	private final TickTimer tickTimer = new TickTimer();

	private boolean mineplexClip;
	private final TickTimer mineplexTickTimer = new TickTimer();

	@EventTarget
	public void onUpdate(final UpdateEvent event)
	{
		if (mc.getThePlayer() == null)
			return;

		final boolean isInsideBlock = BlockUtils.collideBlockIntersects(mc.getThePlayer().getEntityBoundingBox(), block -> !classProvider.isBlockAir(block));

		if (isInsideBlock && !"Mineplex".equalsIgnoreCase(modeValue.get()))
		{
			mc.getThePlayer().setNoClip(true);
			mc.getThePlayer().setMotionY(0.0D);
			mc.getThePlayer().setOnGround(false);
		}

		final IINetHandlerPlayClient netHandlerPlayClient = mc.getNetHandler();

		final float dir = MovementUtils.getDirection();
		final float sin = -functions.sin(dir);
		final float cos = functions.cos(dir);

		final double posX = mc.getThePlayer().getPosX();
		final double posY = mc.getThePlayer().getPosY();
		final double posZ = mc.getThePlayer().getPosZ();

		final boolean onAir = !mc.getThePlayer().getOnGround();

		if (tickTimer.hasTimePassed(2) && mc.getThePlayer().isCollidedHorizontally() && (!isInsideBlock || mc.getThePlayer().isSneaking()))
			switch (modeValue.get().toLowerCase())
			{
				case "vanilla":
				{
					if (onAir)
						break;

					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX, posY, posZ, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5D, 0, 0.5D, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX, posY, posZ, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX, posY + 0.2D, posZ, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5D, 0, 0.5D, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX + 0.5D, posY, posZ + 0.5D, true));

					final double x = sin * 0.04D;
					final double z = cos * 0.04D;

					mc.getThePlayer().setPosition(posX + x, posY, posZ + z);

					tickTimer.reset();
					break;
				}
				case "skip":
				{
					if (onAir)
						break;

					final double x = sin * 0.3;
					final double z = cos * 0.3;

					for (int i = 0; i < 3; ++i)
					{
						mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(posX, posY + 0.06, posZ, true));
						mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(posX + x * i, posY, posZ + z * i, true));
					}

					mc.getThePlayer().setEntityBoundingBox(mc.getThePlayer().getEntityBoundingBox().offset(x, 0.0D, z));
					mc.getThePlayer().setPositionAndUpdate(posX + x, posY, posZ + z);

					tickTimer.reset();
					break;
				}
				case "spartan":
				{
					if (onAir)
						break;

					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX, posY, posZ, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5D, 0, 0.5D, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX, posY, posZ, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX, posY - 0.2D, posZ, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(0.5D, 0, 0.5D, true));
					netHandlerPlayClient.addToSendQueue(classProvider.createCPacketPlayerPosition(posX + 0.5D, posY, posZ + 0.5D, true));

					final double x = sin * 0.04D;
					final double z = cos * 0.04D;

					mc.getThePlayer().setPosition(posX + x, posY, posZ + z);

					tickTimer.reset();
					break;
				}
				case "clip":
				{
					for (int i = 1; i <= 10; i++)
					{
						final double x = sin * i;
						final double z = cos * i;

						final WBlockPos pos = new WBlockPos(posX + x, posY, posZ + z);
						final WBlockPos eyePos = new WBlockPos(posX + x, posY + 1, posZ + z);

						if (classProvider.isBlockAir(BlockUtils.getBlock(pos)) && classProvider.isBlockAir(BlockUtils.getBlock(eyePos)))
						{
							mc.getThePlayer().setPosition(posX + x, posY, posZ + z);
							break;
						}
					}

					tickTimer.reset();
					break;
				}
				case "aac3.5.0":
				{
					final double x = posX + sin;
					final double z = posZ + cos;

					mc.getThePlayer().setPosition(x, posY, z);

					tickTimer.reset();
					break;
				}
			}

		tickTimer.update();
	}

	@EventTarget
	public void onBlockBB(final BlockBBEvent event)
	{
		if (mc.getThePlayer() != null && BlockUtils.collideBlockIntersects(mc.getThePlayer().getEntityBoundingBox(), block -> !classProvider.isBlockAir(block)) && event.getBoundingBox() != null && event.getBoundingBox().getMaxY() > mc.getThePlayer().getEntityBoundingBox().getMinY() && !"Mineplex".equalsIgnoreCase(modeValue.get()))
		{
			final IAxisAlignedBB axisAlignedBB = event.getBoundingBox();

			event.setBoundingBox(classProvider.createAxisAlignedBB(axisAlignedBB.getMaxX(), mc.getThePlayer().getEntityBoundingBox().getMinY(), axisAlignedBB.getMaxZ(), axisAlignedBB.getMinX(), axisAlignedBB.getMinY(), axisAlignedBB.getMinZ()));
		}
	}

	@EventTarget
	public void onPacket(final PacketEvent event)
	{
		final IPacket packet = event.getPacket();

		if (classProvider.isCPacketPlayer(packet))
		{
			final ICPacketPlayer packetPlayer = packet.asCPacketPlayer();

			if ("AAC3.5.0".equalsIgnoreCase(modeValue.get()))
			{
				final float dir = MovementUtils.getDirection();

				packetPlayer.setX(packetPlayer.getX() - functions.sin(dir) * 0.00000001D);
				packetPlayer.setZ(packetPlayer.getZ() + functions.cos(dir) * 0.00000001D);
			}
		}
	}

	@EventTarget
	private void onMove(final MoveEvent event)
	{
		if (mc.getThePlayer() != null && "mineplex".equalsIgnoreCase(modeValue.get()))
		{
			if (mc.getThePlayer().isCollidedHorizontally())
				mineplexClip = true;

			if (!mineplexClip)
				return;

			mineplexTickTimer.update();

			event.setX(0);
			event.setZ(0);

			if (mineplexTickTimer.hasTimePassed(3))
			{
				mineplexTickTimer.reset();
				mineplexClip = false;
			}
			else if (mineplexTickTimer.hasTimePassed(1))
			{
				final double offset = mineplexTickTimer.hasTimePassed(2) ? 1.6D : 0.06D;
				final float dir = MovementUtils.getDirection();
				final double x = -functions.sin(dir) * offset;
				final double z = functions.cos(dir) * offset;

				mc.getThePlayer().setPosition(mc.getThePlayer().getPosX() + x, mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ() + z);
			}
		}
	}

	@EventTarget
	public void onPushOut(final PushOutEvent event)
	{
		event.cancelEvent();
	}

	@Override
	public String getTag()
	{
		return modeValue.get();
	}
}
