/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit;

import static org.lwjgl.opengl.GL11.*;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.vecmath.Vector3f;

import net.ccbluex.liquidbounce.api.enums.MaterialType;
import net.ccbluex.liquidbounce.api.minecraft.block.state.IIBlockState;
import net.ccbluex.liquidbounce.api.minecraft.client.entity.IEntityPlayerSP;
import net.ccbluex.liquidbounce.api.minecraft.renderer.entity.IRenderManager;
import net.ccbluex.liquidbounce.api.minecraft.util.IMovingObjectPosition;
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos;
import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.Render3DEvent;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.ClientUtils;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.ccbluex.liquidbounce.utils.render.RenderUtils;
import net.ccbluex.liquidbounce.value.BoolValue;
import net.ccbluex.liquidbounce.value.ListValue;

import org.lwjgl.input.Mouse;

@ModuleInfo(name = "ItemTeleport", description = "Allows you to pick up items far away.", category = ModuleCategory.EXPLOIT)
public class ItemTeleport extends Module
{

	private final ListValue modeValue = new ListValue("Mode", new String[]
	{
			"New", "Old"
	}, "New");
	private final BoolValue resetAfterTp = new BoolValue("ResetAfterTP", true);
	private final ListValue buttonValue = new ListValue("Button", new String[]
	{
			"Left", "Right", "Middle"
	}, "Middle");

	private int delay;
	private WBlockPos endPos;
	private IMovingObjectPosition objectPosition;

	@Override
	public void onDisable()
	{
		delay = 0;
		endPos = null;
		super.onDisable();
	}

	@EventTarget
	public void onUpdate(final UpdateEvent event)
	{
		if (mc.getCurrentScreen() == null && Mouse.isButtonDown(Arrays.asList(buttonValue.getValues()).indexOf(buttonValue.get())) && delay <= 0)
		{
			endPos = objectPosition.getBlockPos();

			final IIBlockState state = BlockUtils.getState(endPos);

			if (state.getBlock().getMaterial(state) == classProvider.getMaterialEnum(MaterialType.AIR))
			{
				endPos = null;
				return;
			}

			ClientUtils.displayChatMessage("\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was set to \u00A78" + endPos.getX() + "\u00A73, \u00A78" + endPos.getY() + "\u00A73, \u00A78" + endPos.getZ());
			delay = 6;
		}

		if (delay > 0)
			--delay;

		final IEntityPlayerSP thePlayer = mc.getThePlayer();

		if (thePlayer == null)
			return;

		if (endPos != null && thePlayer.isSneaking())
			if (!thePlayer.getOnGround()) {
				final double endX = endPos.getX() + 0.5D;
				final double endY = endPos.getY() + 1D;
				final double endZ = endPos.getZ() + 0.5D;

				switch (modeValue.get().toLowerCase()) {
					case "old":
						for (final Vector3f vector3f : vanillaTeleportPositions(endX, endY, endZ, 4D))
							mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.getX(), vector3f.getY(), vector3f.getZ(), false));
						break;
					case "new":
						for (final Vector3f vector3f : vanillaTeleportPositions(endX, endY, endZ, 5D)) {
							mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.getPosX(), thePlayer.getPosY(), thePlayer.getPosZ(), true));
							mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true));
							mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.getPosX(), thePlayer.getPosY(), thePlayer.getPosZ(), true));
							mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.getPosX(), thePlayer.getPosY() + 4.0, thePlayer.getPosZ(), true));
							mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true));
							MovementUtils.forward(0.04);
						}
						break;
				}

				if (resetAfterTp.get())
					endPos = null;

				ClientUtils.displayChatMessage("\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Tried to collect items");
			} else
				thePlayer.jump();
	}

	@EventTarget
	public void onRender3D(final Render3DEvent event)
	{
		objectPosition = mc.getThePlayer().rayTrace(1000, event.getPartialTicks());

		if (objectPosition.getBlockPos() == null)
			return;

		final int x = objectPosition.getBlockPos().getX();
		final int y = objectPosition.getBlockPos().getY();
		final int z = objectPosition.getBlockPos().getZ();

		final IIBlockState state = BlockUtils.getState(objectPosition.getBlockPos());

		if (!state.getBlock().getMaterial(state).equals(classProvider.getMaterialEnum(MaterialType.AIR)))
		{
			final IRenderManager renderManager = mc.getRenderManager();

			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
			glEnable(GL_BLEND);
			glLineWidth(2F);
			glDisable(GL_TEXTURE_2D);
			glDisable(GL_DEPTH_TEST);
			glDepthMask(false);

			final IIBlockState state1 = BlockUtils.getState(objectPosition.getBlockPos().up());

			RenderUtils.glColor(!state1.getBlock().getMaterial(state1).equals(classProvider.getMaterialEnum(MaterialType.AIR)) ? new Color(255, 0, 0, 90) : new Color(0, 255, 0, 90));
			RenderUtils.drawFilledBox(classProvider.createAxisAlignedBB(x - renderManager.getRenderPosX(), (y + 1) - renderManager.getRenderPosY(), z - renderManager.getRenderPosZ(), x - renderManager.getRenderPosX() + 1D, y + 1.2D - renderManager.getRenderPosY(), z - renderManager.getRenderPosZ() + 1D));
			glEnable(GL_TEXTURE_2D);
			glEnable(GL_DEPTH_TEST);
			glDepthMask(true);
			glDisable(GL_BLEND);

			RenderUtils.renderNameTag(Math.round(mc.getThePlayer().getDistance(x, y, z)) + "m", x + 0.5, y + 1.7, z + 0.5);
			classProvider.getGlStateManager().resetColor();
		}
	}

	private List<Vector3f> vanillaTeleportPositions(final double tpX, final double tpY, final double tpZ, final double speed)
	{
		final List<Vector3f> positions = new ArrayList<>();
		final double posX = tpX - mc.getThePlayer().getPosX();
		final double posZ = tpZ - mc.getThePlayer().getPosZ();
		final float yaw = (float) (Math.atan2(posZ, posX) * 180 / Math.PI - 90F);
		double tmpX;
		double tmpY = mc.getThePlayer().getPosY();
		double tmpZ;
		double steps = 1;

		for (double d = speed; d < getDistance(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), tpX, tpY, tpZ); d += speed)
			steps++;

		for (double d = speed; d < getDistance(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), tpX, tpY, tpZ); d += speed)
		{
			tmpX = mc.getThePlayer().getPosX() - Math.sin(Math.toRadians(yaw)) * d;
			tmpZ = mc.getThePlayer().getPosZ() + Math.cos(Math.toRadians(yaw)) * d;
			tmpY -= (mc.getThePlayer().getPosY() - tpY) / steps;
			positions.add(new Vector3f((float) tmpX, (float) tmpY, (float) tmpZ));
		}

		positions.add(new Vector3f((float) tpX, (float) tpY, (float) tpZ));

		return positions;
	}

	private double getDistance(final double x1, final double y1, final double z1, final double x2, final double y2, final double z2)
	{
		final double d0 = x1 - x2;
		final double d1 = y1 - y2;
		final double d2 = z1 - z2;
		return Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
	}

}
