/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import joptsimple.internal.Strings
import net.ccbluex.liquidbounce.api.minecraft.network.play.server.ISPacketTabComplete
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.IntegerValue

@ModuleInfo(name = "Plugins", description = "Allows you to see which plugins the server is using.", category = ModuleCategory.EXPLOIT)
class Plugins : Module()
{
	private val timeoutTicks = IntegerValue("Timeout", 20, 10, 200)

	private val tickTimer = TickTimer()

	private val knownAntiCheats = setOf("nocheatplus", "aac", "aacadditionpro", "spartan", "verus", "horizon", "matrix", "anticheat", "anticheatplus", "anticheatreloaded", "daedalus", "pac", "watchcat", "dakataanticheat", "minesecure")
	private val knownAntiCheatCommands = setOf("ncp", "aac", "aacap", "aacadditionpro", "spartan", "verus", "horizon", "matrix", "anticheat", "daedalus", "pac", "watchcat", "dakata", "minesecure")

	override fun onEnable()
	{
		if (mc.thePlayer == null) return

		mc.netHandler.addToSendQueue(classProvider.createCPacketTabComplete("/"))
		tickTimer.reset()
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
	{
		tickTimer.update()

		if (tickTimer.hasTimePassed(timeoutTicks.get()))
		{
			ClientUtils.displayChatMessage("\u00A7cPlugins check timed out...")
			tickTimer.reset()
			state = false
		}
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		if (classProvider.isSPacketTabComplete(event.packet))
		{
			val s3APacketTabComplete: ISPacketTabComplete = event.packet.asSPacketTabComplete()

			val plugins = ArrayList<String>()
			val commands = s3APacketTabComplete.completions

			commands.map { it.split(":") }.filter { it.size > 1 }.map { it[0].replace("/", "") }.filterNot { plugins.contains(it) && plugins.contains("\u00A7c$it") }.forEach { plugins.add("${if (knownAntiCheats.contains(it)) "\u00A7c" else ""}$it") }

			// Try another method
			if (plugins.isEmpty()) commands.map { it.split(":") }.filter { it.size == 1 }.map { it[0].replace("/", "") }.filterNot { plugins.contains("\u00A7c$it") && knownAntiCheatCommands.contains(it.toLowerCase()) }.forEach { plugins.add("\u00A7c$it") }

			plugins.sort()

			if (plugins.isNotEmpty()) ClientUtils.displayChatMessage("\u00A7aPlugins \u00A77(\u00A78" + plugins.size + "\u00A77): \u00A7c" + Strings.join(plugins.toArray(arrayOfNulls<String>(0)), "\u00A77, \u00A7c"))
			else ClientUtils.displayChatMessage("\u00A7cNo plugins found.")
			state = false
			tickTimer.reset()
		}
	}

	override val tag: String
		get() = (timeoutTicks.get() - tickTimer.tick).toString()
}
