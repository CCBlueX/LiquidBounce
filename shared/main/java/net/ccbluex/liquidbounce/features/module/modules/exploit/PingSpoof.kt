/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.api.MinecraftVersion
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotificationIcon
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerRangeValue
import net.ccbluex.liquidbounce.value.ListValue
import net.ccbluex.liquidbounce.value.ValueGroup
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue

@ModuleInfo(name = "PingSpoof", description = "Spoofs your ping to a given value. You can bypass most anti-cheats by spoofing ping to higher value.", category = ModuleCategory.EXPLOIT, supportedVersions = [MinecraftVersion.MC_1_8])
class PingSpoof : Module()
{
	/**
	 * Options
	 */
	private val keepAliveGroup = ValueGroup("KeepAlive")
	val keepAliveModeValue = ListValue("Mode", arrayOf("Ignore", "Delay", "TamperKey", "Cancel"), "Delay", "KeepAlive")
	val keepAliveDelayValue = IntegerRangeValue("Delay", 500, 1000, 0, 5000, "KeepAlive-MaxDelay" to "KeepAlive-MinDelay")
	val keepAliveTamperKeyValue = IntegerRangeValue("TamperKey", 1000, Int.MAX_VALUE, Int.MIN_VALUE, Int.MAX_VALUE, "KeepAlive-TamperKey-Bound" to "KeepAlive-TamperKey-Origin")
	private val keepAliveSendOnNextValue = BoolValue("SendOnNextKeepAliveReceived", false, "KeepAlive-SendOnNextKeepAliveReceived")

	private val clientStatusGroup = ValueGroup("ClientStatus")
	private val clientStatusModeValue = ListValue("Mode", arrayOf("Ignore", "Delay"), "Delay", "ClientStatus")
	private val clientStatusDelayValue = IntegerRangeValue("Delay", 500, 1000, 0, 5000, "ClientStatus-MaxDelay" to "ClientStatus-MinDelay")

	// Some anticheats(Verus, Spartan, WatchDog, etc.) sends C0FPacketConfirmTransaction packet to check ping instead of C00PacketKeepAlive to detect most ping-spoofers. So we need to spoof C0FPacketConfirmTransaction together to bypass them.
	private val confirmTransactionGroup = ValueGroup("ConfirmTransaction")
	val confirmTransactionModeValue = ListValue("Mode", arrayOf("Ignore", "Delay", "Cancel"), "Delay", "ConfirmTransactionPackets")
	val confirmTransactionDelayValue = IntegerRangeValue("Delay", 500, 1000, 0, 5000, "ConfirmTransaction-MaxDelay" to "ConfirmTransaction-MinDelay")
	private val confirmTransactionSendOnNextValue = BoolValue("SendOnNextConfirmTransactionReceived", false, "ConfirmTransaction-SendOnNextConfirmTransactionReceived")

	private val verboseNotification = BoolValue("VerboseNotification", false)

	/**
	 * Queues
	 */
	private val packetQueue = ConcurrentHashMap<IPacket, Long>()

	private val keepAliveQueue = ConcurrentLinkedQueue<IPacket>()
	private val confirmTransactionQueue = ConcurrentLinkedQueue<IPacket>()

	init
	{
		keepAliveGroup.addAll(keepAliveModeValue, keepAliveDelayValue, keepAliveTamperKeyValue, keepAliveSendOnNextValue)
		clientStatusGroup.addAll(clientStatusModeValue, clientStatusDelayValue)
		confirmTransactionGroup.addAll(confirmTransactionModeValue, confirmTransactionDelayValue, confirmTransactionSendOnNextValue)
	}

	override fun onDisable()
	{
		packetQueue.clear()
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		if (event.isCancelled) return

		val thePlayer = mc.thePlayer ?: return
		val networkManager = mc.netHandler.networkManager

		val packet = event.packet

		val provider = classProvider

		var delay = 0L

		val keepAliveMode = keepAliveModeValue.get()
		if (!keepAliveMode.equals("Ignore", ignoreCase = true) && provider.isCPacketKeepAlive(packet))
		{
			val keepAlive = packet.asCPacketKeepAlive()

			val sendKeepAlive = {
				if (keepAliveSendOnNextValue.get())
				{
					while (keepAliveQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(keepAliveQueue.poll())

					keepAliveQueue.offer(keepAlive)

					event.cancelEvent()
				}
				else delay = keepAliveDelayValue.getRandomDelay()
			}

			when (keepAliveMode.toLowerCase())
			{
				"delay" ->
				{
					sendKeepAlive()
					verbose { arrayOf("CPacketKeepAlive", "key=${keepAlive.key}", "behavior=delay") }
				}

				"tamperkey" ->
				{
					val prevKey = keepAlive.key
					keepAlive.key = keepAliveTamperKeyValue.getRandomDelay()
					sendKeepAlive()
					verbose { arrayOf("CPacketKeepAlive", "oldKey=${prevKey}", "behavior=tamper + delay", "newKey=${keepAlive.key}") }
				}

				else ->
				{
					event.cancelEvent()
					verbose { arrayOf("CPacketKeepAlive", "oldKey=${keepAlive.key}", "behavior=cancel") }
				}
			}
		}

		if (!clientStatusModeValue.get().equals("Ignore", ignoreCase = true) && provider.isCPacketClientStatus(packet) && !thePlayer.isDead && thePlayer.health > 0)
		{
			delay = clientStatusDelayValue.getRandomDelay()
			verbose { arrayOf("CPacketClientStatus", "status=${packet.asCPacketClientStatus().status}", "behavior=${if (event.isCancelled) "cancel" else "delay"}") }
		}

		val confirmTransactionMode = confirmTransactionModeValue.get()
		if (!confirmTransactionMode.equals("Ignore", ignoreCase = true) && provider.isCPacketConfirmTransaction(packet))
		{
			when (confirmTransactionMode.toLowerCase())
			{
				"delay" ->
				{
					if (confirmTransactionSendOnNextValue.get())
					{
						while (confirmTransactionQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(confirmTransactionQueue.poll())

						confirmTransactionQueue.offer(packet)

						event.cancelEvent()
					}
					else delay = confirmTransactionDelayValue.getRandomDelay()
				}

				"cancel" -> event.cancelEvent()
			}

			verbose {
				val confirmTransaction = packet.asCPacketConfirmTransaction()
				arrayOf("CPacketConfirmTransaction", "windowId=${confirmTransaction.windowId}", "uid=${confirmTransaction.uid}", "accepted=${confirmTransaction.accepted}}", "behavior=${if (event.isCancelled) "cancel" else "delay"}")
			}
		}

		if (delay > 0L)
		{
			packetQueue[packet] = System.currentTimeMillis() + delay
			event.cancelEvent()
		}
	}

	private fun verbose(messageSupplier: () -> Array<String>)
	{
		if (verboseNotification.get()) LiquidBounce.hud.addNotification(Notification(NotificationIcon.VERBOSE, "PingSpoof", messageSupplier(), 1000L))
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
	{
		val networkManager = mc.netHandler.networkManager

		val currentTime = System.currentTimeMillis()

		if (packetQueue.isNotEmpty()) packetQueue.filter { it.value >= currentTime }.forEach { (packet, time) ->
			networkManager.sendPacketWithoutEvent(packet)
			packetQueue.remove(packet, time)
		}
	}
}
