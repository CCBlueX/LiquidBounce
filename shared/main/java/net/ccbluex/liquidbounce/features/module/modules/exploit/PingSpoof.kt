/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.MinecraftVersion
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.timer.TimeUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue

@ModuleInfo(name = "PingSpoof", description = "Spoofs your ping to a given value. You can bypass most anti-cheats by spoofing ping to higher value.", category = ModuleCategory.EXPLOIT, supportedVersions = [MinecraftVersion.MC_1_8])
class PingSpoof : Module()
{
	/**
	 * Options
	 */
	private val spoofKeepAlive = BoolValue("SpoofKeepAlivePackets", true)
	private val keepAliveMinDelayValue: IntegerValue = object : IntegerValue("KeepAlive-MinDelay", 500, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val maxDelayValue = keepAliveMaxDelayValue.get()

			if (maxDelayValue < newValue) set(maxDelayValue)
		}
	}
	private val keepAliveMaxDelayValue: IntegerValue = object : IntegerValue("KeepAlive-MaxDelay", 1000, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val minDelayValue = keepAliveMinDelayValue.get()

			if (minDelayValue > newValue) set(minDelayValue)
		}
	}
	private val sendOnNextKeepAlive = BoolValue("SendOnNextKeepAlive", false)

	private val spoofClientStatus = BoolValue("SpoofClientStatusPackets", true)
	private val clientStatusMinDelayValue: IntegerValue = object : IntegerValue("ClientStatus-MinDelay", 500, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val maxDelayValue = clientStatusMaxDelayValue.get()

			if (maxDelayValue < newValue) set(maxDelayValue)
		}
	}
	private val clientStatusMaxDelayValue: IntegerValue = object : IntegerValue("ClientStatus-MaxDelay", 1000, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val minDelayValue = clientStatusMinDelayValue.get()

			if (minDelayValue > newValue) set(minDelayValue)
		}
	}

	// Some anticheats(Verus, Spartan, WatchDog, etc.) sends C0FPacketConfirmTransaction packet to check ping instead of C00PacketKeepAlive to detect most ping-spoofers. So we need to spoof C0FPacketConfirmTransaction together to bypass them.
	private val spoofConfirmTransactionPacket = BoolValue("SpoofConfirmTransactionPackets", false)
	private val confirmTransactionMinDelayValue: IntegerValue = object : IntegerValue("ConfirmTransaction-MinDelay", 500, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val maxDelayValue = confirmTransactionMaxDelayValue.get()

			if (maxDelayValue < newValue) set(maxDelayValue)
		}
	}
	private val confirmTransactionMaxDelayValue: IntegerValue = object : IntegerValue("ConfirmTransaction-MaxDelay", 1000, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val minDelayValue = confirmTransactionMinDelayValue.get()

			if (minDelayValue > newValue) set(minDelayValue)
		}
	}
	private val sendOnNextConfirmTransaction = BoolValue("SendOnNextConfirmTransaction", false)

	// Warning: Cancelling KeepAlive, ClientStatus, ConfirmTransaction packets are patched on some anti-cheats (ex: AAC4)
	private val cancelPacketsValue = BoolValue("CancelPackets", false)

	/**
	 * Queues
	 */
	private val packetQueue = ConcurrentHashMap<IPacket, Long>()

	private val keepAliveQueue = ConcurrentLinkedQueue<IPacket>()
	private val confirmTransactionQueue = ConcurrentLinkedQueue<IPacket>()

	override fun onDisable()
	{
		packetQueue.clear()
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		val thePlayer = mc.thePlayer ?: return
		val networkManager = mc.netHandler.networkManager

		val packet = event.packet

		val provider = classProvider

		var delay = 0L

		if (spoofKeepAlive.get() && provider.isCPacketKeepAlive(packet))
		{
			if (sendOnNextKeepAlive.get())
			{
				while (keepAliveQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(keepAliveQueue.poll())

				keepAliveQueue.offer(packet)

				event.cancelEvent()
			}
			else delay = TimeUtils.randomDelay(keepAliveMinDelayValue.get(), keepAliveMaxDelayValue.get())
		}

		if (spoofClientStatus.get() && provider.isCPacketClientStatus(packet) && !thePlayer.isDead && thePlayer.health > 0) delay = TimeUtils.randomDelay(clientStatusMinDelayValue.get(), clientStatusMaxDelayValue.get())

		if (spoofConfirmTransactionPacket.get() && provider.isCPacketConfirmTransaction(packet))
		{
			if (sendOnNextConfirmTransaction.get())
			{
				while (confirmTransactionQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(confirmTransactionQueue.poll())

				confirmTransactionQueue.offer(packet)

				event.cancelEvent()
			}
			else delay = TimeUtils.randomDelay(confirmTransactionMinDelayValue.get(), confirmTransactionMaxDelayValue.get())
		}

		if (delay > 0L)
		{
			if (!cancelPacketsValue.get()) packetQueue[packet] = System.currentTimeMillis() + delay
			event.cancelEvent()
		}
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
	{
		if (cancelPacketsValue.get()) return

		val networkManager = mc.netHandler.networkManager

		val currentTime = System.currentTimeMillis()

		packetQueue.filter { it.value >= currentTime }.forEach { (packet, time) ->
			networkManager.sendPacketWithoutEvent(packet)
			packetQueue.remove(packet, time)
		}
	}
}
