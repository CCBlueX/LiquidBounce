/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.MinecraftVersion
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.timer.TimeUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue
import kotlin.random.Random

@ModuleInfo(name = "PingSpoof", description = "Spoofs your ping to a given value. You can bypass most anti-cheats by spoofing ping to higher value.", category = ModuleCategory.EXPLOIT, supportedVersions = [MinecraftVersion.MC_1_8])
class PingSpoof : Module()
{
	/**
	 * Options
	 */
	val keepAliveModeValue = ListValue("KeepAlive", arrayOf("Ignore", "Delay", "TamperKey", "Cancel"), "Delay")
	val keepAliveMinDelayValue: IntegerValue = object : IntegerValue("KeepAlive-MinDelay", 500, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val maxDelayValue = keepAliveMaxDelayValue.get()

			if (maxDelayValue < newValue) set(maxDelayValue)
		}
	}
	val keepAliveMaxDelayValue: IntegerValue = object : IntegerValue("KeepAlive-MaxDelay", 1000, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val minDelayValue = keepAliveMinDelayValue.get()

			if (minDelayValue > newValue) set(minDelayValue)
		}
	}
	val keepAliveTamperKeyOriginValue: IntegerValue = object : IntegerValue("KeepAlive-TamperKey-Origin", 1000, Int.MIN_VALUE, Int.MAX_VALUE)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val maxDelayValue = keepAliveTamperKeyBoundValue.get()

			if (maxDelayValue < newValue) set(maxDelayValue)
		}
	}
	val keepAliveTamperKeyBoundValue: IntegerValue = object : IntegerValue("KeepAlive-TamperKey-Bound", Int.MAX_VALUE, Int.MIN_VALUE, Int.MAX_VALUE)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val minDelayValue = keepAliveTamperKeyOriginValue.get()

			if (minDelayValue > newValue) set(minDelayValue)
		}
	}
	private val sendOnNextKeepAlive = BoolValue("KeepAlive-SendOnNextKeepAliveReceived", false)

	val clientStatusModeValue = ListValue("ClientStatus", arrayOf("Ignore", "Delay"), "Delay")
	val clientStatusMinDelayValue: IntegerValue = object : IntegerValue("ClientStatus-MinDelay", 500, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val maxDelayValue = clientStatusMaxDelayValue.get()

			if (maxDelayValue < newValue) set(maxDelayValue)
		}
	}
	val clientStatusMaxDelayValue: IntegerValue = object : IntegerValue("ClientStatus-MaxDelay", 1000, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val minDelayValue = clientStatusMinDelayValue.get()

			if (minDelayValue > newValue) set(minDelayValue)
		}
	}

	// Some anticheats(Verus, Spartan, WatchDog, etc.) sends C0FPacketConfirmTransaction packet to check ping instead of C00PacketKeepAlive to detect most ping-spoofers. So we need to spoof C0FPacketConfirmTransaction together to bypass them.
	val confirmTransactionModeValue = ListValue("ConfirmTransactionPackets", arrayOf("Ignore", "Delay", "Cancel"), "Delay")
	val confirmTransactionMinDelayValue: IntegerValue = object : IntegerValue("ConfirmTransaction-MinDelay", 500, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val maxDelayValue = confirmTransactionMaxDelayValue.get()

			if (maxDelayValue < newValue) set(maxDelayValue)
		}
	}
	val confirmTransactionMaxDelayValue: IntegerValue = object : IntegerValue("ConfirmTransaction-MaxDelay", 1000, 0, 5000)
	{
		override fun onChanged(oldValue: Int, newValue: Int)
		{
			val minDelayValue = confirmTransactionMinDelayValue.get()

			if (minDelayValue > newValue) set(minDelayValue)
		}
	}
	private val sendOnNextConfirmTransaction = BoolValue("ConfirmTransaction-SendOnNextConfirmTransactionReceived", false)

	/**
	 * Queues
	 */
	private val packetQueue = ConcurrentHashMap<IPacket, Long>()

	private val keepAliveQueue = ConcurrentLinkedQueue<IPacket>()
	private val confirmTransactionQueue = ConcurrentLinkedQueue<IPacket>()

	override fun onDisable()
	{
		packetQueue.clear()
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		val thePlayer = mc.thePlayer ?: return
		val networkManager = mc.netHandler.networkManager

		val packet = event.packet

		val provider = classProvider

		var delay = 0L

		val keepAliveMode = keepAliveModeValue.get()
		if (!keepAliveMode.equals("Ignore", ignoreCase = true) && provider.isCPacketKeepAlive(packet))
		{
			val keepAlive = packet.asCPacketKeepAlive()

			val sendKeepAlive = {
				if (sendOnNextKeepAlive.get())
				{
					while (keepAliveQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(keepAliveQueue.poll())

					keepAliveQueue.offer(keepAlive)

					event.cancelEvent()
				}
				else delay = TimeUtils.randomDelay(keepAliveMinDelayValue.get(), keepAliveMaxDelayValue.get())
			}
			when (keepAliveMode.toLowerCase())
			{
				"delay" -> sendKeepAlive()

				"tamperkey" ->
				{
					keepAlive.key = Random.nextInt(keepAliveTamperKeyOriginValue.get(), keepAliveTamperKeyBoundValue.get())
					sendKeepAlive()
				}

				else -> event.cancelEvent()
			}
		}

		if (!clientStatusModeValue.get().equals("Ignore", ignoreCase = true) && provider.isCPacketClientStatus(packet) && !thePlayer.isDead && thePlayer.health > 0) delay = TimeUtils.randomDelay(clientStatusMinDelayValue.get(), clientStatusMaxDelayValue.get())

		val confirmTransactionMode = confirmTransactionModeValue.get()
		if (!confirmTransactionMode.equals("Ignore", ignoreCase = true) && provider.isCPacketConfirmTransaction(packet))
		{
			when (confirmTransactionMode.toLowerCase())
			{
				"delay" ->
				{
					if (sendOnNextConfirmTransaction.get())
					{
						while (confirmTransactionQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(confirmTransactionQueue.poll())

						confirmTransactionQueue.offer(packet)

						event.cancelEvent()
					}
					else delay = TimeUtils.randomDelay(confirmTransactionMinDelayValue.get(), confirmTransactionMaxDelayValue.get())
				}

				"cancel" -> event.cancelEvent()
			}
		}

		if (delay > 0L)
		{
			packetQueue[packet] = System.currentTimeMillis() + delay
			event.cancelEvent()
		}
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
	{
		val networkManager = mc.netHandler.networkManager

		val currentTime = System.currentTimeMillis()

		if (packetQueue.isNotEmpty()) packetQueue.filter { it.value >= currentTime }.forEach { (packet, time) ->
			networkManager.sendPacketWithoutEvent(packet)
			packetQueue.remove(packet, time)
		}
	}
}
