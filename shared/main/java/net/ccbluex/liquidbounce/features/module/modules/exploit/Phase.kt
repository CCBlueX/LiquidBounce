/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.MovementUtils.getDirection
import net.ccbluex.liquidbounce.utils.block.BlockUtils
import net.ccbluex.liquidbounce.utils.block.BlockUtils.collideBlockIntersects
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.ListValue

@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
class Phase : Module()
{
	private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex", "AAC4-Cage", "RedeSky-Cage"), "Vanilla")

	private val tickTimer = TickTimer()

	private var mineplexClip = false
	private val mineplexTickTimer = TickTimer()

	private var stage = 0 // TODO: rename to aac4Stage

	override fun onEnable()
	{
		stage = 0
		if (modeValue.get().equals("AAC4-Cage", ignoreCase = true)) mc.timer.timerSpeed = 0.1F
	}

	override fun onDisable()
	{
		if (modeValue.get().equals("AAC4-Cage", ignoreCase = true)) mc.timer.timerSpeed = 1F
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent?)
	{
		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val provider = classProvider

		val mode = modeValue.get().toLowerCase()

		// AAC4, RedeSky Cage phase from FDPClient (https://github.com/Project-EZ4H/FDPClient)
		when (mode)
		{
			"aac4-cage" ->
			{
				when (stage)
				{
					1 ->
					{
						thePlayer.sendQueue.addToSendQueue(provider.createCPacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 0.00000001, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
						thePlayer.sendQueue.addToSendQueue(provider.createCPacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 1, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
					}

					3 -> state = false
				}

				stage++

				return
			}

			"redesky-cage" ->
			{
				when (stage)
				{
					0 ->
					{
						thePlayer.setPosition(thePlayer.posX, thePlayer.posY - 0.00000001, thePlayer.posZ)
						thePlayer.sendQueue.addToSendQueue(provider.createCPacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 0.00000001, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
					}

					1 ->
					{
						thePlayer.setPosition(thePlayer.posX, thePlayer.posY - 1, thePlayer.posZ)
						thePlayer.sendQueue.addToSendQueue(provider.createCPacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 1, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
					}

					3 -> state = false
				}
				stage++

				return
			}

			else ->
			{
			}
		}

		val isInsideBlock = collideBlockIntersects(theWorld, thePlayer.entityBoundingBox) { !provider.isBlockAir(it.block) && !BlockUtils.isReplaceable(theWorld, it) }
		if (isInsideBlock && !modeValue.get().equals("Mineplex", ignoreCase = true))
		{
			thePlayer.noClip = true
			thePlayer.motionY = 0.0
			thePlayer.onGround = false
		}

		val netHandler = mc.netHandler

		val func = functions

		val dir = getDirection(thePlayer)
		val sin = -func.sin(dir)
		val cos = func.cos(dir)

		val posX = thePlayer.posX
		val posY = thePlayer.posY
		val posZ = thePlayer.posZ
		val onGround = thePlayer.onGround

		if (tickTimer.hasTimePassed(2) && thePlayer.isCollidedHorizontally && (!isInsideBlock || thePlayer.sneaking)) when (mode)
		{
			"vanilla" -> if (onGround)
			{
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY + 0.2, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX + 0.5, posY, posZ + 0.5, true))

				val x = sin * 0.04
				val z = cos * 0.04

				thePlayer.setPosition(posX + x, posY, posZ + z)
				tickTimer.reset()
			}

			"skip" -> if (onGround)
			{

				val x = sin * 0.3
				val z = cos * 0.3

				repeat(3) {
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY + 0.06, posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX + x * it, posY, posZ + z * it, true))
				}

				thePlayer.entityBoundingBox = thePlayer.entityBoundingBox.offset(x, 0.0, z)
				thePlayer.setPositionAndUpdate(posX + x, posY, posZ + z)
				tickTimer.reset()
			}

			"spartan" -> if (onGround)
			{
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY - 0.2, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX + 0.5, posY, posZ + 0.5, true))

				val x = sin * 0.04
				val z = cos * 0.04

				thePlayer.setPosition(posX + x, posY, posZ + z)
				tickTimer.reset()
			}

			"clip" ->
			{
				run {
					(1..10).map { sin * it to cos * it }.firstOrNull { (x, z) ->
						val pos = WBlockPos(posX + x, posY, posZ + z)
						val eyePos = WBlockPos(posX + x, posY + 1, posZ + z)
						provider.isBlockAir(BlockUtils.getBlock(theWorld, pos)) && provider.isBlockAir(BlockUtils.getBlock(theWorld, eyePos))
					}?.let { (x, z) -> thePlayer.setPosition(posX + x, posY, posZ + z) }
				}

				tickTimer.reset()
			}

			"aac3.5.0" ->
			{
				val x = posX + sin
				val z = posZ + cos

				thePlayer.setPosition(x, posY, z)
				tickTimer.reset()
			}
		}

		tickTimer.update()
	}

	@EventTarget
	fun onBlockBB(event: BlockBBEvent)
	{
		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val provider = classProvider

		if (collideBlockIntersects(theWorld, thePlayer.entityBoundingBox) { !provider.isBlockAir(it.block) } && (event.boundingBox ?: return).maxY > thePlayer.entityBoundingBox.minY && !modeValue.get().equals("Mineplex", ignoreCase = true))
		{
			val axisAlignedBB = event.boundingBox ?: return

			event.boundingBox = provider.createAxisAlignedBB(axisAlignedBB.maxX, thePlayer.entityBoundingBox.minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ)
		}
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		val packet = event.packet

		if (classProvider.isCPacketPlayer(packet))
		{
			val packetPlayer = packet.asCPacketPlayer()

			if (modeValue.get().equals("AAC3.5.0", ignoreCase = true))
			{
				val thePlayer = mc.thePlayer ?: return

				val func = functions

				val dir = getDirection(thePlayer)
				packetPlayer.x -= func.sin(dir) * 0.00000001
				packetPlayer.z += func.cos(dir) * 0.00000001
			}
		}
	}

	@EventTarget
	private fun onMove(event: MoveEvent)
	{
		val thePlayer = mc.thePlayer ?: return

		if (modeValue.get().equals("Mineplex", ignoreCase = true))
		{
			if (thePlayer.isCollidedHorizontally) mineplexClip = true
			if (!mineplexClip) return

			mineplexTickTimer.update()
			event.x = 0.0
			event.z = 0.0

			if (mineplexTickTimer.hasTimePassed(3))
			{
				mineplexTickTimer.reset()
				mineplexClip = false
			}
			else if (mineplexTickTimer.hasTimePassed(1))
			{
				val func = functions

				val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
				val dir = getDirection(thePlayer)

				thePlayer.setPosition(thePlayer.posX - func.sin(dir) * offset, thePlayer.posY, thePlayer.posZ + func.cos(dir) * offset)
			}
		}
	}

	@EventTarget
	fun onPushOut(event: PushOutEvent)
	{
		event.cancelEvent()
	}

	override val tag: String
		get() = modeValue.get()
}
