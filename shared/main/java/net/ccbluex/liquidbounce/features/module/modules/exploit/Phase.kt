/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.minecraft.client.block.IBlock
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.MovementUtils.getDirection
import net.ccbluex.liquidbounce.utils.block.BlockUtils.collideBlockIntersects
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getBlock
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.ListValue

@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
class Phase : Module()
{
	private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"), "Vanilla")
	private val tickTimer = TickTimer()
	private var mineplexClip = false
	private val mineplexTickTimer = TickTimer()

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent?)
	{
		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val provider = classProvider

		val isInsideBlock = collideBlockIntersects(theWorld, thePlayer.entityBoundingBox) { block: IBlock? -> !provider.isBlockAir(block) }
		if (isInsideBlock && !"Mineplex".equals(modeValue.get(), ignoreCase = true))
		{
			thePlayer.noClip = true
			thePlayer.motionY = 0.0
			thePlayer.onGround = false
		}

		val netHandler = mc.netHandler

		val func = functions

		val dir = getDirection(thePlayer)
		val sin = -func.sin(dir)
		val cos = func.cos(dir)

		val posX = thePlayer.posX
		val posY = thePlayer.posY
		val posZ = thePlayer.posZ
		val onGround = thePlayer.onGround

		if (tickTimer.hasTimePassed(2) && thePlayer.isCollidedHorizontally && (!isInsideBlock || thePlayer.sneaking)) when (modeValue.get().toLowerCase())
		{
			"vanilla" -> if (onGround)
			{
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY + 0.2, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX + 0.5, posY, posZ + 0.5, true))

				val x = sin * 0.04
				val z = cos * 0.04

				thePlayer.setPosition(posX + x, posY, posZ + z)
				tickTimer.reset()
			}

			"skip" -> if (onGround)
			{

				val x = sin * 0.3
				val z = cos * 0.3

				repeat(3) {
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY + 0.06, posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX + x * it, posY, posZ + z * it, true))
				}

				thePlayer.entityBoundingBox = thePlayer.entityBoundingBox.offset(x, 0.0, z)
				thePlayer.setPositionAndUpdate(posX + x, posY, posZ + z)
				tickTimer.reset()
			}

			"spartan" -> if (onGround)
			{
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX, posY - 0.2, posZ, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(0.5, 0.0, 0.5, true))
				netHandler.addToSendQueue(provider.createCPacketPlayerPosition(posX + 0.5, posY, posZ + 0.5, true))

				val x = sin * 0.04
				val z = cos * 0.04

				thePlayer.setPosition(posX + x, posY, posZ + z)
				tickTimer.reset()
			}

			"clip" ->
			{
				run {
					(1..10).map { sin * it to cos * it }.firstOrNull { (x, z) ->
						val pos = WBlockPos(posX + x, posY, posZ + z)
						val eyePos = WBlockPos(posX + x, posY + 1, posZ + z)
						provider.isBlockAir(getBlock(theWorld, pos)) && provider.isBlockAir(getBlock(theWorld, eyePos))
					}?.let { (x, z) -> thePlayer.setPosition(posX + x, posY, posZ + z) }
				}

				tickTimer.reset()
			}

			"aac3.5.0" ->
			{
				val x = posX + sin
				val z = posZ + cos

				thePlayer.setPosition(x, posY, z)
				tickTimer.reset()
			}
		}

		tickTimer.update()
	}

	@EventTarget
	fun onBlockBB(event: BlockBBEvent)
	{
		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val provider = classProvider

		if (collideBlockIntersects(theWorld, thePlayer.entityBoundingBox) { block: IBlock? -> !provider.isBlockAir(block) } && (event.boundingBox ?: return).maxY > thePlayer.entityBoundingBox.minY && !"Mineplex".equals(modeValue.get(), ignoreCase = true))
		{
			val axisAlignedBB = event.boundingBox ?: return

			event.boundingBox = provider.createAxisAlignedBB(axisAlignedBB.maxX, thePlayer.entityBoundingBox.minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ)
		}
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		val packet = event.packet

		if (classProvider.isCPacketPlayer(packet))
		{
			val packetPlayer = packet.asCPacketPlayer()

			if ("AAC3.5.0".equals(modeValue.get(), ignoreCase = true))
			{
				val thePlayer = mc.thePlayer ?: return

				val func = functions

				val dir = getDirection(thePlayer)
				packetPlayer.x = packetPlayer.x - func.sin(dir) * 0.00000001
				packetPlayer.z = packetPlayer.z + func.cos(dir) * 0.00000001
			}
		}
	}

	@EventTarget
	private fun onMove(event: MoveEvent)
	{
		val thePlayer = mc.thePlayer ?: return

		if ("Mineplex".equals(modeValue.get(), ignoreCase = true))
		{
			if (thePlayer.isCollidedHorizontally) mineplexClip = true
			if (!mineplexClip) return

			mineplexTickTimer.update()
			event.x = 0.0
			event.z = 0.0

			if (mineplexTickTimer.hasTimePassed(3))
			{
				mineplexTickTimer.reset()
				mineplexClip = false
			}
			else if (mineplexTickTimer.hasTimePassed(1))
			{
				val func = functions

				val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
				val dir = getDirection(thePlayer)
				val x = -func.sin(dir) * offset
				val z = func.cos(dir) * offset

				thePlayer.setPosition(thePlayer.posX + x, thePlayer.posY, thePlayer.posZ + z)
			}
		}
	}

	@EventTarget
	fun onPushOut(event: PushOutEvent)
	{
		event.cancelEvent()
	}

	override val tag: String
		get() = modeValue.get()
}
