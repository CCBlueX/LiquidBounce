/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.api.enums.MaterialType
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket
import net.ccbluex.liquidbounce.api.minecraft.network.play.client.ICPacketEntityAction
import net.ccbluex.liquidbounce.api.minecraft.util.IMovingObjectPosition
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos
import net.ccbluex.liquidbounce.api.minecraft.util.WVec3
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.movement.Fly
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.MovementUtils.forward
import net.ccbluex.liquidbounce.utils.MovementUtils.strafe
import net.ccbluex.liquidbounce.utils.PathUtils.findBlinkPath
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getBlock
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getState
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.ListValue
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11
import java.awt.Color
import java.util.*
import javax.vecmath.Vector3d
import kotlin.math.roundToInt

// TODO: Maximum packets per ticks limit
@ModuleInfo(name = "Teleport", description = "Allows you to teleport around.", category = ModuleCategory.EXPLOIT)
class Teleport : Module()
{
	/**
	 * Options
	 */
	private val modeValue = ListValue("Mode", arrayOf("Blink", "AAC1.9.10", "Rewinside", "OldRewinside", "Spoof", "Minesucht", "AAC3.5.0"), "Blink")

	private val ignoreNoCollision = BoolValue("IgnoreNoCollision", true)

	private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")

	private val blinkOffsetValue = FloatValue("Blink-Offset", 0.2f, 0.1f, 10.0f)
	private val blinkYOffsetValue = FloatValue("Blink-YOffset", 0.25f, 0.1f, 10.0f)

	private val autoDisableValue = BoolValue("AutoDisable", true)

	/**
	 * Variables
	 */
	private val flyTimer = TickTimer()

	/**
	 * Variables for AAC3.5.0 Teleport
	 */
	private var hadGround = false
	private var fixedY = 0.0
	private val packets: MutableCollection<IPacket> = ArrayList()
	private var zitter = false
	private var doTeleport = false
	private var aac3_5_0_freeze = false
	private val freezeTimer = TickTimer()

	/**
	 * Teleport Position Set Delay
	 */
	private var delay = 0

	/**
	 * Target Position
	 */
	private var endPos: WBlockPos? = null
	private var objectPosition: IMovingObjectPosition? = null

	override fun onEnable()
	{
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true))
		{
			displayChatMessage("\u00A7c>>> \u00A7a\u00A7lTeleport \u00A7fAAC 3.5.0 \u00A7c<<<")
			displayChatMessage("\u00A7cHow to teleport: \u00A7aPress " + buttonValue.get() + " mouse button.")
			displayChatMessage("\u00A7cHow to cancel teleport: \u00A7aDisable teleport module.")
		}
	}

	override fun onDisable()
	{
		fixedY = 0.0
		delay = 0
		mc.timer.timerSpeed = 1.0f
		endPos = null
		hadGround = false
		aac3_5_0_freeze = false
		flyTimer.reset()
		packets.clear()
		super.onDisable()
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent?)
	{
		val buttonIndex = arrayOf(*buttonValue.values).indexOf(buttonValue.get())

		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val autoDisable = autoDisableValue.get()

		val netHandler = mc.netHandler

		// AAC 3.5.0 Teleport
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true))
		{
			freezeTimer.update()

			if (aac3_5_0_freeze && freezeTimer.hasTimePassed(40))
			{
				freezeTimer.reset()
				aac3_5_0_freeze = false
				state = false
			}

			if (!flyTimer.hasTimePassed(60))
			{
				flyTimer.update()
				if (thePlayer.onGround) thePlayer.jump()
				else
				{
					// Trigger AAC flag for strafe (change direction in mid-air)
					forward(if (zitter) -0.21 else 0.21)
					zitter = !zitter
				}
				hadGround = false
				return
			}

			if (thePlayer.onGround) hadGround = true

			if (!hadGround) return

			if (thePlayer.onGround) thePlayer.setPositionAndUpdate(thePlayer.posX, thePlayer.posY + 0.2, thePlayer.posZ)

			thePlayer.capabilities.isFlying = false
			thePlayer.motionX = 0.0
			thePlayer.motionY = 0.0
			thePlayer.motionZ = 0.0

			val fly = LiquidBounce.moduleManager[Fly::class.java] as Fly
			val vanillaSpeed = fly.vanillaSpeedValue.get()

			if (mc.gameSettings.keyBindJump.isKeyDown) thePlayer.motionY = thePlayer.motionY + vanillaSpeed
			if (mc.gameSettings.keyBindSneak.isKeyDown) thePlayer.motionY = thePlayer.motionY - vanillaSpeed

			strafe(vanillaSpeed)

			if (Mouse.isButtonDown(buttonIndex) && !doTeleport)
			{
				thePlayer.setPositionAndUpdate(thePlayer.posX, thePlayer.posY - 11, thePlayer.posZ)
				packets.forEach(netHandler.networkManager::sendPacketWithoutEvent)
				freezeTimer.reset()
				aac3_5_0_freeze = true
			}

			doTeleport = Mouse.isButtonDown(buttonIndex)

			return
		}

		val hitPos = objectPosition?.blockPos ?: return
		val hitBlock = getBlock(hitPos) ?: return
		val hitBlockBB = hitBlock.getCollisionBoundingBox(theWorld, hitPos, hitBlock.defaultState ?: return)

		// Teleport Position Set
		if (mc.currentScreen == null && Mouse.isButtonDown(buttonIndex) && delay <= 0)
		{
			endPos = hitPos

			val state = getState(hitPos) ?: return

			if (state.block.getMaterial(state) == classProvider.getMaterialEnum(MaterialType.AIR))
			{
				endPos = null
				displayChatMessage("\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Position was reset")
				return
			}

			displayChatMessage("\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Position was set to \u00A78${hitPos.x}\u00A73, \u00A78${(hitBlockBB?.maxY ?: hitPos.y + 1.0) + fixedY}\u00A73, \u00A78${hitPos.z}")
			delay = 6
		}

		if (delay > 0) --delay

		if (endPos != null)
		{
			val endPos = endPos ?: return

			val endX = endPos.x + 0.5
			val endY: Double = (hitBlockBB?.maxY ?: endPos.y + 1.0) + fixedY
			val endZ = endPos.z + 0.5

			val mode = modeValue.get()

			when (mode.toLowerCase())
			{
				"blink" ->
				{
					if (!thePlayer.sneaking) return

					// Stop Sneak
					netHandler.addToSendQueue(classProvider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.STOP_SNEAKING))

					// Teleport
					findBlinkPath(thePlayer, endX, endY, endZ, blinkOffsetValue.get().toDouble(), blinkYOffsetValue.get().toDouble()).forEach { vector3d: Vector3d ->
						netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(vector3d.x, vector3d.y, vector3d.z, true))
						thePlayer.setPosition(endX, endY, endZ)
					}

					// Re-start Sneak
					netHandler.addToSendQueue(classProvider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.START_SNEAKING))
				}

				"aac1.9.10" ->
				{
					if (!thePlayer.sneaking) return

					// Stop Sneak
					netHandler.addToSendQueue(classProvider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.STOP_SNEAKING))

					// Teleport
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY + 5.0, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX + 0.5, thePlayer.posY, thePlayer.posZ + 0.5, true))
					forward(0.04)

					// Re-start Sneak
					netHandler.addToSendQueue(classProvider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.START_SNEAKING))
				}

				"rewinside" ->
				{
					thePlayer.motionY = 0.1
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY + 0.6, thePlayer.posZ, true))
				}

				"oldrewinside" ->
				{
					thePlayer.motionY = 0.1
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
				}

				"minesucht" ->
				{
					if (!thePlayer.sneaking) return
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(endX, endY, endZ, true))
				}
			}

			// Check Teleported and Notify
			if (thePlayer.posX.toInt() == endX.toInt() && thePlayer.posY.toInt() == endY.toInt() && thePlayer.posZ.toInt() == endZ.toInt())
			{
				displayChatMessage("\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73You were teleported to \u00A78$endX\u00A73, \u00A78$endY\u00A73, \u00A78$endZ")
				this.endPos = null
				if (autoDisable) state = false
			}
			else displayChatMessage("\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Teleport try...")
			if (mode.equals("OldRewinside", ignoreCase = true)) forward(0.04)
		}
	}

	@EventTarget
	fun onRender3D(@Suppress("UNUSED_PARAMETER") event: Render3DEvent?)
	{
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true)) return

		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val entityLookVec = thePlayer.lookVec ?: return

		val lookVec = WVec3(entityLookVec.xCoord * 300, entityLookVec.yCoord * 300, entityLookVec.zCoord * 300)
		val posVec = WVec3(thePlayer.posX, thePlayer.posY + 1.62, thePlayer.posZ)
		val pos = theWorld.rayTraceBlocks(posVec, posVec.add(lookVec), false, ignoreNoCollision.get(), false)

		val hitPos = pos?.blockPos ?: return
		val hitBlock = getBlock(hitPos) ?: return
		val hitBlockBB = hitBlock.getCollisionBoundingBox(theWorld, hitPos, hitBlock.defaultState ?: return)

		objectPosition = pos

		val belowBlockPos = WBlockPos(hitPos.x, hitPos.y - 1, hitPos.z)

		fixedY = if (classProvider.isBlockFence(getBlock(hitPos))) if (theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(hitPos.x + 0.5 - thePlayer.posX, hitPos.y + 1.5 - thePlayer.posY, hitPos.z + 0.5 - thePlayer.posZ)).isEmpty()) 0.5 else 0.0 else if (classProvider.isBlockFence(getBlock(belowBlockPos))) if (!theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(hitPos.x + 0.5 - thePlayer.posX, hitPos.y + 0.5 - thePlayer.posY, hitPos.z + 0.5 - thePlayer.posZ)).isEmpty() || hitBlockBB == null) 0.0 else 0.5 - 1 else if (classProvider.isBlockSnow(getBlock(hitPos))) 1 - 0.125 else 0.0

		val x = hitPos.x
		val y: Double = (hitBlockBB?.maxY ?: hitPos.y + 1.0) - 1.0 + fixedY
		val z = hitPos.z

		if (!classProvider.isBlockAir(getBlock(hitPos)))
		{
			val renderManager = mc.renderManager
			val renderPosX = renderManager.renderPosX
			val renderPosY = renderManager.renderPosY
			val renderPosZ = renderManager.renderPosZ

			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
			GL11.glEnable(GL11.GL_BLEND)
			GL11.glLineWidth(2.0f)
			GL11.glDisable(GL11.GL_TEXTURE_2D)
			GL11.glDisable(GL11.GL_DEPTH_TEST)
			GL11.glDepthMask(false)

			RenderUtils.glColor(if (modeValue.get().equals("Minesucht", ignoreCase = true) && thePlayer.position.y.toDouble() != y + 1) Color(255, 0, 0, 90) else if (theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(x + 0.5 - thePlayer.posX, y + 1.0 - thePlayer.posY, z + 0.5 - thePlayer.posZ)).isEmpty()) Color(0, 255, 0, 90) else Color(255, 0, 0, 90))
			RenderUtils.drawFilledBox(classProvider.createAxisAlignedBB(x - renderPosX, y + 1 - renderPosY, z - renderPosZ, x - renderPosX + 1.0, y + 1.2 - renderPosY, z - renderPosZ + 1.0))

			GL11.glEnable(GL11.GL_TEXTURE_2D)
			GL11.glEnable(GL11.GL_DEPTH_TEST)
			GL11.glDepthMask(true)
			GL11.glDisable(GL11.GL_BLEND)

			RenderUtils.renderNameTag("${thePlayer.getDistance(x + 0.5, y + 1.0, z + 0.5).roundToInt()}m", x + 0.5, y + 1.7, z + 0.5)

			GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f)
		}
	}

	@EventTarget
	fun onMove(event: MoveEvent)
	{
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true) && aac3_5_0_freeze) event.zeroXZ()
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		val packet = event.packet
		val thePlayer = mc.thePlayer ?: return

		if (classProvider.isCPacketPlayer(packet))
		{
			val packetPlayer = packet.asCPacketPlayer()

			when (modeValue.get().toLowerCase())
			{
				"spoof" ->
				{
					val pos = endPos ?: return
					packetPlayer.x = pos.x + 0.5
					packetPlayer.y = (pos.y + 1).toDouble()
					packetPlayer.z = pos.z + 0.5

					thePlayer.setPosition(pos.x + 0.5, (pos.y + 1).toDouble(), pos.z + 0.5)
				}

				"aac3.5.0" ->
				{
					if (!flyTimer.hasTimePassed(60)) return

					event.cancelEvent()

					if (!classProvider.isCPacketPlayerPosition(packet) && !classProvider.isCPacketPlayerPosLook(packet)) return

					packets.add(packet)
				}
			}
		}
	}

	override val tag: String
		get() = modeValue.get()
}
