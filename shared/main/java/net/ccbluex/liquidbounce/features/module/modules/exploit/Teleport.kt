/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.api.enums.MaterialType
import net.ccbluex.liquidbounce.api.minecraft.network.play.client.ICPacketEntityAction
import net.ccbluex.liquidbounce.api.minecraft.network.play.client.ICPacketPlayer
import net.ccbluex.liquidbounce.api.minecraft.util.IMovingObjectPosition
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos
import net.ccbluex.liquidbounce.api.minecraft.util.WVec3
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.movement.Fly
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.MovementUtils.forward
import net.ccbluex.liquidbounce.utils.MovementUtils.strafe
import net.ccbluex.liquidbounce.utils.PathUtils.findBlinkPath
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getBlock
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getState
import net.ccbluex.liquidbounce.utils.render.ColorUtils
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11.*
import java.awt.Color
import java.util.*
import javax.vecmath.Vector3d
import kotlin.math.roundToInt

// TODO: Maximum packets per ticks limit
@ModuleInfo(name = "Teleport", description = "Allows you to teleport around.", category = ModuleCategory.EXPLOIT)
class Teleport : Module()
{
	/**
	 * Options
	 */
	private val modeValue = ListValue("Mode", arrayOf("Blink", "AAC1.9.10", "Rewinside", "OldRewinside", "Spoof", "Minesucht", "AAC3.5.0"), "Blink")

	private val ignoreNoCollision = BoolValue("IgnoreNoCollision", true)

	private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")

	private val blinkOffsetValue = FloatValue("Blink-Offset", 0.2f, 0.1f, 10.0f)
	private val blinkYOffsetValue = FloatValue("Blink-YOffset", 0.25f, 0.1f, 10.0f)

	private val autoDisableValue = BoolValue("AutoDisable", true)

	private val pathEspValue = BoolValue("PathESP", true)
	private val pathEspTime = IntegerValue("PathESPTime", 1000, 100, 3000)

	private val colorRedValue = IntegerValue("PathESP-Red", 255, 0, 255)
	private val colorGreenValue = IntegerValue("PathESP-Green", 179, 0, 255)
	private val colorBlueValue = IntegerValue("PathESP-Blue", 72, 0, 255)

	private val colorRainbow = BoolValue("PathESP-Rainbow", false)
	private val rainbowSpeedValue = IntegerValue("PathESP-RainbowSpeed", 10, 1, 10)
	private val pathEspAlphaValue = IntegerValue("PathESP-Alpha", 255, 0, 255)
	private val saturationValue = FloatValue("PathESP-RainbowHSB-Saturation", 1.0f, 0.0f, 1.0f)
	private val brightnessValue = FloatValue("PathESP-RainbowHSB-Brightness", 1.0f, 0.0f, 1.0f)

	/**
	 * Variables
	 */
	private val flyTimer = TickTimer()
	private val pathESPTimer = MSTimer()
	private var path = mutableListOf<WVec3>()

	/**
	 * Variables for AAC3.5.0 Teleport
	 */
	private var hadGround = false
	private var fixedY = 0.0
	private val packets: MutableCollection<ICPacketPlayer> = ArrayList()
	private var zitter = false
	private var doTeleport = false
	private var aac3_5_0_freeze = false
	private val freezeTimer = TickTimer()

	/**
	 * Teleport Position Set Delay
	 */
	private var delay = 0

	/**
	 * Target Position
	 */
	private var endPos: WBlockPos? = null
	private var objectPosition: IMovingObjectPosition? = null

	override fun onEnable()
	{
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true))
		{
			val thePlayer = mc.thePlayer

			displayChatMessage(thePlayer, "\u00A7c>>> \u00A7a\u00A7lTeleport \u00A7fAAC 3.5.0 \u00A7c<<<")
			displayChatMessage(thePlayer, "\u00A7cHow to teleport: \u00A7aPress " + buttonValue.get() + " mouse button.")
			displayChatMessage(thePlayer, "\u00A7cHow to cancel teleport: \u00A7aDisable teleport module.")
		}

		path.clear()
	}

	override fun onDisable()
	{
		fixedY = 0.0
		delay = 0
		mc.timer.timerSpeed = 1.0f
		endPos = null
		hadGround = false
		aac3_5_0_freeze = false
		flyTimer.reset()
		packets.clear()
		path.clear()
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent?)
	{
		val buttonIndex = arrayOf(*buttonValue.values).indexOf(buttonValue.get())

		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return
		val gameSettings = mc.gameSettings
		val netHandler = mc.netHandler

		val autoDisable = autoDisableValue.get()

		// AAC 3.5.0 Teleport
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true))
		{
			freezeTimer.update()

			if (aac3_5_0_freeze && freezeTimer.hasTimePassed(40))
			{
				freezeTimer.reset()
				aac3_5_0_freeze = false
				state = false
			}

			if (!flyTimer.hasTimePassed(60))
			{
				flyTimer.update()
				if (thePlayer.onGround) thePlayer.jump()
				else
				{
					// Trigger AAC flag for strafe (change direction in mid-air)
					forward(thePlayer, if (zitter) -0.21 else 0.21)
					zitter = !zitter
				}
				hadGround = false
				return
			}

			if (thePlayer.onGround) hadGround = true

			if (!hadGround) return

			if (thePlayer.onGround) thePlayer.setPositionAndUpdate(thePlayer.posX, thePlayer.posY + 0.2, thePlayer.posZ)

			thePlayer.capabilities.isFlying = false
			MovementUtils.zeroXYZ(thePlayer)

			val fly = LiquidBounce.moduleManager[Fly::class.java] as Fly
			val vanillaSpeed = fly.vanillaSpeedValue.get()

			if (gameSettings.keyBindJump.isKeyDown) thePlayer.motionY = thePlayer.motionY + vanillaSpeed
			if (gameSettings.keyBindSneak.isKeyDown) thePlayer.motionY = thePlayer.motionY - vanillaSpeed

			strafe(thePlayer, vanillaSpeed)

			if (Mouse.isButtonDown(buttonIndex) && !doTeleport)
			{
				val pathEsp = pathEspValue.get()

				thePlayer.setPositionAndUpdate(thePlayer.posX, thePlayer.posY - 11, thePlayer.posZ)

				if (pathEsp)
				{
					path.clear()
					path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
					path.add(WVec3(thePlayer.posX, thePlayer.posY - 11, thePlayer.posZ))
				}

				packets.forEach {
					netHandler.networkManager.sendPacketWithoutEvent(it)

					if (pathEsp)
					{
						val packet = it.asCPacketPlayer()
						path.add(WVec3(packet.x, packet.y, packet.z))
					}
				}

				freezeTimer.reset()
				pathESPTimer.reset()

				aac3_5_0_freeze = true
			}

			doTeleport = Mouse.isButtonDown(buttonIndex)

			return
		}

		val hitPos = objectPosition?.blockPos ?: return
		val hitBlock = getBlock(theWorld, hitPos)
		val hitBlockBB = hitBlock.getCollisionBoundingBox(theWorld, hitPos, hitBlock.defaultState ?: return)

		val provider = classProvider

		// Teleport Position Set
		if (mc.currentScreen == null && Mouse.isButtonDown(buttonIndex) && delay <= 0)
		{
			endPos = hitPos

			val state = getState(hitPos) ?: return

			if (state.block.getMaterial(state) == provider.getMaterialEnum(MaterialType.AIR))
			{
				endPos = null
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Position was reset")
				return
			}

			displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Position was set to \u00A78${hitPos.x}\u00A73, \u00A78${(hitBlockBB?.maxY ?: hitPos.y + 1.0) + fixedY}\u00A73, \u00A78${hitPos.z}")
			delay = 6
		}

		if (delay > 0) --delay

		if (endPos != null)
		{
			val endPos = endPos ?: return

			val endX = endPos.x + 0.5
			val endY: Double = (hitBlockBB?.maxY ?: endPos.y + 1.0) + fixedY
			val endZ = endPos.z + 0.5

			val pathEsp = pathEspValue.get()

			val mode = modeValue.get()

			if (pathEsp) path.clear()

			when (mode.toLowerCase())
			{
				"blink" ->
				{
					if (!thePlayer.sneaking) return

					if (pathEsp) path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))

					// Stop Sneak
					netHandler.addToSendQueue(provider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.STOP_SNEAKING))

					// Teleport
					findBlinkPath(thePlayer, endX, endY, endZ, blinkOffsetValue.get().toDouble(), blinkYOffsetValue.get().toDouble()).forEach { vector3d: Vector3d ->
						netHandler.addToSendQueue(provider.createCPacketPlayerPosition(vector3d.x, vector3d.y, vector3d.z, true))
						if (pathEsp) path.add(WVec3(vector3d.x, vector3d.y, vector3d.z))
					}

					thePlayer.setPosition(endX, endY, endZ)
					if (pathEsp) path.add(WVec3(endX, endY, endZ))

					// Re-start Sneak
					netHandler.addToSendQueue(provider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.START_SNEAKING))
				}

				"aac1.9.10" ->
				{
					if (!thePlayer.sneaking) return

					if (pathEsp) path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))

					// Stop Sneak
					netHandler.addToSendQueue(provider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.STOP_SNEAKING))

					// Teleport
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY + 5.0, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX + 0.5, thePlayer.posY, thePlayer.posZ + 0.5, true))

					if (pathEsp)
					{
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(endX, endY, endZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY + 5, thePlayer.posZ))
						path.add(WVec3(endX, endY, endZ))
						path.add(WVec3(thePlayer.posX + 0.5, thePlayer.posY, thePlayer.posZ + 0.5))
					}

					forward(thePlayer, 0.04)

					// Re-start Sneak
					netHandler.addToSendQueue(provider.createCPacketEntityAction(thePlayer, ICPacketEntityAction.WAction.START_SNEAKING))
				}

				"rewinside" ->
				{
					thePlayer.motionY = 0.1

					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY + 0.6, thePlayer.posZ, true))


					if (pathEsp)
					{
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(endX, endY, endZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY + 0.6, thePlayer.posZ))
					}
				}

				"oldrewinside" ->
				{

					thePlayer.motionY = 0.1

					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(endX, endY, endZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))

					if (pathEsp)
					{
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(endX, endY, endZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(endX, endY, endZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
					}
				}

				"minesucht" ->
				{
					if (!thePlayer.sneaking) return

					path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))

					if (pathEsp) netHandler.addToSendQueue(provider.createCPacketPlayerPosition(endX, endY, endZ, true))
					path.add(WVec3(endX, endY, endZ))
				}
			}

			pathESPTimer.reset()

			// Check Teleported and Notify
			if (thePlayer.posX.toInt() == endX.toInt() && thePlayer.posY.toInt() == endY.toInt() && thePlayer.posZ.toInt() == endZ.toInt())
			{
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73You were teleported to \u00A78$endX\u00A73, \u00A78$endY\u00A73, \u00A78$endZ")
				this.endPos = null
				if (autoDisable) state = false
			}
			else displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Teleport try...")
			if (mode.equals("OldRewinside", ignoreCase = true)) forward(thePlayer, 0.04)
		}
	}

	@EventTarget
	fun onRender3D(@Suppress("UNUSED_PARAMETER") event: Render3DEvent?)
	{
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true)) return

		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val renderManager = mc.renderManager
		val viewerPosX = renderManager.viewerPosX
		val viewerPosY = renderManager.viewerPosY
		val viewerPosZ = renderManager.viewerPosZ

		val renderPosX = renderManager.renderPosX
		val renderPosY = renderManager.renderPosY
		val renderPosZ = renderManager.renderPosZ

		// Draw Path ESP
		if (pathEspValue.get() && path.isNotEmpty() && !pathESPTimer.hasTimePassed(pathEspTime.get().toLong()))
		{
			val customColor = Color(colorRedValue.get(), colorGreenValue.get(), colorBlueValue.get())
			val color = if (colorRainbow.get()) ColorUtils.rainbow(pathEspAlphaValue.get(), speed = rainbowSpeedValue.get(), saturation = saturationValue.get(), brightness = brightnessValue.get()) else customColor

			glPushMatrix()
			glDisable(GL_TEXTURE_2D)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
			glEnable(GL_LINE_SMOOTH)
			glEnable(GL_BLEND)
			glDisable(GL_DEPTH_TEST)
			mc.entityRenderer.disableLightmap()

			glBegin(GL_LINE_STRIP)
			RenderUtils.glColor(color)

			for (path in path) glVertex3d(path.xCoord - viewerPosX, path.yCoord - viewerPosY, path.zCoord - viewerPosZ)

			RenderUtils.resetColor()
			glEnd()

			glEnable(GL_DEPTH_TEST)
			glDisable(GL_LINE_SMOOTH)
			glDisable(GL_BLEND)
			glEnable(GL_TEXTURE_2D)
			glPopMatrix()
		}

		val entityLookVec = thePlayer.lookVec ?: return

		val lookVec = WVec3(entityLookVec.xCoord * 300, entityLookVec.yCoord * 300, entityLookVec.zCoord * 300)
		val posVec = WVec3(thePlayer.posX, thePlayer.posY + 1.62, thePlayer.posZ)
		val pos = theWorld.rayTraceBlocks(posVec, posVec.add(lookVec), false, ignoreNoCollision.get(), false)

		val hitPos = pos?.blockPos ?: return
		val hitBlock = getBlock(theWorld, hitPos)
		val hitBlockBB = hitBlock.getCollisionBoundingBox(theWorld, hitPos, hitBlock.defaultState ?: return)

		objectPosition = pos

		val belowBlockPos = WBlockPos(hitPos.x, hitPos.y - 1, hitPos.z)

		val provider = classProvider

		fixedY = if (provider.isBlockFence(getBlock(theWorld, hitPos))) if (theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(hitPos.x + 0.5 - thePlayer.posX, hitPos.y + 1.5 - thePlayer.posY, hitPos.z + 0.5 - thePlayer.posZ)).isEmpty()) 0.5 else 0.0 else if (provider.isBlockFence(getBlock(theWorld, belowBlockPos))) if (!theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(hitPos.x + 0.5 - thePlayer.posX, hitPos.y + 0.5 - thePlayer.posY, hitPos.z + 0.5 - thePlayer.posZ)).isEmpty() || hitBlockBB == null) 0.0 else 0.5 - 1 else if (provider.isBlockSnow(getBlock(theWorld, hitPos))) 1 - 0.125 else 0.0

		val x = hitPos.x
		val y: Double = (hitBlockBB?.maxY ?: hitPos.y + 1.0) - 1.0 + fixedY
		val z = hitPos.z

		if (!provider.isBlockAir(getBlock(theWorld, hitPos)))
		{
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
			glEnable(GL_BLEND)
			glLineWidth(2.0f)
			glDisable(GL_TEXTURE_2D)
			glDisable(GL_DEPTH_TEST)
			glDepthMask(false)

			RenderUtils.glColor(if (modeValue.get().equals("Minesucht", ignoreCase = true) && thePlayer.position.y.toDouble() != y + 1) Color(255, 0, 0, 90) else if (theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(x + 0.5 - thePlayer.posX, y + 1.0 - thePlayer.posY, z + 0.5 - thePlayer.posZ)).isEmpty()) Color(0, 255, 0, 90) else Color(255, 0, 0, 90))
			RenderUtils.drawFilledBox(provider.createAxisAlignedBB(x - renderPosX, y + 1 - renderPosY, z - renderPosZ, x - renderPosX + 1.0, y + 1.2 - renderPosY, z - renderPosZ + 1.0))

			glEnable(GL_TEXTURE_2D)
			glEnable(GL_DEPTH_TEST)
			glDepthMask(true)
			glDisable(GL_BLEND)

			RenderUtils.renderNameTag("${thePlayer.getDistance(x + 0.5, y + 1.0, z + 0.5).roundToInt()}m", x + 0.5, y + 1.7, z + 0.5)

			RenderUtils.resetColor()
		}
	}

	@EventTarget
	fun onMove(event: MoveEvent)
	{
		if (modeValue.get().equals("AAC3.5.0", ignoreCase = true) && aac3_5_0_freeze) event.zeroXZ()
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		val packet = event.packet
		val thePlayer = mc.thePlayer ?: return

		val provider = classProvider

		if (provider.isCPacketPlayer(packet))
		{
			val packetPlayer = packet.asCPacketPlayer()

			when (modeValue.get().toLowerCase())
			{
				"spoof" ->
				{
					val pos = endPos ?: return
					packetPlayer.x = pos.x + 0.5
					packetPlayer.y = (pos.y + 1).toDouble()
					packetPlayer.z = pos.z + 0.5

					thePlayer.setPosition(pos.x + 0.5, (pos.y + 1).toDouble(), pos.z + 0.5)
				}

				"aac3.5.0" ->
				{
					if (!flyTimer.hasTimePassed(60)) return

					event.cancelEvent()

					if (!provider.isCPacketPlayerPosition(packet) && !provider.isCPacketPlayerPosLook(packet)) return

					packets.add(packetPlayer)
				}
			}
		}
	}

	override val tag: String
		get() = modeValue.get()
}
