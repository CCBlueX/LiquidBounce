/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.enums.MaterialType
import net.ccbluex.liquidbounce.api.minecraft.client.entity.IEntityPlayerSP
import net.ccbluex.liquidbounce.api.minecraft.util.IMovingObjectPosition
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos
import net.ccbluex.liquidbounce.api.minecraft.util.WMathHelper.toDegrees
import net.ccbluex.liquidbounce.api.minecraft.util.WMathHelper.toRadians
import net.ccbluex.liquidbounce.api.minecraft.util.WVec3
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.Render3DEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.MovementUtils.forward
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getState
import net.ccbluex.liquidbounce.utils.render.ColorUtils
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11
import java.awt.Color
import java.util.*
import javax.vecmath.Vector3d
import kotlin.math.roundToInt
import kotlin.math.sqrt

@ModuleInfo(name = "ItemTeleport", description = "Allows you to pick up items far away.", category = ModuleCategory.EXPLOIT)
class ItemTeleport : Module()
{
	private val modeValue = ListValue("Mode", arrayOf("AAC3.1.6", "AAC3.3.9"), "AAC3.3.9")
	private val resetAfterTpValue = BoolValue("ResetAfterTP", true)
	private val autoDisableValue = BoolValue("AutoDisable", true)
	private val pathDistanceValue = FloatValue("PathDistance", 5.0f, 0.1f, 10.0f)
	private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")

	private val pathEspValue = BoolValue("PathESP", true)
	private val pathEspTime = IntegerValue("PathESPTime", 1000, 100, 3000)

	private val colorRedValue = IntegerValue("PathESP-Red", 255, 0, 255)
	private val colorGreenValue = IntegerValue("PathESP-Green", 179, 0, 255)
	private val colorBlueValue = IntegerValue("PathESP-Blue", 72, 0, 255)

	private val colorRainbow = BoolValue("PathESP-Rainbow", false)
	private val rainbowSpeedValue = IntegerValue("PathESP-RainbowSpeed", 10, 1, 10)
	private val saturationValue = FloatValue("PathESP-RainbowHSB-Saturation", 1.0f, 0.0f, 1.0f)
	private val brightnessValue = FloatValue("PathESP-RainbowHSB-Brightness", 1.0f, 0.0f, 1.0f)

	/**
	 * Teleport Position Set Delay
	 */
	private var delay = 0

	/**
	 * Target Position
	 */
	private var endPos: WBlockPos? = null
	private var objectPosition: IMovingObjectPosition? = null

	private val pathESPTimer = MSTimer()
	private var path = mutableListOf<WVec3>()

	override fun onDisable()
	{
		delay = 0
		endPos = null
		path.clear()
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent?)
	{
		val thePlayer = mc.thePlayer ?: return

		val provider = classProvider

		if (mc.currentScreen == null && Mouse.isButtonDown(arrayOf(*buttonValue.values).indexOf(buttonValue.get())) && delay <= 0)
		{
			val endPos = ((objectPosition ?: return).blockPos ?: return).also { endPos = it }

			val state = getState(endPos) ?: return

			if (state.block.getMaterial(state) == provider.getMaterialEnum(MaterialType.AIR))
			{
				this.endPos = null
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was reset")
				return
			}

			displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was set to \u00A78" + endPos.x + "\u00A73, \u00A78" + endPos.y + "\u00A73, \u00A78" + endPos.z)
			delay = 6
		}

		if (delay > 0) --delay

		val pathDistance = pathDistanceValue.get()

		if (endPos != null && thePlayer.sneaking) if (!thePlayer.onGround)
		{
			val endPos = endPos ?: return
			val endX = endPos.x + 0.5
			val endY = endPos.y + 1.0
			val endZ = endPos.z + 0.5

			val pathEsp = pathEspValue.get()

			val netHandler = mc.netHandler

			if (pathEsp)
			{
				path.clear()
				path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
			}

			when (modeValue.get().toLowerCase())
			{
				"aac3.1.6" -> vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble()).forEach { vector3f ->
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(vector3f.getX(), vector3f.getY(), vector3f.getZ(), false))
					if (pathEsp) path.add(WVec3(endX, endY, endZ))
				}

				"aac3.3.9" -> vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble()).forEach { vector3f ->
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY + 4.0, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true))

					if (pathEsp)
					{
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(vector3f.x, vector3f.y, vector3f.z))
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY + 4, thePlayer.posZ))
						path.add(WVec3(vector3f.x, vector3f.y, vector3f.z))
					}

					forward(thePlayer, 0.04)
				}
			}

			pathESPTimer.reset()

			if (resetAfterTpValue.get())
			{
				this.endPos = null
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was reset")
			}
			else if (autoDisableValue.get() && thePlayer.posX.toInt() == endX.toInt() && thePlayer.posY.toInt() == endY.toInt() && thePlayer.posZ.toInt() == endZ.toInt()) // Check Teleported and Notify
			{
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73You were teleported to \u00A78$endX\u00A73, \u00A78$endY\u00A73, \u00A78$endZ")
				this.endPos = null
				state = false
			}
			else displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Teleport try...")
		}
		else thePlayer.jump()
	}

	@EventTarget
	fun onRender3D(event: Render3DEvent)
	{
		val thePlayer = mc.thePlayer ?: return

		val renderManager = mc.renderManager
		val viewerPosX = renderManager.viewerPosX
		val viewerPosY = renderManager.viewerPosY
		val viewerPosZ = renderManager.viewerPosZ

		val renderPosX = renderManager.renderPosX
		val renderPosY = renderManager.renderPosY
		val renderPosZ = renderManager.renderPosZ

		// Draw Path ESP
		if (pathEspValue.get() && path.isNotEmpty() && !pathESPTimer.hasTimePassed(pathEspTime.get().toLong()))
		{
			val customColor = Color(colorRedValue.get(), colorGreenValue.get(), colorBlueValue.get())
			val color = if (colorRainbow.get()) ColorUtils.rainbow(speed = rainbowSpeedValue.get(), saturation = saturationValue.get(), brightness = brightnessValue.get()) else customColor

			GL11.glPushMatrix()
			GL11.glDisable(GL11.GL_TEXTURE_2D)
			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
			GL11.glEnable(GL11.GL_LINE_SMOOTH)
			GL11.glEnable(GL11.GL_BLEND)
			GL11.glDisable(GL11.GL_DEPTH_TEST)
			mc.entityRenderer.disableLightmap()

			GL11.glBegin(GL11.GL_LINE_STRIP)
			RenderUtils.glColor(color)

			path.asSequence().filterNotNull().forEach { GL11.glVertex3d(it.xCoord - viewerPosX, it.yCoord - viewerPosY, it.zCoord - viewerPosZ) }

			GL11.glColor4d(1.0, 1.0, 1.0, 1.0)
			GL11.glEnd()

			GL11.glEnable(GL11.GL_DEPTH_TEST)
			GL11.glDisable(GL11.GL_LINE_SMOOTH)
			GL11.glDisable(GL11.GL_BLEND)
			GL11.glEnable(GL11.GL_TEXTURE_2D)
			GL11.glPopMatrix()
		}

		objectPosition = thePlayer.rayTrace(1000.0, event.partialTicks)
		val hitPos = objectPosition?.blockPos ?: return
		val x = hitPos.x
		val y = hitPos.y
		val z = hitPos.z

		val state = getState(hitPos) ?: return

		if (state.block.getMaterial(state) != classProvider.getMaterialEnum(MaterialType.AIR))
		{
			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
			GL11.glEnable(GL11.GL_BLEND)
			GL11.glLineWidth(2.0f)
			GL11.glDisable(GL11.GL_TEXTURE_2D)
			GL11.glDisable(GL11.GL_DEPTH_TEST)
			GL11.glDepthMask(false)

			val upState = getState(hitPos.up()) ?: return

			RenderUtils.glColor(if (upState.block.getMaterial(upState) == classProvider.getMaterialEnum(MaterialType.AIR)) Color(0, 255, 0, 90) else Color(255, 0, 0, 90))
			RenderUtils.drawFilledBox(classProvider.createAxisAlignedBB(x - renderPosX, y + 1 - renderPosY, z - renderPosZ, x - renderPosX + 1.0, y + 1.2 - renderPosY, z - renderPosZ + 1.0))

			GL11.glEnable(GL11.GL_TEXTURE_2D)
			GL11.glEnable(GL11.GL_DEPTH_TEST)
			GL11.glDepthMask(true)
			GL11.glDisable(GL11.GL_BLEND)

			RenderUtils.renderNameTag(thePlayer.getDistance(x.toDouble(), y.toDouble(), z.toDouble()).roundToInt().toString() + "m", x + 0.5, y + 1.7, z + 0.5)

			classProvider.glStateManager.resetColor()
		}
	}

	override val tag: String
		get() = modeValue.get()

	companion object
	{
		private fun vanillaTeleportPositions(thePlayer: IEntityPlayerSP, tpX: Double, tpY: Double, tpZ: Double, speed: Double): List<Vector3d>
		{
			val posX = tpX - thePlayer.posX
			val posZ = tpZ - thePlayer.posZ

			val yaw = toRadians(toDegrees(StrictMath.atan2(posZ, posX).toFloat()) - 90.0f)
			var tmpY = thePlayer.posY
			var steps = 1.0

			run {
				var d = speed
				val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

				while (d < d2)
				{
					steps++
					d += speed
				}
			}

			val positions: MutableList<Vector3d> = ArrayList()
			var d = speed
			val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

			while (d < d2)
			{
				val tmpX = thePlayer.posX - functions.sin(yaw) * d
				val tmpZ = thePlayer.posZ + functions.cos(yaw) * d
				tmpY -= (thePlayer.posY - tpY) / steps

				positions.add(Vector3d(tmpX, tmpY, tmpZ))
				d += speed
			}

			positions.add(Vector3d(tpX, tpY, tpZ))

			return positions
		}

		private fun getDistance(x1: Double, y1: Double, z1: Double, x2: Double, y2: Double, z2: Double): Double
		{
			val xDelta = x1 - x2
			val yDelta = y1 - y2
			val zDelta = z1 - z2
			return sqrt(xDelta * xDelta + yDelta * yDelta + zDelta * zDelta)
		}
	}
}
