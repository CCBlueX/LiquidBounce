/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.enums.MaterialType
import net.ccbluex.liquidbounce.api.minecraft.client.entity.IEntity
import net.ccbluex.liquidbounce.api.minecraft.util.IMovingObjectPosition
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos
import net.ccbluex.liquidbounce.api.minecraft.util.WMathHelper.toDegrees
import net.ccbluex.liquidbounce.api.minecraft.util.WMathHelper.toRadians
import net.ccbluex.liquidbounce.api.minecraft.util.WVec3
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.Render3DEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.extensions.forward
import net.ccbluex.liquidbounce.utils.render.ColorUtils
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11.*
import java.awt.Color
import javax.vecmath.Vector3d
import kotlin.math.roundToInt
import kotlin.math.sqrt

@ModuleInfo(name = "ItemTeleport", description = "Allows you to pick up items far away.", category = ModuleCategory.EXPLOIT)
class ItemTeleport : Module()
{
	private val modeValue = ListValue("Mode", arrayOf("AAC3.1.6", "AAC3.3.9"), "AAC3.3.9")
	private val resetAfterTpValue = BoolValue("ResetAfterTP", true)
	private val autoDisableValue = BoolValue("AutoDisable", true)
	private val pathDistanceValue = FloatValue("PathDistance", 5.0f, 0.1f, 10.0f)
	private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")

	private val pathEspGroup = ValueGroup("PathESP")
	private val pathEspEnabledValue = BoolValue("Enabled", true, "PathESP")
	private val pathEspTimeValue = IntegerValue("KeepLength", 1000, 100, 3000, "PathESPTime")
	private val pathEspColorValue = RGBAColorValue("Color", 255, 179, 72, 255, listOf("PathESP-Red", "PathESP-Green", "PathESP-Blue", "PathESP-Alpha"))

	private val pathEspColorRainbowGroup = ValueGroup("Rainbow")
	private val pathEspColorRainbowEnabledValue = BoolValue("Enabled", false, "PathESP-Rainbow")
	private val pathEspColorRainbowSpeedValue = IntegerValue("Speed", 10, 1, 10, "PathESP-RainbowSpeed")
	private val pathEspColorRainbowSaturationValue = FloatValue("Saturation", 1.0f, 0.0f, 1.0f, "PathESP-RainbowHSB-Saturation")
	private val pathEspColorRainbowBrightnessValue = FloatValue("Brightness", 1.0f, 0.0f, 1.0f, "PathESP-RainbowHSB-Brightness")

	/**
	 * Teleport Position Set Delay
	 */
	private var delay = 0

	/**
	 * Target Position
	 */
	private var endPos: WBlockPos? = null
	private var objectPosition: IMovingObjectPosition? = null

	private val pathESPTimer = MSTimer()
	private var path = mutableListOf<WVec3>()

	init
	{
		pathEspColorRainbowGroup.addAll(pathEspColorRainbowEnabledValue, pathEspColorRainbowSpeedValue, pathEspColorRainbowSaturationValue, pathEspColorRainbowBrightnessValue)
		pathEspGroup.addAll(pathEspEnabledValue, pathEspTimeValue, pathEspColorValue, pathEspColorRainbowGroup)
	}

	override fun onDisable()
	{
		delay = 0
		endPos = null
		path.clear()
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
	{
		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val provider = classProvider

		if (mc.currentScreen == null && Mouse.isButtonDown(arrayOf(*buttonValue.values).indexOf(buttonValue.get())) && delay <= 0)
		{
			val endPos = ((objectPosition ?: return).blockPos ?: return).also { endPos = it }

			val state = theWorld.getBlockState(endPos)

			if (state.block.getMaterial(state) == provider.getMaterialEnum(MaterialType.AIR))
			{
				this.endPos = null
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was reset")
				return
			}

			displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was set to \u00A78" + endPos.x + "\u00A73, \u00A78" + endPos.y + "\u00A73, \u00A78" + endPos.z)
			delay = 6
		}

		if (delay > 0) --delay

		val pathDistance = pathDistanceValue.get()

		if (endPos != null && thePlayer.sneaking) if (!thePlayer.onGround)
		{
			val endPos = endPos ?: return
			val endX = endPos.x + 0.5
			val endY = endPos.y + 1.0
			val endZ = endPos.z + 0.5

			val pathEsp = pathEspEnabledValue.get()

			val netHandler = mc.netHandler

			if (pathEsp)
			{
				path.clear()
				path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
			}

			when (modeValue.get().toLowerCase())
			{
				"aac3.1.6" -> vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble()).forEach { vector3f ->
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(vector3f.getX(), vector3f.getY(), vector3f.getZ(), false))
					if (pathEsp) path.add(WVec3(endX, endY, endZ))
				}

				"aac3.3.9" -> vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble()).forEach { vector3f ->
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY + 4.0, thePlayer.posZ, true))
					netHandler.addToSendQueue(provider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true))

					if (pathEsp)
					{
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(vector3f.x, vector3f.y, vector3f.z))
						path.add(WVec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
						path.add(WVec3(thePlayer.posX, thePlayer.posY + 4, thePlayer.posZ))
						path.add(WVec3(vector3f.x, vector3f.y, vector3f.z))
					}

					thePlayer.forward(0.04)
				}
			}

			pathESPTimer.reset()

			if (resetAfterTpValue.get())
			{
				this.endPos = null
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was reset")
			}
			else if (autoDisableValue.get() && thePlayer.posX.toInt() == endX.toInt() && thePlayer.posY.toInt() == endY.toInt() && thePlayer.posZ.toInt() == endZ.toInt()) // Check Teleported and Notify
			{
				displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73You were teleported to \u00A78$endX\u00A73, \u00A78$endY\u00A73, \u00A78$endZ")
				this.endPos = null
				state = false
			}
			else displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Teleport try...")
		}
		else thePlayer.jump()
	}

	@EventTarget
	fun onRender3D(event: Render3DEvent)
	{
		val theWorld = mc.theWorld ?: return
		val thePlayer = mc.thePlayer ?: return

		val renderManager = mc.renderManager
		val viewerPosX = renderManager.viewerPosX
		val viewerPosY = renderManager.viewerPosY
		val viewerPosZ = renderManager.viewerPosZ

		val renderPosX = renderManager.renderPosX
		val renderPosY = renderManager.renderPosY
		val renderPosZ = renderManager.renderPosZ

		// Draw Path ESP
		if (pathEspEnabledValue.get() && path.isNotEmpty() && !pathESPTimer.hasTimePassed(pathEspTimeValue.get().toLong()))
		{
			val customColor = pathEspColorValue.get()

			val color = if (pathEspColorRainbowEnabledValue.get()) ColorUtils.rainbowRGB(pathEspColorValue.getAlpha(), speed = pathEspColorRainbowSpeedValue.get(), saturation = pathEspColorRainbowSaturationValue.get(), brightness = pathEspColorRainbowBrightnessValue.get()) else customColor

			glPushMatrix()
			glDisable(GL_TEXTURE_2D)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
			glEnable(GL_LINE_SMOOTH)
			glEnable(GL_BLEND)
			glDisable(GL_DEPTH_TEST)
			mc.entityRenderer.disableLightmap()

			glBegin(GL_LINE_STRIP)
			RenderUtils.glColor(color)

			for (path in path) glVertex3d(path.xCoord - viewerPosX, path.yCoord - viewerPosY, path.zCoord - viewerPosZ)

			RenderUtils.resetColor()
			glEnd()

			glEnable(GL_DEPTH_TEST)
			glDisable(GL_LINE_SMOOTH)
			glDisable(GL_BLEND)
			glEnable(GL_TEXTURE_2D)
			glPopMatrix()
		}

		objectPosition = thePlayer.rayTrace(1000.0, event.partialTicks)
		val hitPos = objectPosition?.blockPos ?: return
		val x = hitPos.x
		val y = hitPos.y
		val z = hitPos.z

		val state = theWorld.getBlockState(hitPos)

		val provider = classProvider

		if (state.block.getMaterial(state) != provider.getMaterialEnum(MaterialType.AIR))
		{
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
			glEnable(GL_BLEND)
			glLineWidth(2.0f)
			glDisable(GL_TEXTURE_2D)
			glDisable(GL_DEPTH_TEST)
			glDepthMask(false)

			val upState = theWorld.getBlockState(hitPos.up())

			RenderUtils.glColor(if (upState.block.getMaterial(upState) == provider.getMaterialEnum(MaterialType.AIR)) Color(0, 255, 0, 90) else Color(255, 0, 0, 90))
			RenderUtils.drawFilledBox(provider.createAxisAlignedBB(x - renderPosX, y + 1 - renderPosY, z - renderPosZ, x - renderPosX + 1.0, y + 1.2 - renderPosY, z - renderPosZ + 1.0))

			glEnable(GL_TEXTURE_2D)
			glEnable(GL_DEPTH_TEST)
			glDepthMask(true)
			glDisable(GL_BLEND)

			RenderUtils.renderNameTag("${thePlayer.getDistance(x.toDouble(), y.toDouble(), z.toDouble()).roundToInt()}m", x + 0.5, y + 1.7, z + 0.5)

			provider.glStateManager.resetColor()
		}
	}

	override val tag: String
		get() = modeValue.get()

	companion object
	{
		private fun vanillaTeleportPositions(thePlayer: IEntity, tpX: Double, tpY: Double, tpZ: Double, speed: Double): List<Vector3d>
		{
			val posX = tpX - thePlayer.posX
			val posZ = tpZ - thePlayer.posZ

			val yaw = toRadians(toDegrees(StrictMath.atan2(posZ, posX).toFloat()) - 90.0f)
			var tmpY = thePlayer.posY
			var steps = 1.0

			run {
				var d = speed
				val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

				while (d < d2)
				{
					steps++
					d += speed
				}
			}

			val positions: MutableList<Vector3d> = ArrayList()
			var d = speed
			val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

			val func = functions

			while (d < d2)
			{
				val tmpX = thePlayer.posX - func.sin(yaw) * d
				val tmpZ = thePlayer.posZ + func.cos(yaw) * d
				tmpY -= (thePlayer.posY - tpY) / steps

				positions.add(Vector3d(tmpX, tmpY, tmpZ))
				d += speed
			}

			positions.add(Vector3d(tpX, tpY, tpZ))

			return positions
		}

		private fun getDistance(x1: Double, y1: Double, z1: Double, x2: Double, y2: Double, z2: Double): Double
		{
			val xDelta = x1 - x2
			val yDelta = y1 - y2
			val zDelta = z1 - z2
			return sqrt(xDelta * xDelta + yDelta * yDelta + zDelta * zDelta)
		}
	}
}
