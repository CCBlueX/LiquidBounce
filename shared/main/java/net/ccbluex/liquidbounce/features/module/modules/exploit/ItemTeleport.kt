/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.enums.MaterialType
import net.ccbluex.liquidbounce.api.minecraft.client.entity.IEntityPlayerSP
import net.ccbluex.liquidbounce.api.minecraft.util.IMovingObjectPosition
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos
import net.ccbluex.liquidbounce.api.minecraft.util.WMathHelper.toDegrees
import net.ccbluex.liquidbounce.api.minecraft.util.WMathHelper.toRadians
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.Render3DEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.MovementUtils.forward
import net.ccbluex.liquidbounce.utils.block.BlockUtils.getState
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.ListValue
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11
import java.awt.Color
import java.util.*
import javax.vecmath.Vector3f
import kotlin.math.roundToInt
import kotlin.math.sqrt

@ModuleInfo(name = "ItemTeleport", description = "Allows you to pick up items far away.", category = ModuleCategory.EXPLOIT)
class ItemTeleport : Module()
{
	private val modeValue = ListValue("Mode", arrayOf("AAC3.1.6", "AAC3.3.9"), "AAC3.3.9")
	private val resetAfterTpValue = BoolValue("ResetAfterTP", true)
	private val autoDisableValue = BoolValue("AutoDisable", true)
	private val pathDistanceValue = FloatValue("PathDistance", 5.0f, 0.1f, 10.0f)
	private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")

	/**
	 * Teleport Position Set Delay
	 */
	private var delay = 0

	/**
	 * Target Position
	 */
	private var endPos: WBlockPos? = null
	private var objectPosition: IMovingObjectPosition? = null

	override fun onDisable()
	{
		delay = 0
		endPos = null
		super.onDisable()
	}

	@EventTarget
	fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent?)
	{
		if (mc.currentScreen == null && Mouse.isButtonDown(arrayOf(*buttonValue.values).indexOf(buttonValue.get())) && delay <= 0)
		{
			val endPos = ((objectPosition ?: return).blockPos ?: return).also { endPos = it }

			val state = getState(endPos) ?: return

			if (state.block.getMaterial(state) == classProvider.getMaterialEnum(MaterialType.AIR))
			{
				this.endPos = null
				return
			}

			displayChatMessage("\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was set to \u00A78" + endPos.x + "\u00A73, \u00A78" + endPos.y + "\u00A73, \u00A78" + endPos.z)
			delay = 6
		}

		if (delay > 0) --delay

		val thePlayer = mc.thePlayer ?: return

		val pathDistance = pathDistanceValue.get()

		if (endPos != null && thePlayer.sneaking) if (!thePlayer.onGround)
		{
			val endPos = endPos ?: return
			val endX = endPos.x + 0.5
			val endY = endPos.y + 1.0
			val endZ = endPos.z + 0.5

			val netHandler = mc.netHandler

			when (modeValue.get().toLowerCase())
			{
				"aac3.1.6" -> for (vector3f in vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble())) netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.getX().toDouble(), vector3f.getY().toDouble(), vector3f.getZ().toDouble(), false))
				"aac3.3.9" -> for (vector3f in vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble()))
				{
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.x.toDouble(), vector3f.y.toDouble(), vector3f.z.toDouble(), true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY + 4.0, thePlayer.posZ, true))
					netHandler.addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.x.toDouble(), vector3f.y.toDouble(), vector3f.z.toDouble(), true))
					forward(0.04)
				}
			}
			if (resetAfterTpValue.get()) this.endPos = null
			else if (autoDisableValue.get() && thePlayer.posX.toInt() == endX.toInt() && thePlayer.posY.toInt() == endY.toInt() && thePlayer.posZ.toInt() == endZ.toInt()) // Check Teleported and Notify
			{
				displayChatMessage("\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73You were teleported to \u00A78$endX\u00A73, \u00A78$endY\u00A73, \u00A78$endZ")
				this.endPos = null
				state = false
			}
			else displayChatMessage("\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Teleport try...")
		}
		else thePlayer.jump()
	}

	@EventTarget
	fun onRender3D(event: Render3DEvent)
	{
		val thePlayer = mc.thePlayer ?: return

		objectPosition = thePlayer.rayTrace(1000.0, event.partialTicks)
		val hitPos = objectPosition?.blockPos ?: return
		val x = hitPos.x
		val y = hitPos.y
		val z = hitPos.z

		val state = getState(hitPos) ?: return

		if (state.block.getMaterial(state) != classProvider.getMaterialEnum(MaterialType.AIR))
		{
			val renderManager = mc.renderManager
			val renderPosX = renderManager.renderPosX
			val renderPosY = renderManager.renderPosY
			val renderPosZ = renderManager.renderPosZ

			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
			GL11.glEnable(GL11.GL_BLEND)
			GL11.glLineWidth(2.0f)
			GL11.glDisable(GL11.GL_TEXTURE_2D)
			GL11.glDisable(GL11.GL_DEPTH_TEST)
			GL11.glDepthMask(false)

			val upState = getState(hitPos.up()) ?: return

			RenderUtils.glColor(if (upState.block.getMaterial(upState) == classProvider.getMaterialEnum(MaterialType.AIR)) Color(0, 255, 0, 90) else Color(255, 0, 0, 90))
			RenderUtils.drawFilledBox(classProvider.createAxisAlignedBB(x - renderPosX, y + 1 - renderPosY, z - renderPosZ, x - renderPosX + 1.0, y + 1.2 - renderPosY, z - renderPosZ + 1.0))

			GL11.glEnable(GL11.GL_TEXTURE_2D)
			GL11.glEnable(GL11.GL_DEPTH_TEST)
			GL11.glDepthMask(true)
			GL11.glDisable(GL11.GL_BLEND)

			RenderUtils.renderNameTag(thePlayer.getDistance(x.toDouble(), y.toDouble(), z.toDouble()).roundToInt().toString() + "m", x + 0.5, y + 1.7, z + 0.5)

			classProvider.getGlStateManager().resetColor()
		}
	}

	override val tag: String
		get() = modeValue.get()

	companion object
	{
		private fun vanillaTeleportPositions(thePlayer: IEntityPlayerSP, tpX: Double, tpY: Double, tpZ: Double, speed: Double): List<Vector3f>
		{
			val posX = tpX - thePlayer.posX
			val posZ = tpZ - thePlayer.posZ

			val yaw = toRadians(toDegrees(StrictMath.atan2(posZ, posX).toFloat()) - 90.0f)
			var tmpY = thePlayer.posY
			var steps = 1.0

			run {
				var d = speed
				val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

				while (d < d2)
				{
					steps++
					d += speed
				}
			}

			val positions: MutableList<Vector3f> = ArrayList()
			var d = speed
			val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

			while (d < d2)
			{
				val tmpX = thePlayer.posX - functions.sin(yaw) * d
				val tmpZ = thePlayer.posZ + functions.cos(yaw) * d

				tmpY -= (thePlayer.posY - tpY) / steps
				positions.add(Vector3f(tmpX.toFloat(), tmpY.toFloat(), tmpZ.toFloat()))
				d += speed
			}

			positions.add(Vector3f(tpX.toFloat(), tpY.toFloat(), tpZ.toFloat()))

			return positions
		}

		private fun getDistance(x1: Double, y1: Double, z1: Double, x2: Double, y2: Double, z2: Double): Double
		{
			val xDelta = x1 - x2
			val yDelta = y1 - y2
			val zDelta = z1 - z2
			return sqrt(xDelta * xDelta + yDelta * yDelta + zDelta * zDelta)
		}
	}
}
