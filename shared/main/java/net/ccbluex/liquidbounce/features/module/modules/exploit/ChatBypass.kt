/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.WorkerUtils
import net.ccbluex.liquidbounce.utils.timer.TimeUtils
import net.ccbluex.liquidbounce.value.BoolValue

@ModuleInfo(name = "ChatBypass", description = "Bypasses chat filters by replacing your chat messages to other similar characters.", category = ModuleCategory.EXPLOIT)
class ChatBypass : Module()
{
	private val cyrillicValue = object : BoolValue("Cyrillic", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			shouldUpdateMap = true
		}
	}

	private val greekValue = object : BoolValue("Greek", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			shouldUpdateMap = true
		}
	}

	private val cherokeeValue = object : BoolValue("Cherokee", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			shouldUpdateMap = true
		}
	}

	private val currencySymbolsValue = object : BoolValue("Currency-symbols", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			shouldUpdateMap = true
		}
	}

	private val letterlikeSymbolsValue = object : BoolValue("Letterlike-symbols", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			shouldUpdateMap = true
		}
	}

	private val fullwidthValue = object : BoolValue("Fullwidth-forms", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			shouldUpdateMap = true
		}
	}

	private var shouldUpdateMap = false
	private val replacements: HashMap<Char, MutableList<Char>> = HashMap(54)

	override fun onEnable()
	{
		updateReplacementMap()
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		if (classProvider.isCPacketChatMessage(event.packet))
		{
			val message = event.packet.asCPacketChatMessage().message

			if (message.isNotEmpty() && message[0] == '/') return // Command

			// Send message asynchronously after replace in done
			WorkerUtils.workers.execute { mc.netHandler.networkManager.sendPacketWithoutEvent(classProvider.createCPacketChatMessage(replace(message) ?: return@execute)) }

			event.cancelEvent()
		}
	}

	private fun updateReplacementMap()
	{
		val add = { replaceFrom: Char, replaceTo: Array<Char> ->
			val list = replacements[replaceFrom] ?: mutableListOf()
			list.addAll(replaceTo)
			replacements[replaceFrom] = list
		}

		val addSingle = { replaceFrom: Char, replaceTo: Char ->
			add(replaceFrom, arrayOf(replaceTo))
		}

		val nanoTime = System.nanoTime()

		replacements.clear()

		if (fullwidthValue.get()) (33..128).map { it.toChar() to (it + 65248).toChar() }.forEach { addSingle(it.first, it.second) }

		if (currencySymbolsValue.get())
		{
			add('C', arrayOf('\u20A1', '\u20B5'))
			add('F', arrayOf('\u20A3', '\u20A4'))
			addSingle('m', '\u20A5')
			addSingle('N', '\u20A6')
			addSingle('W', '\u20A9')
			addSingle('d', '\u20AB')
			addSingle('K', '\u20AD')
			addSingle('T', '\u20AE')
			add('P', arrayOf('\u20B1', '\u20BD'))
			addSingle('G', '\u20B2')
			addSingle('A', '\u20B3')
			addSingle('B', '\u20BF')
		}

		if (letterlikeSymbolsValue.get())
		{
			add('C', arrayOf('ℂ', '℃'))
			addSingle('E', 'ℇ')
			addSingle('F', '℉')
			addSingle('g', 'ℊ')
			add('H', arrayOf('ℋ', 'ℍ'))
			add('h', arrayOf('ℎ', 'ℏ'))
			addSingle('l', 'ℓ')
			addSingle('N', 'ℕ')
			add('R', arrayOf('ℛ', 'ℝ', '℞', '℟'))
			addSingle('Z', 'ℤ')
			addSingle('K', 'K')
			addSingle('A', 'Å')
			add('e', arrayOf('℮', 'ℯ'))
			addSingle('M', 'ℳ')
			add('i', arrayOf('ℹ', 'ⅈ'))
			addSingle('j', 'ⅉ')
			addSingle('D', 'ⅅ')
		}

		if (cherokeeValue.get())
		{
			addSingle('D', '\u13A0')
			addSingle('R', '\u13A1')
			addSingle('T', '\u13A2')
			addSingle('i', '\u13A5')
			addSingle('Y', '\u13A9')
			addSingle('A', '\u13AA')
			addSingle('J', '\u13AB')
			addSingle('E', '\u13AC')
			addSingle('W', '\u13B3')
			addSingle('M', '\u13B7')
			addSingle('H', '\u13BB')
			addSingle('G', '\u13C0')
			addSingle('Z', '\u13C3')
			addSingle('L', '\u13DE')
			addSingle('C', '\u13DF')
			addSingle('P', '\u13E2')
			addSingle('K', '\u13E6')
			addSingle('B', '\u13F4')
		}

		if (cyrillicValue.get())
		{
			addSingle('S', '\u0405')
			addSingle('I', '\u0406')
			addSingle('J', '\u0408')
			addSingle('A', '\u0410')
			addSingle('B', '\u0412')
			addSingle('E', '\u0415')
			addSingle('M', '\u041C')
			addSingle('H', '\u041D')
			addSingle('O', '\u041E')
			addSingle('P', '\u0420')
			addSingle('C', '\u0421')
			addSingle('T', '\u0422')
			addSingle('Y', '\u0423')
			addSingle('X', '\u0425')
			addSingle('b', '\u042C')
			addSingle('a', '\u0430')
			addSingle('e', '\u0435')
			addSingle('o', '\u043E')
			addSingle('p', '\u0440')
			addSingle('c', '\u0441')
			addSingle('y', '\u0443')
			addSingle('x', '\u0445')
			addSingle('s', '\u0455')
			addSingle('i', '\u0456')
			addSingle('w', '\u0461')
			addSingle('h', '\u04BB')
		}

		if (greekValue.get())
		{
			addSingle('A', '\u0391')
			addSingle('B', '\u0392')
			addSingle('E', '\u0395')
			addSingle('Z', '\u0396')
			addSingle('H', '\u0397')
			addSingle('I', '\u0399')
			addSingle('K', '\u039A')
			addSingle('M', '\u039C')
			addSingle('N', '\u039D')
			addSingle('O', '\u039F')
			addSingle('P', '\u03A1')
			addSingle('T', '\u03A4')
			addSingle('Y', '\u03A5')
			addSingle('X', '\u03A7')
			addSingle('o', '\u03BF')
		}

		ClientUtils.logger.info("[ChatBypass] Took {} to update replacement map.", TimeUtils.nanosecondsToString(System.nanoTime() - nanoTime))
	}

	private fun replace(original: String): String?
	{
		val nanoTime = System.nanoTime()

		if (shouldUpdateMap)
		{
			updateReplacementMap()
			shouldUpdateMap = false
		}

		val replaced = try
		{
			original.toCharArray().map { replacements[it]?.random() ?: it }.joinToString(separator = "") // Zero-Width Space
		}
		catch (t: Throwable)
		{
			t.printStackTrace()
			null
		}

		ClientUtils.logger.info("[ChatBypass] Took {} to replace message \"{}\" to \"{}\".", TimeUtils.nanosecondsToString(System.nanoTime() - nanoTime), original, replaced)

		return replaced
	}
}
