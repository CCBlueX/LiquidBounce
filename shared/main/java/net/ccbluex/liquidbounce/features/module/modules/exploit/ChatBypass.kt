/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.WorkerUtils
import net.ccbluex.liquidbounce.utils.misc.StringUtils
import net.ccbluex.liquidbounce.utils.timer.TimeUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import kotlin.random.Random

//  TODO: Anti-Spam bypass
// TODO: Anti-Advertisement (URL check) bypass
@ModuleInfo(name = "ChatBypass", description = "Bypasses chat filters(insult words, anti-spam, anti-advertisement, etc.) by replacing your chat messages to other similar characters. (ForceUnicodeChat)", category = ModuleCategory.EXPLOIT)
class ChatBypass : Module()
{
	/**
	 * Replace
	 */
	private val replaceValue = BoolValue("Replace", true)
	private val replaceChanceValue = IntegerValue("Replace-Chance", 100, 1, 100)

	//<editor-fold desc="Options">
	private val cyrillicValue = object : BoolValue("Replace-Cyrillic", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val greekValue = object : BoolValue("Replace-Greek", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val cherokeeValue = object : BoolValue("Replace-Cherokee", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val currencySymbolsValue = object : BoolValue("Replace-Currency_Symbols", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val canadianAboriginalSyllabicsValue = object : BoolValue("Replace-Canadian_Aboriginal_Syllabics", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val fullwidthFormsValue = object : BoolValue("Replace-Fullwidth_Forms", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val superAndSubScriptsValue = object : BoolValue("Replace-Superscripts_and_Subscripts", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val circledLatinValue = object : BoolValue("Replace-Circled_Latins", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	private val smallLatinValue = object : BoolValue("Replace-Small_Latins", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			replacementMapUpdateRequired = true
		}
	}

	/**
	 * Add
	 */
	private val addValue = BoolValue("Add", false)

	private val addChanceValue = IntegerValue("Replace-Chance", 100, 1, 100)
	private val addMaxCountValue = IntegerValue("Replace-MaxCount", 5, 1, 100)

	private val addAccentsValue = object : BoolValue("Add-Combining_Accents", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			addMapUpdateRequired = true
		}
	}

	private val addCyrillicValue = object : BoolValue("Add-Combining_Cyrillic", true)
	{
		override fun onChanged(oldValue: Boolean, newValue: Boolean)
		{
			addMapUpdateRequired = true
		}
	}
	//</editor-fold>

	private var replacementMapUpdateRequired = false
	private val replacements: HashMap<Char, MutableList<Char>> = HashMap(54)

	private var addMapUpdateRequired = false
	private val add: MutableList<Char> = ArrayList(54)

	override fun onEnable()
	{
		updateReplacementMap()
		updateAddMap()
	}

	@EventTarget
	fun onPacket(event: PacketEvent)
	{
		if (classProvider.isCPacketChatMessage(event.packet))
		{
			val message = event.packet.asCPacketChatMessage().message

			if (message.isNotEmpty() && message[0] == '/') return // Command

			// Send message asynchronously after replacing
			WorkerUtils.workers.execute { mc.netHandler.networkManager.sendPacketWithoutEvent(classProvider.createCPacketChatMessage(replace(message).ifEmpty { return@execute })) }

			event.cancelEvent()
		}
	}

	//<editor-fold desc="Update replacement map">
	private fun updateReplacementMap()
	{
		val addMulti = { replaceFrom: Char, replaceTo: Array<Char> ->
			val list = replacements[replaceFrom] ?: mutableListOf()
			list.addAll(replaceTo)
			replacements[replaceFrom] = list
		}

		val add = { replaceFrom: Char, replaceTo: Char ->
			val list = replacements[replaceFrom] ?: mutableListOf()
			list.add(replaceTo)
			replacements[replaceFrom] = list
		}

		val addBothCase = { replaceFrom: Char, replaceTo: Char ->
			add(replaceFrom.toLowerCase(), replaceTo)
			add(replaceFrom.toUpperCase(), replaceTo)
		}

		val addBothCaseMulti = { replaceFrom: Char, replaceTo: Array<Char> ->
			addMulti(replaceFrom.toLowerCase(), replaceTo)
			addMulti(replaceFrom.toUpperCase(), replaceTo)
		}

		val nanoTime = System.nanoTime()

		replacements.clear()

		if (fullwidthFormsValue.get()) (33..128).map { it.toChar() to (it + 0xFEE0).toChar() }.forEach { add(it.first, it.second) }

		if (superAndSubScriptsValue.get())
		{
			add('A', '\u1D2C')
			add('B', '\u1D2E')

			addBothCase('C', '\u1D9C')

			add('D', '\u1D30')
			add('E', '\u1D31')

			addBothCase('f', 'á¶ ')

			add('G', '\u1D33')
			add('H', '\u1D34')
			add('I', '\u1D35')
			add('J', '\u1D36')
			add('K', '\u1D37')
			add('L', '\u1D38')
			add('M', '\u1D39')
			add('N', '\u1D3A')
			add('O', '\u1D3C')
			add('P', '\u1D3E')
			add('R', '\u1D3F')
			add('T', '\u1D40')
			add('U', '\u1D41')
			add('V', '\u2C7D')
			add('W', '\u1D42')

			addBothCase('X', '\u02E3')
			addBothCase('Y', '\u02B8')
			addBothCase('Z', '\u1DBB')

			add('a', '\u1D43')
			add('b', '\u1D47')
			add('d', '\u1D48')
			add('e', '\u1D49')
			add('g', '\u1D4D')
			add('h', '\u02B0')
			add('i', '\u2071')
			add('j', '\u02B2')
			add('k', '\u1D4F')
			add('l', '\u02E1')
			add('m', '\u1D50')
			add('n', '\u207F')
			add('o', '\u1D52')
			add('p', '\u1D56')
			add('r', '\u02B3')
			add('s', '\u02E2')
			add('t', '\u1D57')
			add('u', '\u1D58')
			add('v', '\u1D5B')
			add('w', '\u02B7')

			add('1', '\u00B9')
			add('2', '\u00B2')
			add('3', '\u00B3')
			add('4', '\u2074')
			add('5', '\u2075')
			add('6', '\u2076')
			add('7', '\u2077')
			add('8', '\u2078')
			add('9', '\u2079')
			add('0', '\u2070')
		}

		if (smallLatinValue.get())
		{
			addBothCase('A', '\u1D00')
			addBothCase('B', '\u0299')
			addBothCase('C', '\u1D04')
			addBothCase('D', '\u1D05')
			addBothCase('E', '\u1D07')
			addBothCase('F', '\u0493')
			addBothCase('G', '\u0262')
			addBothCase('H', '\u029C')
			addBothCase('I', '\u026A')
			addBothCase('J', '\u1D0A')
			addBothCase('K', '\u1D0B')
			addBothCase('L', '\u029F')
			addBothCase('M', '\u1D0D')
			addBothCase('N', '\u0274')
			addBothCase('O', '\u1D0F')
			addBothCase('P', '\u1D18')
			addBothCase('Q', '\u01EB')
			addBothCase('R', '\u0280')
			addBothCase('S', 's')
			addBothCase('T', '\u1D1B')
			addBothCase('U', '\u1D1C')
			addBothCase('V', '\u1D20')
			addBothCase('W', '\u1D21')
			addBothCase('X', 'x')
			addBothCase('Y', '\u028F')
			addBothCase('Z', '\u1D22')
		}

		if (circledLatinValue.get())
		{
			(65..90).map { it.toChar() to (it + 0x2475).toChar() }.forEach { add(it.first, it.second) } // A-Z

			(97..122).forEach { addMulti(it.toChar(), arrayOf((it + 0x243B).toChar(), (it + 0x246F).toChar())) } // a-z

			(49..57).forEach { addMulti(it.toChar(), arrayOf((it + 0x242F).toChar(), (it + 0x2433).toChar(), (it + 0x2457).toChar())) } // 0-9
		}

		if (canadianAboriginalSyllabicsValue.get())
		{
			addBothCase('A', '\u15E9')
			addBothCase('B', '\u15F7')
			addBothCase('F', '\u15B4')
			addBothCase('H', '\u157C')
			addBothCase('L', '\u14AA')
			addBothCase('R', '\u1587')
			addBothCase('X', '\u166D')
		}

		if (currencySymbolsValue.get())
		{
			addBothCaseMulti('C', arrayOf('\u20A1', '\u20B5'))
			addBothCaseMulti('F', arrayOf('\u20A3', '\u20A4'))

			add('m', '\u20A5')

			addBothCase('N', '\u20A6')
			addBothCase('W', '\u20A9')

			add('d', '\u20AB')

			addBothCase('K', '\u20AD')
			addBothCase('T', '\u20AE')

			addBothCaseMulti('P', arrayOf('\u20B1', '\u20BD'))

			addBothCase('G', '\u20B2')
			addBothCase('A', '\u20B3')
			addBothCase('B', '\u20BF')
		}

		if (cherokeeValue.get())
		{
			addBothCase('A', '\u13AA')
			addBothCase('B', '\u13F4')
			addBothCase('C', '\u13DF')
			addBothCase('D', '\u13A0')
			addBothCase('E', '\u13AC')
			addBothCase('G', '\u13C0')
			addBothCase('H', '\u13BB')

			add('i', '\u13A5')

			addBothCase('J', '\u13AB')
			addBothCase('K', '\u13E6')
			addBothCase('L', '\u13DE')
			addBothCase('M', '\u13B7')
			addBothCase('P', '\u13E2')
			addBothCase('R', '\u13A1')
			addBothCase('T', '\u13A2')
			addBothCase('W', '\u13B3')
			addBothCase('Y', '\u13A9')
			addBothCase('Z', '\u13C3')
		}

		if (cyrillicValue.get())
		{
			add('A', '\u0410')
			add('B', '\u0412')
			add('C', '\u0421')
			add('E', '\u0415')
			add('S', '\u0405')
			add('H', '\u041D')
			add('I', '\u0406')
			add('J', '\u0408')
			add('M', '\u041C')
			add('O', '\u041E')
			add('P', '\u0420')
			add('T', '\u0422')
			add('X', '\u0425')
			add('Y', '\u0423')

			add('a', '\u0430')
			add('b', '\u042C')
			add('c', '\u0441')
			add('e', '\u0435')
			add('h', '\u04BB')
			add('i', '\u0456')
			add('s', '\u0455')
			add('o', '\u043E')
			add('p', '\u0440')
			add('w', '\u0461')
			add('y', '\u0443')
			add('x', '\u0445')
		}

		if (greekValue.get())
		{
			addBothCase('A', '\u0391')
			addBothCase('B', '\u0392')
			addBothCase('E', '\u0395')
			addBothCase('H', '\u0397')
			addBothCase('I', '\u0399')
			addBothCase('K', '\u039A')
			addBothCase('M', '\u039C')
			addBothCase('N', '\u039D')
			add('O', '\u039F')
			add('o', '\u03BF')
			addBothCase('P', '\u03A1')
			addBothCase('T', '\u03A4')
			addBothCase('X', '\u03A7')
			addBothCase('Y', '\u03A5')
			addBothCase('Z', '\u0396')
		}

		ClientUtils.logger.info("[ChatBypass] Took {} to update replacement map.", TimeUtils.nanosecondsToString(System.nanoTime() - nanoTime))
	}
	//</editor-fold>

	//<editor-fold desc="Update replacement map">
	private fun updateAddMap()
	{
		val add: (Collection<Char>) -> Boolean = add::addAll
		val addRange = { range: IntRange ->
			add(range.map(Int::toChar))
		}

		val nanoTime = System.nanoTime()

		this.add.clear()

		if (addAccentsValue.get())
		{
			addRange(768 /* 0x0300 */..879 /* 0x036F */) // Combining Diacritical Marks (0300-036F)
			addRange(6832 /* 0x1AB0 */..6846 /* 0x1ABE */) // Combining Diacritical Marks Extended (1AB0-1ABE)
			addRange(7616 /* 0x1DC0 */..7679 /* 0x1DFF */) // Combining Diacritical Marks Supplement (1DC0-1DFF)
			addRange(8400 /* 0x20D0 */..8447 /* 0x20FF */) // Combining Diacritical Marks for Symbols (20D0-20FF)
			addRange(65056 /* 0xFE20 */..65071 /* 0xFE2F */) // Combining Half Marks (FE20-FE2F)
		}

		if (addCyrillicValue.get())
		{
			add(listOf('\u0485', '\u0486', '\u0488', '\u0489'))
			addRange(11744 /* 0x2DE0 */..11775 /* 0x2DFF */) // Cyrillic Extended-A - Old church Slavonic combining letters (2DE0-2DFF)
		}

		ClientUtils.logger.info("[ChatBypass] Took {} to update add map.", TimeUtils.nanosecondsToString(System.nanoTime() - nanoTime))
	}
	//</editor-fold>

	private fun replace(original: String): String
	{
		val nanoTime = System.nanoTime()

		if (replacementMapUpdateRequired)
		{
			updateReplacementMap()
			replacementMapUpdateRequired = false
		}

		if (addMapUpdateRequired)
		{
			updateAddMap()
			addMapUpdateRequired = false
		}

		var modified = original

		val urlMatcher = StringUtils.URL_PATTERN.matcher(modified)

		val builder = StringBuilder(modified)
		var indexChange = 0

		// Bypass URL check
		while (urlMatcher.find())
		{
			val start = urlMatcher.start() + indexChange
			val end = urlMatcher.end() + indexChange

			val url = modified.substring(start, end).replace(".", arrayOf(",", "[.]", "(.)", "_", "(dot)", "[dot]").random()).replace("http", arrayOf("h11p", "h++p", "httq", "nttp").random()).replace("://", ":")
			builder.substring(start, end)
			builder.append(url)

			indexChange += url.length /* New String Length */ - (end - start) /* Original String Length */
		}

		// Replace
		if (replaceValue.get())
		{
			val replaceChance = replaceChanceValue.get()
			modified = modified.map { if (Random.nextInt(100) <= replaceChance) replacements[it]?.random() ?: it else it }.joinToString(separator = "")
		}

		// Add
		if (addValue.get())
		{
			val addChance = addChanceValue.get()
			val maxCount = addMaxCountValue.get()
			modified = modified.map {
				"$it${
					if (add.isNotEmpty() && Random.nextInt(100) <= addChance)
					{
						val count = Random.nextInt(1, maxCount + 1) // +1 is required to change 'exclusive bound' to 'inclusive bound'
						if (count > 0)
						{
							val b = StringBuilder(count)
							repeat(count) { b.append(add.random()) }
							"$b"
						}
						else "${add.random()}"
					}
					else ""
				}"
			}.joinToString(separator = "")
		}

		ClientUtils.logger.info("[ChatBypass] Took {} to obfuscate message \"{}\" to \"{}\".", TimeUtils.nanosecondsToString(System.nanoTime() - nanoTime), original, modified)

		return modified.take(100)
	}
}
