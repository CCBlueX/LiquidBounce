/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import io.netty.buffer.Unpooled
import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.api.MinecraftVersion
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.ListValue
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import kotlin.math.pow
import kotlin.math.roundToInt
import kotlin.math.sqrt

// Original author is Rilshrink (https://github.com/Rilshrink/Minecraft-Disablers) [Most of disablers are available in PingSpoof]
// Some codes are from FDPClient (https://github.com/Project-EZ4H/FDPClient)
@ModuleInfo(name = "Disabler", description = "Bye! Bye! Bad Anticheat -Rilshrink", category = ModuleCategory.EXPLOIT, supportedVersions = [MinecraftVersion.MC_1_8])
class Disabler : Module()
{
    private val modeValue = object : ListValue("Mode", arrayOf("ACMC.pl", "ColdNetwork", "Kauri", "OnlyMC", "HazelMC", "Verus-Combat", "EarthPol", "Verus-Move", "Matrix-Scaffold"), "Verus-Combat")
    {
        override fun onChange(oldValue: String, newValue: String)
        {
            onDisable()
        }

        override fun onChanged(oldValue: String, newValue: String)
        {
            onEnable()
        }
    }
    private val mtrxWithAACValue = BoolValue("Matrix-Scaffold_WithAAC5", false)

    private var packetBuffer = mutableListOf<IPacket>()
    private var memeTick = 0

    override fun onEnable()
    {
        val pingSpoof = LiquidBounce.moduleManager[PingSpoof::class.java] as PingSpoof

        when (modeValue.get().toLowerCase())
        {
            "acmc.pl" ->
            {
                pingSpoof.keepAliveModeValue.set("Delay")
                pingSpoof.keepAliveDelayValue.setMin(500)
                pingSpoof.keepAliveDelayValue.setMax(600)

                pingSpoof.confirmTransactionModeValue.set("Delay")
                pingSpoof.confirmTransactionDelayValue.setMin(1000)
                pingSpoof.confirmTransactionDelayValue.setMax(1250)

                pingSpoof.state = true
            }

            "coldnetwork" ->
            {
                ClientUtils.displayChatMessage(mc.thePlayer, "\u00A78[\u00A7c\u00A7lColdNetwork Disabler\u00A78] \u00A7c\u00A7lThe disabler only works temporary 10 minutes\u00A7r\u00A7c, ping spoof alerts over time.")

                pingSpoof.confirmTransactionModeValue.set("Delay")
                pingSpoof.confirmTransactionDelayValue.setMin(2000)
                pingSpoof.confirmTransactionDelayValue.setMax(2500)

                pingSpoof.state = true
            }

            "kauri" ->
            {
                ClientUtils.displayChatMessage(mc.thePlayer, "\u00A78[\u00A7c\u00A7lKauri Disabler\u00A78] \u00A7c\u00A7lRe-login for disabler to work.")

                pingSpoof.confirmTransactionModeValue.set("Cancel")

                pingSpoof.state = true
                state = false
            }

            "onlymc" ->
            {
                pingSpoof.keepAliveModeValue.set("TamperKey")
                pingSpoof.keepAliveTamperKeyValue.setMin(1000)
                pingSpoof.keepAliveTamperKeyValue.setMax(Int.MAX_VALUE)

                pingSpoof.confirmTransactionModeValue.set("Delay")
                pingSpoof.confirmTransactionDelayValue.setMin(5000)
                pingSpoof.confirmTransactionDelayValue.setMax(6000)

                pingSpoof.state = true
            }

            "hazelmc" ->
            {
                pingSpoof.keepAliveModeValue.set("Delay")
                pingSpoof.keepAliveDelayValue.setMin(5000)
                pingSpoof.keepAliveDelayValue.setMax(6000)

                pingSpoof.confirmTransactionModeValue.set("Delay")
                pingSpoof.confirmTransactionDelayValue.setMin(50)
                pingSpoof.confirmTransactionDelayValue.setMax(100)

                pingSpoof.state = true
            }

            "verus-combat" ->
            {
                pingSpoof.keepAliveModeValue.set("TamperKey")
                pingSpoof.keepAliveTamperKeyValue.setMin(1)
                pingSpoof.keepAliveTamperKeyValue.setMax(Int.MAX_VALUE)

                pingSpoof.confirmTransactionModeValue.set("Delay")
                pingSpoof.confirmTransactionDelayValue.setMin(50)
                pingSpoof.confirmTransactionDelayValue.setMax(100)

                pingSpoof.state = true
            }

            "verus-move", "matrix-scaffold" ->
            {
                pingSpoof.state = false
            }
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent)
    {
        val thePlayer = mc.thePlayer ?: return
        val networkManager = mc.netHandler.networkManager

        val packet = event.packet

        val provider = classProvider

        val mode = modeValue.get().toLowerCase()
        if (provider.isCPacketPlayer(packet))
        {
            when (mode)
            {
                "acmc.pl", "coldnetwork", "verus-combat" ->
                {
                    networkManager.sendPacketWithoutEvent(provider.createCPacketInput())

                    if (thePlayer.ticksExisted % 15 == 0) packet.asCPacketPlayer().y += RandomUtils.nextFloat(100.0F, 1000.0F)
                }

                "earthpol" -> if (thePlayer.ticksExisted % 15 == 0)
                {
                    try
                    {
                        val baos = ByteArrayOutputStream()
                        val dos = DataOutputStream(baos)
                        dos.writeUTF(thePlayer.gameProfile.name)

                        val byteBuf = provider.createPacketBuffer(Unpooled.buffer())
                        byteBuf.writeBytes(baos.toByteArray())

                        networkManager.sendPacketWithoutEvent(provider.createCPacketCustomPayload("matrix:geyser", byteBuf)) // This is due to a config error by turning on Matrix geyser support
                    }
                    catch (ignored: IOException)
                    {
                    }
                }
            }
        }

        when (mode)
        {
            "verus-move" ->
            {
                if (thePlayer.ticksExisted == 0) packetBuffer.clear()

                if (provider.isCPacketPlayer(packet))
                {
                    // Set position to a valid block height (so Spoof NoFall works)
                    val yPos = (thePlayer.posY / 0.015625).roundToInt() * 0.015625
                    thePlayer.setPosition(thePlayer.posX, yPos, thePlayer.posZ)

                    if (thePlayer.ticksExisted % 45 == 0)
                    {
                        // Clip into ground and silently accept the teleport from the server. (This fucks with teleport compensation LOL)
                        networkManager.sendPacketWithoutEvent(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                        networkManager.sendPacketWithoutEvent(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY - 11.725, thePlayer.posZ, false))
                        networkManager.sendPacketWithoutEvent(provider.createCPacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    }
                }
                else if (provider.isSPacketPlayerPosLook(packet))
                {
                    val teleport = packet.asSPacketPlayerPosLook()
                    val x = teleport.x - thePlayer.posX
                    val y = teleport.y - thePlayer.posY
                    val z = teleport.z - thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)

                    // Cancel the teleport, and silently accept it.
                    if (diff <= 8)
                    {
                        event.cancelEvent()
                        // LATEST verus ALWAYS expects a c06 within 30 seconds of a teleport if packets have been sent from the client after the teleport.
                        networkManager.sendPacketWithoutEvent(provider.createCPacketPlayerPosLook(teleport.x, teleport.y, teleport.z, teleport.yaw, teleport.pitch, true))
                    }
                }
                else if (provider.isCPacketConfirmTransaction(packet))
                {
                    for (i in 0..3)
                    {
                        // Make sure to dupe packets 4 times, since it will match up with the missing packets while keeping the anticheat disabled, in order to bypass ping spoof checks
                        // why the fuck do they not checked duped transactions? LMFAO
                        packetBuffer.add(packet)
                    }

                    event.cancelEvent()
                }
            }

            "matrix-scaffold" ->
            {
                if (provider.isCPacketPlayer(packet) && !(provider.isCPacketPlayerPosition(packet) || provider.isCPacketPlayerLook(packet) || provider.isCPacketPlayerPosLook(packet))) event.cancelEvent()

                if (provider.isCPacketPlayer(packet) || provider.isCPacketPlayerPosition(packet) || provider.isCPacketPlayerLook(packet) || provider.isCPacketPlayerPosLook(packet) || provider.isCPacketPlayerDigging(packet) || provider.isCPacketPlayerBlockPlacement(packet) || provider.isCPacketAnimation(packet) || provider.isCPacketEntityAction(packet))
                {
                    event.cancelEvent()
                    packetBuffer.add(packet)
                }
            }
        }
    }

    fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
    {
        val thePlayer = mc.thePlayer ?: return
        val timer = mc.timer
        val networkManager = mc.netHandler.networkManager

        val provider = classProvider

        when (modeValue.get().toLowerCase())
        {
            "acmc.pl" -> timer.timerSpeed = 0.4F
            "coldnetwork" -> timer.timerSpeed = 0.6F
            "onlymc" -> if (thePlayer.ticksExisted % 50 == 0) networkManager.sendPacketWithoutEvent(provider.createCPacketPlayerPosLook(thePlayer.posX, thePlayer.posY - RandomUtils.nextFloat(1000F, 2000F), thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, thePlayer.onGround))
            "hazelmc" -> networkManager.sendPacket(provider.createCPacketKeepAlive(0))

            "verus-move" ->
            {
                // Partially drain the queue every 180 ticks (9 seconds), to prevent flagging Ping Spoof.
                if (thePlayer.ticksExisted % 180 == 0)
                {
                    // grab packets untill the queue size is 22 or less.
                    while (packetBuffer.size > 22)
                    {
                        // grab 1 packet, send and then remove it from the queue
                        networkManager.sendPacketWithoutEvent(packetBuffer[0])
                        packetBuffer.removeAt(0)
                    }
                }
            }

            "matrix-scaffold" ->
            {
                memeTick++
                val cTick = if (mtrxWithAACValue.get()) (mc.timer.timerSpeed.pow(2.0F) * 10.0F).roundToInt() else (mc.timer.timerSpeed.pow(2.0F) * 7.6F).roundToInt()
                if (memeTick >= cTick)
                {
                    memeTick = 0
                    for (packet in packetBuffer) networkManager.sendPacketWithoutEvent(packet)
                    packetBuffer.clear()
                }
            }
        }
    }
}
