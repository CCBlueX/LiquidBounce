/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.injection.forge.mixins.render;

import java.util.List;

import com.google.common.base.Predicates;

import net.ccbluex.liquidbounce.LiquidBounce;
import net.ccbluex.liquidbounce.event.Render3DEvent;
import net.ccbluex.liquidbounce.features.module.modules.player.Reach;
import net.ccbluex.liquidbounce.features.module.modules.render.CameraClip;
import net.ccbluex.liquidbounce.features.module.modules.render.NoHurtCam;
import net.ccbluex.liquidbounce.features.module.modules.render.Tracers;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.ActiveRenderInfo;
import net.minecraft.client.renderer.EntityRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.item.EntityItemFrame;
import net.minecraft.entity.passive.EntityAnimal;
import net.minecraft.util.EntitySelectors;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import org.lwjgl.opengl.GL11;
import org.spongepowered.asm.mixin.Final;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Overwrite;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(EntityRenderer.class)
@SideOnly(Side.CLIENT)
public abstract class MixinEntityRenderer
{

	@Shadow
	private Entity pointedEntity;
	@Final
	@Shadow
	private Minecraft mc;
	@Final
	@Shadow
	private float thirdPersonDistance;
	@Shadow
	private boolean cloudFog;
	@Shadow
	private float thirdPersonDistancePrev;

	@Shadow
	public abstract void loadShader(ResourceLocation resourceLocationIn);

	@Shadow
	public abstract void setupCameraTransform(float partialTicks, int pass);

	@Inject(method = "renderWorldPass", at = @At(value = "FIELD", target = "Lnet/minecraft/client/renderer/EntityRenderer;renderHand:Z", shift = At.Shift.BEFORE))
	private void renderWorldPass(int pass, float partialTicks, long finishTimeNano, CallbackInfo callbackInfo)
	{
		LiquidBounce.eventManager.callEvent(new Render3DEvent(partialTicks));
	}

	@Inject(method = "hurtCameraEffect", at = @At("HEAD"), cancellable = true)
	private void injectHurtCameraEffect(CallbackInfo callbackInfo)
	{
		if (LiquidBounce.moduleManager.getModule(NoHurtCam.class).getState())
			callbackInfo.cancel();
	}

	@Inject(method = "orientCamera", at = @At(value = "INVOKE", target = "Lnet/minecraft/util/math/Vec3d;distanceTo(Lnet/minecraft/util/math/Vec3d;)D"), cancellable = true)
	private void cameraClip(float partialTicks, CallbackInfo callbackInfo)
	{
		if (LiquidBounce.moduleManager.getModule(CameraClip.class).getState())
		{
			callbackInfo.cancel();

			Entity entity = this.mc.getRenderViewEntity();
			float f = entity.getEyeHeight();

			if (entity instanceof EntityLivingBase && ((EntityLivingBase) entity).isPlayerSleeping())
			{
				f = (float) ((double) f + 1D);
				GlStateManager.translate(0F, 0.3F, 0.0F);

				if (!this.mc.gameSettings.debugCamEnable)
				{
					BlockPos blockpos = new BlockPos(entity);
					IBlockState iblockstate = this.mc.world.getBlockState(blockpos);
					net.minecraftforge.client.ForgeHooksClient.orientBedCamera(this.mc.world, blockpos, iblockstate, entity);

					GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F, 0.0F, -1.0F, 0.0F);
					GlStateManager.rotate(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks, -1.0F, 0.0F, 0.0F);
				}
			}
			else if (this.mc.gameSettings.thirdPersonView > 0)
			{
				double d3 = this.thirdPersonDistancePrev + (this.thirdPersonDistance - this.thirdPersonDistancePrev) * partialTicks;

				if (this.mc.gameSettings.debugCamEnable)
				{
					GlStateManager.translate(0.0F, 0.0F, (float) (-d3));
				}
				else
				{
					float f1 = entity.rotationYaw;
					float f2 = entity.rotationPitch;

					if (this.mc.gameSettings.thirdPersonView == 2)
						f2 += 180.0F;

					if (this.mc.gameSettings.thirdPersonView == 2)
						GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);

					GlStateManager.rotate(entity.rotationPitch - f2, 1.0F, 0.0F, 0.0F);
					GlStateManager.rotate(entity.rotationYaw - f1, 0.0F, 1.0F, 0.0F);
					GlStateManager.translate(0.0F, 0.0F, (float) (-d3));
					GlStateManager.rotate(f1 - entity.rotationYaw, 0.0F, 1.0F, 0.0F);
					GlStateManager.rotate(f2 - entity.rotationPitch, 1.0F, 0.0F, 0.0F);
				}
			}
			else
				GlStateManager.translate(0.0F, 0.0F, -0.1F);

			if (!this.mc.gameSettings.debugCamEnable)
			{
				float yaw = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks + 180.0F;
				float pitch = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;
				float roll = 0.0F;
				if (entity instanceof EntityAnimal)
				{
					EntityAnimal entityanimal = (EntityAnimal) entity;
					yaw = entityanimal.prevRotationYawHead + (entityanimal.rotationYawHead - entityanimal.prevRotationYawHead) * partialTicks + 180.0F;
				}

				IBlockState block = ActiveRenderInfo.getBlockStateAtEntityViewpoint(this.mc.world, entity, partialTicks);
				net.minecraftforge.client.event.EntityViewRenderEvent.CameraSetup event = new net.minecraftforge.client.event.EntityViewRenderEvent.CameraSetup((EntityRenderer) (Object) this, entity, block, partialTicks, yaw, pitch, roll);
				net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(event);
				GlStateManager.rotate(event.getRoll(), 0.0F, 0.0F, 1.0F);
				GlStateManager.rotate(event.getPitch(), 1.0F, 0.0F, 0.0F);
				GlStateManager.rotate(event.getYaw(), 0.0F, 1.0F, 0.0F);
			}

			GlStateManager.translate(0.0F, -f, 0.0F);
			double d0 = entity.prevPosX + (entity.posX - entity.prevPosX) * (double) partialTicks;
			double d1 = entity.prevPosY + (entity.posY - entity.prevPosY) * (double) partialTicks + (double) f;
			double d2 = entity.prevPosZ + (entity.posZ - entity.prevPosZ) * (double) partialTicks;
			this.cloudFog = this.mc.renderGlobal.hasCloudFog(d0, d1, d2, partialTicks);
		}
	}

	@Inject(method = "setupCameraTransform", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/EntityRenderer;applyBobbing(F)V", shift = At.Shift.BEFORE))
	private void setupCameraViewBobbingBefore(final CallbackInfo callbackInfo)
	{
		if (LiquidBounce.moduleManager.getModule(Tracers.class).getState())
			GL11.glPushMatrix();
	}

	@Inject(method = "setupCameraTransform", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/EntityRenderer;applyBobbing(F)V", shift = At.Shift.AFTER))
	private void setupCameraViewBobbingAfter(final CallbackInfo callbackInfo)
	{
		if (LiquidBounce.moduleManager.getModule(Tracers.class).getState())
			GL11.glPopMatrix();
	}

	/**
	 * @author
	 */
	@Overwrite
	public void getMouseOver(float partialTicks)
	{
		Entity entity = this.mc.getRenderViewEntity();

		if (entity != null)
		{
			if (this.mc.world != null)
			{
				this.mc.mcProfiler.startSection("pick");
				this.mc.pointedEntity = null;

				final Reach reach = (Reach) LiquidBounce.moduleManager.getModule(Reach.class);

				double d0 = reach.getState() ? reach.getMaxRange() : (double) this.mc.playerController.getBlockReachDistance();
				this.mc.objectMouseOver = entity.rayTrace(reach.getState() ? reach.getBuildReachValue().get() : d0, partialTicks);

				Vec3d vec3d = entity.getPositionEyes(partialTicks);
				boolean flag = false;
				int i = 3;
				double d1 = d0;

				if (this.mc.playerController.extendedReach())
				{
					d1 = 6.0D;
					d0 = d1;
				}
				else
				{
					if (d0 > 3.0D)
					{
						flag = true;
					}
				}

				if (this.mc.objectMouseOver != null)
				{
					d1 = this.mc.objectMouseOver.hitVec.distanceTo(vec3d);
				}

				if (reach.getState())
				{
					d1 = reach.getCombatReachValue().get();

					final RayTraceResult movingObjectPosition = entity.rayTrace(d1, partialTicks);

					if (movingObjectPosition != null)
						d1 = movingObjectPosition.hitVec.distanceTo(vec3d);
				}

				Vec3d vec3d1 = entity.getLook(1.0F);
				Vec3d vec3d2 = vec3d.addVector(vec3d1.x * d0, vec3d1.y * d0, vec3d1.z * d0);
				this.pointedEntity = null;
				Vec3d vec3d3 = null;
				float f = 1.0F;
				List<Entity> list = this.mc.world.getEntitiesInAABBexcluding(entity, entity.getEntityBoundingBox().expand(vec3d1.x * d0, vec3d1.y * d0, vec3d1.z * d0).grow(1.0D, 1.0D, 1.0D), Predicates.and(EntitySelectors.NOT_SPECTATING, p_apply_1_ -> p_apply_1_ != null && p_apply_1_.canBeCollidedWith()));
				double d2 = d1;

				for (Entity entity1 : list)
				{
					AxisAlignedBB axisalignedbb = entity1.getEntityBoundingBox().grow((double) entity1.getCollisionBorderSize());
					RayTraceResult raytraceresult = axisalignedbb.calculateIntercept(vec3d, vec3d2);

					if (axisalignedbb.contains(vec3d))
					{
						if (d2 >= 0.0D)
						{
							this.pointedEntity = entity1;
							vec3d3 = raytraceresult == null ? vec3d : raytraceresult.hitVec;
							d2 = 0.0D;
						}
					}
					else if (raytraceresult != null)
					{
						double d3 = vec3d.distanceTo(raytraceresult.hitVec);

						if (d3 < d2 || d2 == 0.0D)
						{
							if (entity1.getLowestRidingEntity() == entity.getLowestRidingEntity() && !entity1.canRiderInteract())
							{
								if (d2 == 0.0D)
								{
									this.pointedEntity = entity1;
									vec3d3 = raytraceresult.hitVec;
								}
							}
							else
							{
								this.pointedEntity = entity1;
								vec3d3 = raytraceresult.hitVec;
								d2 = d3;
							}
						}
					}
				}

				if (this.pointedEntity != null && flag && vec3d.distanceTo(vec3d3) > (reach.getState() ? reach.getCombatReachValue().get() : 3.0D))
				{
					this.pointedEntity = null;
					this.mc.objectMouseOver = new RayTraceResult(RayTraceResult.Type.MISS, vec3d3, null, new BlockPos(vec3d3));
				}

				if (this.pointedEntity != null && (d2 < d1 || this.mc.objectMouseOver == null))
				{
					this.mc.objectMouseOver = new RayTraceResult(this.pointedEntity, vec3d3);

					if (this.pointedEntity instanceof EntityLivingBase || this.pointedEntity instanceof EntityItemFrame)
					{
						this.mc.pointedEntity = this.pointedEntity;
					}
				}

				this.mc.mcProfiler.endSection();
			}
		}
	}
}
