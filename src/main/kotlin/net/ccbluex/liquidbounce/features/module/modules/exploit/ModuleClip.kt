/*
 * This file is part of LiquidBounce (https://github.com/CCBlueX/LiquidBounce)
 *
 * Copyright (c) 2015 - 2024 CCBlueX
 *
 * LiquidBounce is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LiquidBounce is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LiquidBounce. If not, see <https://www.gnu.org/licenses/>.
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.config.Choice
import net.ccbluex.liquidbounce.config.ChoiceConfigurable
import net.ccbluex.liquidbounce.event.events.NotificationEvent
import net.ccbluex.liquidbounce.event.events.OverlayRenderEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.event.repeatable
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.modules.movement.fly.ModuleFly
import net.ccbluex.liquidbounce.render.engine.Color4b
import net.ccbluex.liquidbounce.render.renderEnvironmentForGUI
import net.ccbluex.liquidbounce.utils.block.canStandOn
import net.ccbluex.liquidbounce.utils.block.getState
import net.ccbluex.liquidbounce.utils.client.notification
import net.ccbluex.liquidbounce.utils.client.scaledDimension
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Direction
import kotlin.math.cos
import kotlin.math.sin

/**
 * Clip module
 *
 * Allows you to clip through blocks by jumping or snekaing.
 */
object ModuleClip : Module("Clip", Category.MOVEMENT) {

    val modes = choices<Choice>("Choice", { Fancy }) {
        arrayOf(Fancy, Old)
    }

    object Old : Choice("Old") {

        override val parent: ChoiceConfigurable<Choice>
            get() = modes

        private val horizontal by float("Horizontal", 0f, -10f..10f)
        private val vertical by float("Vertical", 5f, -10f..10f)
        private val resetVelocity by boolean("ResetVelocity", true)

        override fun enable() {
            val yaw = Math.toRadians(player.yaw.toDouble())
            val x = -sin(yaw) * horizontal
            val z = cos(yaw) * horizontal

            player.updatePosition(player.x + x, player.y + vertical, player.z + z)
            if (resetVelocity) {
                player.setVelocity(0.0, 0.0, 0.0)
            }
            enabled = false
        }
    }

    object Fancy : Choice("Fancy") {

        override val parent: ChoiceConfigurable<Choice>
            get() = modes


        private val horizontal by int("Horizontal", 0, 0..6)
        private val vertical by int("Vertical", 5, 0..6)

        private val requiresStandOn by boolean("RequiresStandOn", true)

        private val possibleClipDirections = mutableListOf<Direction>()

        val repeatable = repeatable {
            synchronized(possibleClipDirections) {
                possibleClipDirections.clear()

                if (ModuleFly.enabled) {
                    return@repeatable
                }

                arrayOf(Direction.UP, Direction.DOWN).forEach { direction ->
                    tryClip(direction, vertical) {
                        possibleClipDirections.add(direction)
                    }
                }
            }

            val movementDirection = when {
                player.horizontalCollision -> player.horizontalFacing // todo: fix not based on keyboard
                mc.options.sneakKey.isPressed -> Direction.DOWN
                mc.options.jumpKey.isPressed -> Direction.UP
                else -> return@repeatable
            }

            val clipLength = when (movementDirection) {
                Direction.DOWN, Direction.UP -> vertical
                else -> horizontal
            }

            tryClip(movementDirection, clipLength) { blockPos ->
                val centerPosition = blockPos.toCenterPos()

                // Set the new position
                player.updatePosition(centerPosition.x, centerPosition.y - 0.5, centerPosition.z)

                notification("Clip", message("whoosh"), NotificationEvent.Severity.SUCCESS)
            }
            waitTicks(5)
        }

        @Suppress("unused")
        val overlayRenderHandler = handler<OverlayRenderEvent> { event ->
            val context = event.context

            val directionString = synchronized(possibleClipDirections) {
                if (possibleClipDirections.isEmpty()) {
                    return@handler
                }

                val arrowUp = if (possibleClipDirections.contains(Direction.UP)) "▲" else ""
                val arrowDown = if (possibleClipDirections.contains(Direction.DOWN)) "▼" else ""
                "[ $arrowUp$arrowDown ]"
            }

            renderEnvironmentForGUI {
                // Draw it to the right of the crosshair
                val (width, height) = mc.window.scaledDimension

                // Since we cannot use the LiquidBounce FontRenderer for characters like ▲ and ▼
                // we have to use the Minecraft FontRenderer.
                // Another option would be to pass the text to the JCEF HUD and render it there.
                // But that would be a lot of work for a simple arrow.
                // todo: maybe add a font renderer that supports unicode characters?
                //   or a way to pass text to the JCEF HUD
                context.drawTextWithShadow(
                    mc.textRenderer,
                    directionString,
                    width / 2 + 10,
                    height / 2 - mc.textRenderer.fontHeight / 2 + 1,
                    Color4b.WHITE.toRGBA()
                )
            }
        }

        private fun tryClip(movementDirection: Direction, length: Int, clip: (BlockPos) -> Unit) {
            val blockPos = player.blockPos

            var wallBetween = false

            // Calculate the new position
            // Find the closest free block to clip into
            for (i in 1..length) {
                val x = blockPos.x + movementDirection.offsetX * i
                val y = blockPos.y + movementDirection.offsetY * i
                val z = blockPos.z + movementDirection.offsetZ * i
                val position = BlockPos(x, y, z)

                if (isPossibleLocation(position, requiresStandOn = requiresStandOn &&
                        movementDirection != Direction.UP)) {
                    // We do not want to clip if there is no wall between us
                    if (wallBetween) {
                        clip(position)
                        break
                    }
                } else {
                    wallBetween = true
                }
            }
        }

        private fun isPossibleLocation(blockPos: BlockPos, requiresStandOn: Boolean = true): Boolean {
            val floorBlockPos = blockPos.down()
            val upperBlockPos = blockPos.up()

            if (requiresStandOn && !floorBlockPos.canStandOn()) {
                return false
            }

            return blockPos.getState()?.isAir == true && upperBlockPos.getState()?.isAir == true
        }
    }

}
