/*
 * This file is part of LiquidBounce (https://github.com/CCBlueX/LiquidBounce)
 *
 * Copyright (c) 2024 CCBlueX
 *
 * LiquidBounce is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LiquidBounce is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LiquidBounce. If not, see <https://www.gnu.org/licenses/>.
 *
 *
 */

package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.Sequence
import net.ccbluex.liquidbounce.event.events.BlockShapeEvent
import net.ccbluex.liquidbounce.event.events.MovementInputEvent
import net.ccbluex.liquidbounce.event.events.NotificationEvent
import net.ccbluex.liquidbounce.event.events.WorldRenderEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.event.repeatable
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.render.drawSolidBox
import net.ccbluex.liquidbounce.render.engine.Color4b
import net.ccbluex.liquidbounce.render.renderEnvironmentForWorld
import net.ccbluex.liquidbounce.render.withColor
import net.ccbluex.liquidbounce.render.withPosition
import net.ccbluex.liquidbounce.render.withPositionRelativeToCamera
import net.ccbluex.liquidbounce.utils.aiming.raycast
import net.ccbluex.liquidbounce.utils.block.canStandOn
import net.ccbluex.liquidbounce.utils.block.getState
import net.ccbluex.liquidbounce.utils.client.chat
import net.ccbluex.liquidbounce.utils.client.notification
import net.ccbluex.liquidbounce.utils.entity.rotation
import net.ccbluex.liquidbounce.utils.math.toVec3
import net.ccbluex.liquidbounce.utils.math.toVec3d
import net.ccbluex.liquidbounce.utils.movement.DirectionalInput
import net.minecraft.block.FluidBlock
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Box
import net.minecraft.util.math.Vec3d
import net.minecraft.util.shape.VoxelShapes

/**
 * ClickTP
 *
 * Only works for Vulcan AntiCheat
 */
object ModuleClickTp : Module("ClickTp", Category.EXPLOIT) {

    private val range by float("Range", 60f, 10f..500f)
    private val cooldown by int("Cooldown", 20, 0..120)
    private val lagAfter by int("LagAfter", 40, 0..120)
    private val jumps by int("Jumps", 3, 1..10)

    private val startDelay by int("StartDelay", 5, 0..20)

    var requiresLag = false
    private var requiresCollision = false
    private var requiresMovement = false

    private var highlightBlock: BlockPos? = null
    private val fullBox = Box(0.0, 0.0, 0.0, 1.0, 1.0, 1.0)

    val repeatable = repeatable {
        val raycast = raycast(range.toDouble(), player.rotation, false)
        val blockPos = raycast?.blockPos.apply {
            highlightBlock = this
        }

        if (!mc.options.pickItemKey.isPressed) {
            return@repeatable
        }

        if (blockPos == null || !isSuitable(blockPos)) {
            chat("No suitable target!")
            return@repeatable
        }

        val pos = blockPos.up().toCenterPos()

        notification("ClickTp", message("start", blockPos.x, blockPos.y, blockPos.z),
            NotificationEvent.Severity.SUCCESS)

        teleportVulcan286(pos)

        waitTicks(5)
        if (player.pos.distanceTo(blockPos.toVec3d()) < 5) {
            notification("ClickTp", message("success", blockPos.x, blockPos.y, blockPos.z),
                NotificationEvent.Severity.SUCCESS)
        } else {
            notification("ClickTp", message("failed", blockPos.x, blockPos.y, blockPos.z),
                NotificationEvent.Severity.ERROR)
        }

        waitTicks(cooldown)
    }

    /**
     * Teleport to a position by abusing Vulcan.
     *
     * TODO: Not very good method. Needs too much time and is not reliable. But it works...
     */
    private suspend fun Sequence<*>.teleportVulcan286(pos: Vec3d) {
        requiresLag = true

        // Set position and send packet
        player.setPosition(pos)
        waitTicks(startDelay)

        repeat(jumps) {
            requiresCollision = true
            player.jump()

            waitTicks(1)
            waitUntil { player.isOnGround }
            requiresCollision = false
        }

        requiresMovement = true
        waitTicks(lagAfter)
        requiresMovement = false

        requiresLag = false
    }

    val renderHandler = handler<WorldRenderEvent> { event ->
        val matrixStack = event.matrixStack
        val pos = highlightBlock ?: return@handler

        renderEnvironmentForWorld(matrixStack) {
            val blockState = pos.getState() ?: return@renderEnvironmentForWorld
            if (blockState.isAir) {
                return@renderEnvironmentForWorld
            }

            val outlineShape = blockState.getOutlineShape(world, pos)
            val boundingBox = if (outlineShape.isEmpty) {
                fullBox
            } else {
                outlineShape.boundingBox
            }

            withPositionRelativeToCamera(pos.toVec3d()) {
                // Show green color when block is suitable for standing
                val color = if (isSuitable(pos)) Color4b.GREEN.alpha(100) else Color4b.RED.alpha(100)

                withColor(color) {
                    drawSolidBox(boundingBox)
                }
            }
        }
    }

    val shapeHandler = handler<BlockShapeEvent> { event ->
        if (requiresCollision && event.state.block !is FluidBlock && event.pos.y < player.y) {
            event.shape = VoxelShapes.fullCube()
        }
    }

    private var swap = false

    val handleMovement = handler<MovementInputEvent> {
        if (requiresMovement) {
            it.directionalInput = if (swap) DirectionalInput.LEFT else DirectionalInput.RIGHT
            swap = !swap
        }
    }

    private fun isSuitable(blockPos: BlockPos?): Boolean {
        if (blockPos == null || !blockPos.canStandOn()) {
            return false
        }

        val blockPosUp = blockPos.up()
        val BlockPosUp2 = blockPosUp.up()

        return !blockPosUp.canStandOn() && !BlockPosUp2.canStandOn()
    }

    override fun disable() {
        requiresLag = false
        requiresCollision = false
        requiresMovement = false
        highlightBlock = null
        super.disable()
    }

}
