package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.repeatable
import net.minecraft.network.Packet
import net.minecraft.network.packet.c2s.play.ClientStatusC2SPacket
import net.minecraft.network.packet.c2s.play.ConfirmScreenActionC2SPacket
import net.minecraft.network.packet.c2s.play.KeepAliveC2SPacket

object ModulePingSpoof : Module("PingSpoof", Category.EXPLOIT) {
    private val delay by int("Delay", 500, 0..5000)

    private val packetQueue = hashMapOf<Packet<*>, Long>()

    override fun disable() {
        packetQueue.clear()
    }

    val packetHandler = handler<PacketEvent> { event ->
        val packet = event.packet

        if ((packet is KeepAliveC2SPacket || packet is ClientStatusC2SPacket || packet is ConfirmScreenActionC2SPacket)
            && !(player.isDead || player.health <= 0) && !packetQueue.containsKey(packet)
        ) {
            event.cancelEvent()

            synchronized(packetQueue) {
                packetQueue[packet] = System.currentTimeMillis() + delay
            }
        }
    }

    val repeatable = repeatable {
        synchronized(packetQueue) {
            packetQueue.filter {
                it.value >= System.currentTimeMillis()
            }.forEach { (packet, time) ->
                network.sendPacket(packet)
                packetQueue.remove(packet, time)
            }
        }
    }
}