/*
 * This file is part of LiquidBounce (https://github.com/CCBlueX/LiquidBounce)
 *
 * Copyright (c) 2015 - 2024 CCBlueX
 *
 * LiquidBounce is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LiquidBounce is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LiquidBounce. If not, see <https://www.gnu.org/licenses/>.
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import kotlinx.coroutines.*
import net.ccbluex.liquidbounce.event.events.GameTickEvent
import net.ccbluex.liquidbounce.event.events.PacketEvent
import net.ccbluex.liquidbounce.event.events.WorldChangeEvent
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.client.chat
import net.ccbluex.liquidbounce.utils.client.markAsError
import net.ccbluex.liquidbounce.utils.client.sendPacketSilently
import net.ccbluex.liquidbounce.utils.entity.ping
import net.minecraft.network.packet.Packet
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket
import net.minecraft.network.packet.c2s.common.KeepAliveC2SPacket
import java.util.concurrent.ConcurrentLinkedQueue

/**
 * PingSpoof module
 *
 * Spoofs your ping to a specified value.
 */
object ModulePingSpoof : Module("PingSpoof", Category.EXPLOIT) {

    private val delay by int("Delay", 500, 0..25000, "ms")
    private val dynamic by boolean("Dynamic", false)
    private val pauseDeath by boolean("PauseWhileBeingDead", true)

    // stores all packets that have to be sent
    val queue = ConcurrentLinkedQueue<Packet<*>>()

    // handles each packet and its delay
    var scope: CoroutineScope? = null

    var starting = true

    override fun enable() {
        scope = CoroutineScope(Dispatchers.Default + SupervisorJob())
        starting = true
    }

    override fun disable() {
        cancel()
        while (queue.isNotEmpty()) {
            sendPacketSilently(queue.poll())
        }
    }

    // the packet handler should have a really low priority,
    // so from other modules canceled events won't be sent
    val packetHandler = handler<PacketEvent>(priority = -1000) { event ->
        val packet = event.packet

        val pause = player.isDead && pauseDeath
        if (pause || event.isCancelled) {
            return@handler
        }

        if (packet is KeepAliveC2SPacket || packet is CommonPongC2SPacket) {
            event.cancelEvent()
            queue.add(packet)
            schedulePacketSending(packet)
        }
    }

    @Suppress("SpellCheckingInspection")
    val tickHandler = handler<GameTickEvent> {
        if (mc.isIntegratedServerRunning) {
            chat(markAsError(message("cantEnableInSingleplayer")))
            enabled = false
        }
    }

    @Suppress("unused")
    val worldChangeHandler = handler<WorldChangeEvent>(ignoreCondition = true) {
        cancel()
        queue.clear()
        scope = CoroutineScope(Dispatchers.Default + SupervisorJob())
        starting = true
    }

    private fun schedulePacketSending(packet: Packet<*>) {
        scope!!.launch {
            val subtrahend = if (dynamic) {
                var ping = player.ping

                if (starting && ping > delay) {
                    starting = false
                }

                // If the ping wasn't spoofed before, there is no need to correct it.
                // (Actually, it needs some seconds before reaching the level,
                // so the spoofed milliseconds will be wrong when joining a server
                // or enabling this module for some seconds).
                if (!starting) {
                    // the player.ping variable is spoofed, so it needs to be corrected
                    ping -= delay
                } else {
                    ping = 0
                }

                // The ping might vary,
                // so it should rather keep it above the set ping
                // over 10 ms variation is probably not really to expect.
                roundDownToIncrement(ping, 10).coerceAtLeast(0)
            } else {
                0
            }

            delay(delay.toLong() - subtrahend)

            // Removes the packet from the queue,
            // but only execute if the queue contained the packet.
            if (queue.remove(packet)) {
                sendPacketSilently(packet)
            }
        }
    }

    private fun cancel() {
        try {
            scope!!.cancel()
        } catch (_: Exception) {
            /* ignored */
        }
    }

    /**
     * Rounds the [number] down to the nearest multiple of the given [increment].
     */
    @Suppress("SameParameterValue")
    private fun roundDownToIncrement(number: Int, increment: Int): Int {
        return (number / increment) * increment
    }

}
