/*
 * This file is part of LiquidBounce (https://github.com/CCBlueX/LiquidBounce)
 *
 * Copyright (c) 2015 - 2024 CCBlueX
 *
 * LiquidBounce is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LiquidBounce is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LiquidBounce. If not, see <https://www.gnu.org/licenses/>.
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.config.Choice
import net.ccbluex.liquidbounce.config.ChoiceConfigurable
import net.ccbluex.liquidbounce.event.events.PacketEvent
import net.ccbluex.liquidbounce.event.events.TransferOrigin
import net.ccbluex.liquidbounce.event.handler
import net.ccbluex.liquidbounce.event.repeatable
import net.ccbluex.liquidbounce.features.fakelag.DelayData
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.client.*
import net.ccbluex.liquidbounce.utils.item.getEnchantment
import net.minecraft.enchantment.Enchantments
import net.minecraft.item.Items
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerInputC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.network.packet.s2c.common.CommonPingS2CPacket
import net.minecraft.network.packet.s2c.play.PlayerPositionLookS2CPacket
import net.minecraft.util.Hand
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Direction
import kotlin.math.roundToInt

/**
 * A disabler module
 *
 * Disables either a specific anti-cheat or server.
 */
object ModuleDisabler : Module("Disabler", Category.EXPLOIT) {

    private val modes = choices(
        "Mode", LiveOverflow, arrayOf(
            LiveOverflow,
            AdvancedAntiCheat1910,
            VulcanRiptide,
            GrimSpectate
        )
    )

    override fun enable() {
        chat(regular(message("info")))
        super.enable()
    }

    /* Really old disabler method... but still works
       On Grim you need a lot of extra logic for it to works.
       I will try my best to explain everything.
    */
    private object GrimSpectate : Choice("GrimSpectate") {

        override val parent: ChoiceConfigurable
            get() = modes

        private val packetQueue = LinkedHashSet<DelayData>()
        private var delay = false

        override fun disable() {
            if (inGame) {
                packetQueue.forEach { handlePacket(it.packet) }
            }

            packetQueue.clear()
            delay = false
        }

        /**
         * This is simple... most AntiCheat use transaction to check if the packet it sent u have arrived. So we are
         * going to delay the transaction when we got fly abilities from dead spectator or etc... to make the server
         * think we haven't received the set your fly status to false (after you respawn and not spectating anymore).
         * So we can disable the AntiCheat, since this could happen to some extreme laggy player,
         * it not really much proper, way to patch without affect the legits... That what we're going to abuse.
         * You get it, the idea is really stupid but works on old Intave and Grim
         * On Old Intave, player will not show up... on grim, it will flag reach which is make sense.
         * Grim think that you haven't received the player move packet so you for grim all player on our client-sided
         * it not moving and ofc that mean we are reaching or not even looking at the target.
         *
         * https://github.com/GrimAnticheat/Grim/blob/2.0/src/main/java/ac/grim/grimac/events/packets/PacketPlayerAbilities.java
         */
        val packetHandler = handler<PacketEvent> { event ->
            val packet = event.packet

            if (player.age < 20) {
                packetQueue.clear()
                return@handler
            }

            if (event.origin != TransferOrigin.RECEIVE) {
                return@handler
            }

            /**
             * THIS IS FOR GRIM....
             * Here come a bit tricky, after you not in spectator anymore, you got teleport back.
             * (I hate BadPacketsN). BadPacketsN check teleport queues every PlayerMoveC2SPacket.Full.
             *
             * When you release your transaction packets you delay
             * your lastTransaction data on Grim (or any) will go to the latest transaction.
             * But BadPacketsN check if the transaction use
             * for teleport is > your latest send transaction. Since u sent it like all in one,
             * it will not have time to check and wait for next tick that is C06
             * to check for BacPacketsN. But since your transaction is latest and your teleport
             * transaction is behind then it will flag
             *
             * Bypass BadPacketsN is not hard but... either way even if we bypass it, it will still set us back...
             * TODO: FIND A WAY AROUND THIS (works on all sv)
             *
             * ---------------------------------------------
             * Ok on some server we get teleport Packet before Abilities packet when we out of spectator,
             * how about we just delay right after teleport?
             * (please don't turn this on before you in spectator)
             * I'm not good at explaining stuff...
             * https://github.com/GrimAnticheat/Grim/blob/2.0/src/main/java/ac/grim/grimac/manager/SetbackTeleportUtil.java
            */
            if (packet is PlayerPositionLookS2CPacket) {
                // Should we start delaying?
                if (player.abilities.flying && !delay) {
                    delay = true
                } else if (delay) {
                    /**
                     * We flagged, info the player and add to packet queue to
                     * bypass BadPacketsN.
                     *
                     * This should not autotoggle, since everything that has been used
                     * with disabler would still be enabled.
                     */
                    packetQueue.add(DelayData(packet, System.currentTimeMillis()))
                    chat(markAsError(message("grimSpectateMessage")))
                }
            }

            if (delay) {
                //it not really good idea to delay our packets for way too long, let's just release it after a while
                // idk this is fine for minemalia ig.
//                if (timer.hasElapsed(seconds.toLong() * 1000L)) {
//                    packetQueue.forEach() { handlePacket(it.packet) }
//                    packetQueue.clear()
//
//                    delay = false
//                    timer.reset()
//                }

                // delay transaction of course so the server will think we still have the flying ablities.
                if (packet is CommonPingS2CPacket) {
                    packetQueue.add(DelayData(packet, System.currentTimeMillis()))
                    event.cancelEvent()

                    // Prevent you from getting timed out, it will not work if your version is below 1.17
                    network.sendPacket(CommonPongC2SPacket(0))
                }
            }
        }
    }

    /**
     * Exploits the Riptide except of Vulcan in order to disable any movement checks
     *
     * This seems to be patched in newer versions of Vulcan
     * This disabler was added in 02/07/23, which indicates it was probably made for Vulcan 2.7.5
     */
    private object VulcanRiptide : Choice("VulcanRiptide") {

        override val parent: ChoiceConfigurable
            get() = modes

        override fun enable() {
            if (!checkItem()) {
                chat(markAsError(message("vulcanRiptideMessage")))
                enabled = false
            }
        }

        val repeatable = repeatable {
            if (checkItem()) {
                waitTicks(20)
                interaction.sendSequencedPacket(world) { sequence ->
                    PlayerInteractItemC2SPacket(Hand.OFF_HAND, sequence)
                }
                network.sendPacket(
                    PlayerActionC2SPacket(
                        PlayerActionC2SPacket.Action.RELEASE_USE_ITEM, BlockPos(0, 0, 0), Direction.DOWN
                    )
                )
            }
            return@repeatable
        }

        fun checkItem(): Boolean {
            val offhand = player.inventory.offHand[0]
            return (offhand.item == Items.TRIDENT && offhand.hasEnchantments()
                && offhand.getEnchantment(Enchantments.RIPTIDE) != 0)
        }
    }

    /**
     * AAC 1.9.10 disabler
     */
    private object AdvancedAntiCheat1910 : Choice("AAC1.9.10") {

        override val parent: ChoiceConfigurable
            get() = modes

        val packetHandler = handler<PacketEvent> { event ->
            if (event.packet is PlayerMoveC2SPacket) {
                network.sendPacket(
                    PlayerInputC2SPacket(
                        player.sidewaysSpeed, player.forwardSpeed, true, player.input.sneaking
                    )
                )
                event.packet.y += 7.0E-9
            }
        }
    }

    /**
     * LiveOverflow disabler
     *
     * This disabler is made for LiveOverflow's server
     */
    private object LiveOverflow : Choice("LiveOverflow") {

        override val parent: ChoiceConfigurable
            get() = modes

        val packetHandler = handler<PacketEvent> { event ->
            when (val packet = event.packet) {
                is PlayerMoveC2SPacket -> {
                    packet.x = (packet.x * 100).roundToInt() / 100.0
                    packet.z = (packet.z * 100).roundToInt() / 100.0
                }
            }
        }
    }
}
