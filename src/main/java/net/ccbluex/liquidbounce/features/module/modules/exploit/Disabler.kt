/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.grim.GrimPlace
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.startsprint.StartSprint
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.verus.VerusCombat
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.verus.VerusFly
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablermodes.vulcan.VulcanScaffold
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.MultiListValue

object Disabler : Module("Disabler", Category.EXPLOIT, hideModule = false) {

    private val disablerModes = arrayOf(
        // Start Sprint
        StartSprint,

        // Grim
        GrimPlace,

        // Vulcan
        VulcanScaffold,

        // Verus
        VerusFly,
        VerusCombat
    )

    private val modes = disablerModes.map { it.modeName }.toTypedArray()

    val mode by object : MultiListValue("Mode", modes, listOf("StartSprint")) {
        override fun onChange(oldValue: List<String>, newValue: List<String>): List<String> {
            if (state)
                onDisable()

            return super.onChange(oldValue, newValue)
        }

        override fun onChanged(oldValue: List<String>, newValue: List<String>) {
            if (state)
                onEnable()
        }
    }

    val grimDebug by BoolValue("GrimDebug", false) { mode.contains("GrimPlace") }

    val onlyCombat by BoolValue("OnlyCombat", true) { mode.contains("VerusCombat") }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        modeModules.forEach { it.onPacket(event) }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        modeModules.forEach { it.onUpdate() }
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        modeModules.forEach { it.onMotion() }
    }

    @EventTarget
    fun onTick(event: GameTickEvent) {
        modeModules.forEach { it.onTick() }
    }

    @EventTarget
    fun onStrafe(event: StrafeEvent) {
        modeModules.forEach { it.onStrafe() }
    }

    @EventTarget
    fun onAttack(event: AttackEvent) {
        modeModules.forEach { it.onAttack() }
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        modeModules.forEach { it.onWorld() }
    }

    override fun onEnable() {
        modeModules.forEach { it.onEnable() }
    }

    override fun onDisable() {
        modeModules.forEach { it.onDisable() }
    }

    private val modeModules
        get() = disablerModes.filter { mode.contains(it.modeName) }

    override val tag
        get() = mode.joinToString(" | ")

    override fun handleEvents() = super.handleEvents() && mc.thePlayer != null && mc.theWorld != null
}