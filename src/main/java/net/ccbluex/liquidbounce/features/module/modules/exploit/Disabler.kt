/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.AttackEvent
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacket
import net.minecraft.item.Items
import net.minecraft.item.ItemStack
import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerInteractBlockC2SPacket
import net.minecraft.network.packet.c2s.play.ConfirmGuiActionC2SPacket
import net.minecraft.network.packet.s2c.play.ConfirmGuiActionS2CPacket

object Disabler : Module("Disabler", Category.EXPLOIT, hideModule = false) {
    val startSprint by BoolValue("StartSprint", true)

    private val grimPlace by BoolValue("GrimPlace", false)
    private val grimDebug by BoolValue("GrimDebug", false) { grimPlace }

    private val vulcanScaffold by BoolValue("VulcanScaffold", false)
    private val vulcanPacketTick by IntegerValue("VulcanScaffoldPacketTick", 15, 1..20) { vulcanScaffold }

    val verusFly by BoolValue("VerusFly", false)

    private val verusCombat by BoolValue("VerusCombat", false)
    private val onlyCombat by BoolValue("OnlyCombat", true) { verusCombat }

    private var transaction = false
    var isOnCombat = false

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val player = mc.player ?: return
        val packet = event.packet

        if (grimPlace) {
            if (packet is PlayerInteractBlockC2SPacket && packet.placedBlockDirection in 0..5) {
                event.cancelEvent()
                sendPacket(
                    PlayerInteractBlockC2SPacket(
                        packet.position,
                        6 + packet.placedBlockDirection * 7,
                        packet.stack,
                        packet.placedBlockOffsetX,
                        packet.placedBlockOffsetY,
                        packet.placedBlockOffsetZ
                    )
                )

                if (grimDebug) {
                    displayChatMessage("§cModify §aPlace §cPacket§7.")
                }
            }
        }

        if (verusCombat) {
            if (player.ticksAlive <= 20) {
                isOnCombat = false
                return
            }

            if (onlyCombat && !isOnCombat) {
                return
            }

            /**
             * Works by just simply ignore transaction and not accepting them and send invalid one
             * to bypass Verus cancel transaction "patch" (not sending transaction for too long)
             * This could work on other anti-cheat that don't have a proper transaction handling system
             * But this will mostly be used on Verus, disabled any combat check related to transaction.
             *
             * Credit: @ghost / LB Nextgen
             */
            if (packet is ConfirmGuiActionS2CPacket) {
                event.cancelEvent()
                sendPacket(ConfirmGuiActionC2SPacket(if (transaction) 1 else -1, if (transaction) -1 else 1, transaction), triggerEvent = false)
                transaction = !transaction
            }
        }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val player = mc.player ?: return

        if (verusFly) {
            if (!isOnCombat && !player.isDead) {
                val pos = player.pos.add(0, if(player.y > 0) -100 else 100 , 0) ?: return

                sendPacket(
                    PlayerInteractBlockC2SPacket(
                        pos,
                        1,
                        ItemStack(Items.WATER_BUCKET),
                        0F,
                        0.5F + Math.random().toFloat() * 0.44F,
                        0F
                    )
                )
            } else {
                isOnCombat = true
            }
        }

        if (vulcanScaffold) {
            if (!(player.isTouchingWater || player.isTouchingLava || player.isDead || player.isClimbing)) {
                if (player.ticksAlive % vulcanPacketTick == 0) {
                    sendPacket(ClientCommandC2SPacket(player, ClientCommandC2SPacket.Action.START_SNEAKING))
                    sendPacket(ClientCommandC2SPacket(player, ClientCommandC2SPacket.Action.STOP_SNEAKING))
                }
            }
        }
    }

    @EventTarget
    fun onAttack(event: AttackEvent) {
        isOnCombat = true
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        isOnCombat = false
    }
}
