/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.MoveEvent
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.Render3DEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.MovementUtils.forward
import net.ccbluex.liquidbounce.utils.MovementUtils.strafe
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPackets
import net.ccbluex.liquidbounce.utils.PathUtils.findBlinkPath
import net.ccbluex.liquidbounce.utils.extensions.getBlock
import net.ccbluex.liquidbounce.utils.extensions.plus
import net.ccbluex.liquidbounce.utils.render.RenderUtils.drawFilledBox
import net.ccbluex.liquidbounce.utils.render.RenderUtils.glColor
import net.ccbluex.liquidbounce.utils.render.RenderUtils.renderNameTag
import net.ccbluex.liquidbounce.utils.timing.TickTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.AirBlock
import net.minecraft.block.BlockAir
import net.minecraft.block.BlockFence
import net.minecraft.block.BlockSnow
import net.minecraft.block.Blocks
import net.minecraft.block.material.Material.air
import net.minecraft.client.render.GlStateManager
import net.minecraft.network.Packet
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.PositionOnly
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.Both
import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket
import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket.Action.START_SNEAKING
import net.minecraft.network.packet.c2s.play.ClientCommandC2SPacket.Action.STOP_SNEAKING
import net.minecraft.util.Box
import net.minecraft.util.math.BlockPos
import net.minecraft.util.MovingObjectPosition
import net.minecraft.util.Vec3d
import net.minecraft.util.math.Vec3d
import org.lwjgl.input.Mouse.isButtonDown
import org.lwjgl.opengl.GL11.*
import java.awt.Color
import java.lang.Math.round
import javax.vecmath.Vector3d

object Teleport : Module("Teleport", Category.EXPLOIT) {
    private val ignoreNoCollision by BoolValue("IgnoreNoCollision", true)
    private val mode by ListValue("Mode", arrayOf("Tp", "Blink", "Flag", "Rewinside", "OldRewinside", "Spoof", "Minesucht", "AAC3.5.0", "BWRel", "Karhu"), "Tp")
    private val button by ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")
    private val needSneak by BoolValue("NeedSneak", true) { mode !in noSneakModes }

    private val noSneakModes = setOf("Rewinside", "OldRewinside", "AAC3.5.0", "Spoof")

    private val flyTimer = TickTimer()
    private var hadGround = false
    private var fixedY = 0.0
    private val packets = mutableListOf<Packet<*>>()
    private var disableLogger = false
    private var zitter = false
    private var doTeleport = false
    private var freeze = false
    private val freezeTimer = TickTimer()

    private var delay = 0
    private var endPos: BlockPos? = null
    private var objectPosition: MovingObjectPosition? = null

    private var endX = 0.0
    private var endY = 0.0
    private var endZ = 0.0

    override fun onEnable() {
        if (mode == "AAC3.5.0") {
            displayChatMessage("§c>>> §a§lTeleport §fAAC 3.5.0 §c<<<")
            displayChatMessage("§cHow to teleport: §aPress $button mouse button.")
            displayChatMessage("§cHow to cancel teleport: §aDisable teleport module.")
        }
    }

    override fun onDisable() {
        fixedY = 0.0
        delay = 0
        mc.ticker.timerSpeed = 1f
        endPos = null
        hadGround = false
        freeze = false
        disableLogger = false
        flyTimer.reset()
        packets.clear()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val buttonIndex = listOf("Left", "Right", "Middle").indexOf(button)

        if (mode == "AAC3.5.0") {
            freezeTimer.update()

            if (freeze && freezeTimer.hasTimePassed(40)) {
                freezeTimer.reset()
                freeze = false
                state = false
            }

            if (!flyTimer.hasTimePassed(60)) {
                flyTimer.update()

                if (mc.player.onGround)
                    mc.player.jump()
                else {
                    forward(if (zitter) -0.21 else 0.21)
                    zitter = !zitter
                }

                hadGround = false
                return
            }

            if (mc.player.onGround)
                hadGround = true

            if (!hadGround)
                return

            if (mc.player.onGround)
                mc.player.setPositionAndUpdate(mc.player.x, mc.player.y + 0.2, mc.player.z)

            mc.player.abilities.isFlying = false

            if (mc.options.jumpKey.isPressed) mc.player.velocityY = 2.0
            else if (mc.options.sneakKey.isPressed) mc.player.velocityY = -2.0
            else mc.player.velocityY = 0.0

            strafe(2f, true)

            if (isButtonDown(buttonIndex) && !doTeleport) {
                mc.player.setPositionAndUpdate(mc.player.x, mc.player.y - 11, mc.player.z)

                disableLogger = true
                sendPackets(*packets.toTypedArray())

                freezeTimer.reset()
                freeze = true
            }

            doTeleport = isButtonDown(buttonIndex)
            return
        }

        if (mc.currentScreen == null && isButtonDown(buttonIndex) && delay <= 0) {
            val objectPosition = objectPosition!!
            val block = objectPosition.blockPos.getBlock()!!
            endPos = objectPosition.blockPos

            if (endPos!!.getBlock()!!.material === Blocks.AIR) {
                endPos = null
                return
            }

            val collisionBoundingBox = block.getCollisionBoundingBox(mc.world, objectPosition.blockPos, block.defaultState)
            val y = (collisionBoundingBox?.maxY ?: (endPos!!.y + endPos!!.getBlock()!!.blockBoundsMaxY)) + fixedY
            displayChatMessage("§7[§8§lTeleport§7] §3Position was set to §8${endPos!!.x}§3, §8$y§3, §8${endPos!!.z}")

            delay = 6
            endX = endPos!!.x + 0.5
            endY = endPos!!.y + 1.0
            endZ = endPos!!.z + 0.5
        }

        if (delay > 0) --delay

        if (endPos != null && (mc.player.isSneaking || !needSneak || mode in noSneakModes))
            when (mode) {
                "Blink" -> {
                    // Sneak
                    sendPacket(ClientCommandC2SPacket(mc.player, STOP_SNEAKING))

                    // Teleport
                    findBlinkPath(endX, endY, endZ).forEach { vector3d: Vector3d ->
                        sendPacket(PositionOnly(vector3d.x, vector3d.y, vector3d.z, true))
                        mc.player.setPosition(endX, endY, endZ)
                    }

                    // Sneak
                    sendPacket(ClientCommandC2SPacket(mc.player, START_SNEAKING))

                    // Notify
                    displayChatMessage("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "Flag" -> {
                    sendPackets( // Sneak
                        ClientCommandC2SPacket(mc.player, STOP_SNEAKING),  // Teleport

                        PositionOnly(mc.player.x, mc.player.y, mc.player.z, true),
                        PositionOnly(endX, endY, endZ, true),
                        PositionOnly(mc.player.x, mc.player.y, mc.player.z, true),
                        PositionOnly(mc.player.x, mc.player.y + 5, mc.player.z, true),
                        PositionOnly(endX, endY, endZ, true),
                        PositionOnly(mc.player.x + 0.5, mc.player.y, mc.player.z + 0.5, true),  // Sneak

                        ClientCommandC2SPacket(mc.player, START_SNEAKING)
                    )

                    forward(0.04)

                    // Notify
                    displayChatMessage("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "BWRel" -> {
                    mc.player.setPosition(mc.player.x, mc.player.y + 9.2507838107252498276, mc.player.z)
                    mc.player.velocityY = 1.042026214225532854
                    sendPacket(PositionOnly(endX, endY, endZ, true))
                }

                "Rewinside" -> {
                    mc.player.velocityY = 0.1
                    sendPackets(
                        PositionOnly(endX, endY, endZ, true),
                        PositionOnly(mc.player.x, mc.player.y + 0.6, mc.player.z, true)
                    )

                    if (mc.player.x.toInt().toDouble() == endX && mc.player.y.toInt()
                            .toDouble() == endY && mc.player.z.toInt()
                            .toDouble() == endZ
                    ) {
                        displayChatMessage("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                        endPos = null
                    } else displayChatMessage("§7[§8§lTeleport§7] §3Teleport try...")
                }

                "OldRewinside" -> {
                    mc.player.velocityY = 0.1

                    sendPackets(
                        PositionOnly(mc.player.x, mc.player.y, mc.player.z, true),
                        PositionOnly(endX, endY, endZ, true),
                        PositionOnly(mc.player.x, mc.player.y, mc.player.z, true),
                        PositionOnly(mc.player.x, mc.player.y, mc.player.z, true),
                        PositionOnly(endX, endY, endZ, true),
                        PositionOnly(mc.player.x, mc.player.y, mc.player.z, true)
                    )

                    if (mc.player.x.toInt().toDouble() == endX && mc.player.y.toInt()
                            .toDouble() == endY && mc.player.z.toInt()
                            .toDouble() == endZ
                    ) {
                        displayChatMessage("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                        endPos = null
                    } else displayChatMessage("§7[§8§lTeleport§7] §3Teleport try...")

                    forward(0.04)
                }

                "Minesucht" -> {
                    sendPacket(PositionOnly(endX, endY, endZ, true))
                    displayChatMessage("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "Tp" -> {
                    sendPacket(PositionOnly(endX, endY, endZ, true))
                    mc.player.setPosition(endX, endY, endZ)
                    displayChatMessage("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }

                "Karhu" -> {
                    repeat(5) {
                        sendPackets(
                            PositionOnly(endX, endY, endZ, false),
                            PositionOnly(mc.player.x, mc.player.y, mc.player.z, false)
                        )
                    }

                    mc.player.setPosition(endX, endY, endZ)

                    displayChatMessage("§7[§8§lTeleport§7] §3You were teleported to §8$endX§3, §8$endY§3, §8$endZ")
                    endPos = null
                }
            }
    }

    @EventTarget
    fun onRender3D(event: Render3DEvent?) {
        if (mode == "AAC3.5.0")
            return

        val lookVec = Vec3d(mc.player.lookVec.xCoord * 300, mc.player.lookVec.yCoord * 300, mc.player.lookVec.zCoord * 300)
        val posVec = Vec3d(mc.player.x, mc.player.y + 1.62, mc.player.z)

        objectPosition = mc.player.world.rayTrace(posVec, posVec + lookVec, false, ignoreNoCollision, false) ?: return
        val blockPos = objectPosition!!.blockPos ?: return
        val block = blockPos.getBlock()

        val belowBlockPos = BlockPos(blockPos.x, blockPos.y - 1, blockPos.z)

        fixedY = if (block is BlockFence) (if (mc.world.getCollidingBoundingBoxes(
                    mc.player,
                    mc.player.entityBoundingBox.offset(
                        blockPos.x + 0.5 - mc.player.x,
                        blockPos.y + 1.5 - mc.player.y,
                        blockPos.z + 0.5 - mc.player.z
                    )
                ).isEmpty()
            ) 0.5 else 0.0) else if (belowBlockPos.getBlock() is BlockFence) (if (mc.world.getCollidingBoundingBoxes(
                    mc.player,
                    mc.player.entityBoundingBox.offset(
                        blockPos.x + 0.5 - mc.player.x,
                        blockPos.y + 0.5 - mc.player.y,
                        blockPos.z + 0.5 - mc.player.z
                    )
                ).isNotEmpty() || block!!
                .getCollisionBoundingBox(mc.world, blockPos, block.defaultState) == null
            ) 0.0 else 0.5 - block.blockBoundsMaxY) else if (block is BlockSnow) block.blockBoundsMaxY - 0.125 else 0.0

        val x = blockPos.x
        val y =
            (if (block!!.getCollisionBoundingBox(mc.world, blockPos, block.defaultState) == null
            ) blockPos.y + block.blockBoundsMaxY else block
                .getCollisionBoundingBox(mc.world, blockPos, block.defaultState).maxY) - 1 + fixedY
        val z = blockPos.z

        if (block !is AirBlock) {
            val renderManager = mc.renderManager

            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            glEnable(GL_BLEND)
            glLineWidth(2f)
            glDisable(GL_TEXTURE_2D)
            glDisable(GL_DEPTH_TEST)
            glDepthMask(false)
            glColor(
                if (mode == "Minesucht" && mc.player.pos.y.toDouble() != y + 1) Color(255, 0, 0, 90) else if (mc.world.getCollidingBoundingBoxes(
                        mc.player,
                        mc.player.boundingBox.offset(
                            x + 0.5 - mc.player.x,
                            y + 1.0 - mc.player.y,
                            z + 0.5 - mc.player.z
                        )
                    ).isNotEmpty()
                ) Color(255, 0, 0, 90) else Color(0, 255, 0, 90)
            )
            drawFilledBox(
                Box(
                    x - renderManager.renderPosX,
                    (y + 1) - renderManager.renderPosY, z - renderManager.renderPosZ, x - renderManager.renderPosX + 1, y + 1.2 - renderManager.renderPosY, z - renderManager.renderPosZ + 1
                )
            )
            glEnable(GL_TEXTURE_2D)
            glEnable(GL_DEPTH_TEST)
            glDepthMask(true)
            glDisable(GL_BLEND)

            renderNameTag(round(mc.player.getDistance(x + 0.5, y + 1, z + 0.5)).toString() + "m", x + 0.5, y + 1.7, z + 0.5)
            GlStateManager.resetColor()
        }
    }

    @EventTarget
    fun onMove(event: MoveEvent) {
        if (mode == "AAC3.5.0" && freeze) {
            event.zeroXZ()
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (disableLogger)
            return

        if (packet is PlayerMoveC2SPacket) {
            when (mode) {
                "Spoof" -> if (endPos != null) {
                    val endPos = endPos!!
                    packet.x = endPos.x + 0.5
                    packet.y = endPos.y + 1.0
                    packet.z = endPos.z + 0.5
                    mc.player.setPosition(endPos.x + 0.5, endPos.y + 1.0, endPos.z + 0.5)
                }

                "AAC3.5.0" -> {
                    if (!flyTimer.hasTimePassed(60)) return

                    event.cancelEvent()

                    if (packet !is PositionOnly && packet !is Both) return

                    packets.add(packet)
                }
            }
        }
    }

    override val tag
        get() = mode
}
