/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.movement.Fly
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.PathUtils.findBlinkPath
import net.ccbluex.liquidbounce.utils.extensions.*
import net.ccbluex.liquidbounce.utils.render.ColorUtils
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.block.BlockAir
import net.minecraft.block.BlockFence
import net.minecraft.block.BlockSnow
import net.minecraft.block.material.Material
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import net.minecraft.util.MovingObjectPosition
import net.minecraft.util.Vec3
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11.*
import java.awt.Color
import java.util.*
import javax.vecmath.Vector3d
import kotlin.collections.ArrayList
import kotlin.math.roundToInt

// TODO: Maximum packets per ticks limit
@ModuleInfo(name = "Teleport", description = "Allows you to teleport around.", category = ModuleCategory.EXPLOIT)
class Teleport : Module()
{
    /**
     * Options
     */
    private val modeValue = ListValue("Mode", arrayOf("Blink", "AAC1.9.10", "Rewinside", "OldRewinside", "Spoof", "Minesucht", "AAC3.5.0"), "Blink")

    private val ignoreNoCollision = BoolValue("IgnoreNoCollision", true)

    private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")

    private val blinkGroup = object : ValueGroup("Blink")
    {
        override fun showCondition() = modeValue.get().equals("Blink", ignoreCase = true)
    }
    private val blinkOffsetValue = FloatValue("Offset", 0.2f, 0.1f, 10.0f, "Blink-Offset")
    private val blinkYOffsetValue = FloatValue("YOffset", 0.25f, 0.1f, 10.0f, "Blink-YOffset")

    private val autoDisableValue = BoolValue("AutoDisable", true)

    private val pathEspGroup = ValueGroup("PathESP")
    private val pathEspEnabledValue = BoolValue("Enabled", true, "PathESP")
    private val pathEspTimeValue = IntegerValue("KeepLength", 1000, 100, 3000, "PathESPTime")
    private val pathEspColorValue = RGBAColorValue("Color", 255, 179, 72, 255, listOf("PathESP-Red", "PathESP-Green", "PathESP-Blue", "PathESP-Alpha"))

    private val pathEspColorRainbowGroup = ValueGroup("Rainbow")
    private val pathEspColorRainbowEnabledValue = BoolValue("Enabled", false, "PathESP-Rainbow")
    private val pathEspColorRainbowSpeedValue = IntegerValue("Speed", 10, 1, 10, "PathESP-RainbowSpeed")
    private val pathEspColorRainbowSaturationValue = FloatValue("Saturation", 1.0f, 0.0f, 1.0f, "PathESP-RainbowHSB-Saturation")
    private val pathEspColorRainbowBrightnessValue = FloatValue("Brightness", 1.0f, 0.0f, 1.0f, "PathESP-RainbowHSB-Brightness")

    /**
     * Variables
     */
    private val flyTimer = TickTimer()
    private val pathESPTimer = MSTimer()
    private var path = mutableListOf<Vec3>()

    /**
     * Variables for AAC3.5.0 Teleport
     */
    private var hadGround = false
    private var fixedY = 0.0
    private val packets: MutableCollection<C03PacketPlayer> = ArrayList()
    private var zitter = false
    private var doTeleport = false
    private var aac3_5_0_freeze = false
    private val freezeTimer = TickTimer()

    /**
     * Teleport Position Set Delay
     */
    private var delay = 0

    /**
     * Target Position
     */
    private var endPos: BlockPos? = null
    private var objectPosition: MovingObjectPosition? = null

    init
    {
        blinkGroup.addAll(blinkOffsetValue, blinkYOffsetValue)
        pathEspColorRainbowGroup.addAll(pathEspColorRainbowEnabledValue, pathEspColorRainbowSpeedValue, pathEspColorRainbowSaturationValue, pathEspColorRainbowBrightnessValue)
        pathEspGroup.addAll(pathEspEnabledValue, pathEspTimeValue, pathEspColorValue, pathEspColorRainbowGroup)
    }

    override fun onEnable()
    {
        if (modeValue.get().equals("AAC3.5.0", ignoreCase = true))
        {
            val thePlayer = mc.thePlayer

            displayChatMessage(thePlayer, "\u00A7c>>> \u00A7a\u00A7lTeleport \u00A7fAAC 3.5.0 \u00A7c<<<")
            displayChatMessage(thePlayer, "\u00A7cHow to teleport: \u00A7aPress " + buttonValue.get() + " mouse button.")
            displayChatMessage(thePlayer, "\u00A7cHow to cancel teleport: \u00A7aDisable teleport module.")
        }

        path.clear()
    }

    override fun onDisable()
    {
        fixedY = 0.0
        delay = 0
        mc.timer.timerSpeed = 1.0f
        endPos = null
        hadGround = false
        aac3_5_0_freeze = false
        flyTimer.reset()
        packets.clear()
        path.clear()
    }

    @EventTarget
    fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
    {
        val buttonIndex = arrayOf(*buttonValue.values).indexOf(buttonValue.get())

        val theWorld = mc.theWorld ?: return
        val thePlayer = mc.thePlayer ?: return
        val gameSettings = mc.gameSettings
        val netHandler = mc.netHandler

        val autoDisable = autoDisableValue.get()

        // AAC 3.5.0 Teleport
        if (modeValue.get().equals("AAC3.5.0", ignoreCase = true))
        {
            freezeTimer.update()

            if (aac3_5_0_freeze && freezeTimer.hasTimePassed(40))
            {
                freezeTimer.reset()
                aac3_5_0_freeze = false
                state = false
            }

            if (!flyTimer.hasTimePassed(60))
            {
                flyTimer.update()
                if (thePlayer.onGround) thePlayer.jump()
                else
                {
                    // Trigger AAC flag for strafe (change direction in mid-air)
                    thePlayer.forward(if (zitter) -0.21 else 0.21)
                    zitter = !zitter
                }
                hadGround = false
                return
            }

            if (thePlayer.onGround) hadGround = true

            if (!hadGround) return

            if (thePlayer.onGround) thePlayer.setPositionAndUpdate(thePlayer.posX, thePlayer.posY + 0.2, thePlayer.posZ)

            thePlayer.capabilities.isFlying = false
            thePlayer.zeroXYZ()

            val fly = LiquidBounce.moduleManager[Fly::class.java] as Fly
            val vanillaSpeed = fly.baseSpeedValue.get()

            if (gameSettings.keyBindJump.isKeyDown) thePlayer.motionY = thePlayer.motionY + vanillaSpeed
            if (gameSettings.keyBindSneak.isKeyDown) thePlayer.motionY = thePlayer.motionY - vanillaSpeed

            thePlayer.strafe(vanillaSpeed)

            if (Mouse.isButtonDown(buttonIndex) && !doTeleport)
            {
                val pathEsp = pathEspEnabledValue.get()

                thePlayer.setPositionAndUpdate(thePlayer.posX, thePlayer.posY - 11, thePlayer.posZ)

                if (pathEsp)
                {
                    path.clear()
                    path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                    path.add(Vec3(thePlayer.posX, thePlayer.posY - 11, thePlayer.posZ))
                }

                packets.forEach {
                    netHandler.networkManager.sendPacketWithoutEvent(it)

                    if (pathEsp) path.add(Vec3(it.x, it.y, it.z))
                }

                freezeTimer.reset()
                pathESPTimer.reset()

                aac3_5_0_freeze = true
            }

            doTeleport = Mouse.isButtonDown(buttonIndex)

            return
        }

        val hitPos = objectPosition?.blockPos ?: return
        val hitBlock = theWorld.getBlock(hitPos)
        val hitBlockBB = hitBlock.getCollisionBoundingBox(theWorld, hitPos, hitBlock.defaultState ?: return)

        // Teleport Position Set
        if (mc.currentScreen == null && Mouse.isButtonDown(buttonIndex) && delay <= 0)
        {
            endPos = hitPos

            val state = theWorld.getBlockState(hitPos)

            if (state.block.material == Material.air)
            {
                endPos = null
                displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Position was reset")
                return
            }

            displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Position was set to \u00A78${hitPos.x}\u00A73, \u00A78${(hitBlockBB?.maxY ?: (hitPos.y + 1.0)) + fixedY}\u00A73, \u00A78${hitPos.z}")
            delay = 6
        }

        if (delay > 0) --delay

        if (endPos != null)
        {
            val endPos = endPos ?: return

            val endX = endPos.x + 0.5
            val endY: Double = (hitBlockBB?.maxY ?: (endPos.y + 1.0)) + fixedY
            val endZ = endPos.z + 0.5

            val pathEsp = pathEspEnabledValue.get()

            val mode = modeValue.get()

            if (pathEsp) path.clear()

            when (mode.lowercase(Locale.getDefault()))
            {
                "blink" ->
                {
                    if (!thePlayer.isSneaking) return

                    if (pathEsp) path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))

                    // Stop Sneak
                    netHandler.addToSendQueue(C0BPacketEntityAction(thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING))

                    // Teleport
                    findBlinkPath(thePlayer, endX, endY, endZ, blinkOffsetValue.get().toDouble(), blinkYOffsetValue.get().toDouble()).forEach { vector3d: Vector3d ->
                        netHandler.addToSendQueue(C04PacketPlayerPosition(vector3d.x, vector3d.y, vector3d.z, true))
                        if (pathEsp) path.add(Vec3(vector3d.x, vector3d.y, vector3d.z))
                    }

                    thePlayer.setPosition(endX, endY, endZ)
                    if (pathEsp) path.add(Vec3(endX, endY, endZ))

                    // Re-start Sneak
                    netHandler.addToSendQueue(C0BPacketEntityAction(thePlayer, C0BPacketEntityAction.Action.START_SNEAKING))
                }

                "aac1.9.10" ->
                {
                    if (!thePlayer.isSneaking) return

                    if (pathEsp) path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))

                    // Stop Sneak
                    netHandler.addToSendQueue(C0BPacketEntityAction(thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING))

                    // Teleport
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY + 5.0, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX + 0.5, thePlayer.posY, thePlayer.posZ + 0.5, true))

                    if (pathEsp)
                    {
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(endX, endY, endZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY + 5, thePlayer.posZ))
                        path.add(Vec3(endX, endY, endZ))
                        path.add(Vec3(thePlayer.posX + 0.5, thePlayer.posY, thePlayer.posZ + 0.5))
                    }

                    thePlayer.forward(0.04)

                    // Re-start Sneak
                    netHandler.addToSendQueue(C0BPacketEntityAction(thePlayer, C0BPacketEntityAction.Action.START_SNEAKING))
                }

                "rewinside" ->
                {
                    thePlayer.motionY = 0.1

                    netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY + 0.6, thePlayer.posZ, true))


                    if (pathEsp)
                    {
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(endX, endY, endZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY + 0.6, thePlayer.posZ))
                    }
                }

                "oldrewinside" ->
                {

                    thePlayer.motionY = 0.1

                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))

                    if (pathEsp)
                    {
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(endX, endY, endZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(endX, endY, endZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                    }
                }

                "minesucht" ->
                {
                    if (!thePlayer.isSneaking) return

                    path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))

                    if (pathEsp) netHandler.addToSendQueue(C04PacketPlayerPosition(endX, endY, endZ, true))
                    path.add(Vec3(endX, endY, endZ))
                }
            }

            pathESPTimer.reset()

            // Check Teleported and Notify
            if (thePlayer.posX.toInt() == endX.toInt() && thePlayer.posY.toInt() == endY.toInt() && thePlayer.posZ.toInt() == endZ.toInt())
            {
                displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73You were teleported to \u00A78$endX\u00A73, \u00A78$endY\u00A73, \u00A78$endZ")
                this.endPos = null
                if (autoDisable) state = false
            }
            else displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lTeleport\u00A77] \u00A73Teleport try...")
            if (mode.equals("OldRewinside", ignoreCase = true)) thePlayer.forward(0.04)
        }
    }

    @EventTarget
    fun onRender3D(@Suppress("UNUSED_PARAMETER") event: Render3DEvent)
    {
        if (modeValue.get().equals("AAC3.5.0", ignoreCase = true)) return

        val theWorld = mc.theWorld ?: return
        val thePlayer = mc.thePlayer ?: return

        val renderManager = mc.renderManager
        val viewerPosX = renderManager.viewerPosX
        val viewerPosY = renderManager.viewerPosY
        val viewerPosZ = renderManager.viewerPosZ

        val renderPosX = renderManager.renderPosX
        val renderPosY = renderManager.renderPosY
        val renderPosZ = renderManager.renderPosZ

        // Draw Path ESP
        if (pathEspEnabledValue.get() && path.isNotEmpty() && !pathESPTimer.hasTimePassed(pathEspTimeValue.get().toLong()))
        {
            val customColor = pathEspColorValue.get()
            val color = if (pathEspColorRainbowEnabledValue.get()) ColorUtils.rainbowRGB(pathEspColorValue.getAlpha(), speed = pathEspColorRainbowSpeedValue.get(), saturation = pathEspColorRainbowSaturationValue.get(), brightness = pathEspColorRainbowBrightnessValue.get()) else customColor

            glPushMatrix()
            glDisable(GL_TEXTURE_2D)
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            glEnable(GL_LINE_SMOOTH)
            glEnable(GL_BLEND)
            glDisable(GL_DEPTH_TEST)
            mc.entityRenderer.disableLightmap()

            glBegin(GL_LINE_STRIP)
            RenderUtils.glColor(color)

            for (path in path) glVertex3d(path.xCoord - viewerPosX, path.yCoord - viewerPosY, path.zCoord - viewerPosZ)

            RenderUtils.resetColor()
            glEnd()

            glEnable(GL_DEPTH_TEST)
            glDisable(GL_LINE_SMOOTH)
            glDisable(GL_BLEND)
            glEnable(GL_TEXTURE_2D)
            glPopMatrix()
        }

        val entityLookVec = thePlayer.lookVec ?: return

        val lookVec = Vec3(entityLookVec.xCoord * 300, entityLookVec.yCoord * 300, entityLookVec.zCoord * 300)
        val posVec = Vec3(thePlayer.posX, thePlayer.posY + 1.62, thePlayer.posZ)
        val pos = theWorld.rayTraceBlocks(posVec, posVec + lookVec, false, ignoreNoCollision.get(), false)

        val hitPos = pos?.blockPos ?: return
        val hitBlock = theWorld.getBlock(hitPos)
        val hitBlockBB = hitBlock.getCollisionBoundingBox(theWorld, hitPos, hitBlock.defaultState ?: return)

        objectPosition = pos

        val beloBlockPos = BlockPos(hitPos.x, hitPos.y - 1, hitPos.z)

        // TODO: Handle BlockFenceGate
        fixedY = if (theWorld.getBlock(hitPos) is BlockFence) if (theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(hitPos.x + 0.5 - thePlayer.posX, hitPos.y + 1.5 - thePlayer.posY, hitPos.z + 0.5 - thePlayer.posZ)).isEmpty()) 0.5 else 0.0 else if (theWorld.getBlock(beloBlockPos) is BlockFence) if (!theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(hitPos.x + 0.5 - thePlayer.posX, hitPos.y + 0.5 - thePlayer.posY, hitPos.z + 0.5 - thePlayer.posZ)).isEmpty() || hitBlockBB == null) 0.0 else 0.5 - 1 else if (theWorld.getBlock(hitPos) is BlockSnow) 1 - 0.125 else 0.0

        val x = hitPos.x
        val y: Double = (hitBlockBB?.maxY ?: (hitPos.y + 1.0)) - 1.0 + fixedY
        val z = hitPos.z

        if (theWorld.getBlock(hitPos) !is BlockAir)
        {
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            glEnable(GL_BLEND)
            glLineWidth(2.0f)
            glDisable(GL_TEXTURE_2D)
            glDisable(GL_DEPTH_TEST)
            glDepthMask(false)

            RenderUtils.glColor(if (modeValue.get().equals("Minesucht", ignoreCase = true) && thePlayer.position.y.toDouble() != y + 1) Color(255, 0, 0, 90) else if (theWorld.getCollidingBoundingBoxes(thePlayer, thePlayer.entityBoundingBox.offset(x + 0.5 - thePlayer.posX, y + 1.0 - thePlayer.posY, z + 0.5 - thePlayer.posZ)).isEmpty()) Color(0, 255, 0, 90) else Color(255, 0, 0, 90))
            RenderUtils.drawFilledBox(AxisAlignedBB(x - renderPosX, y + 1 - renderPosY, z - renderPosZ, x - renderPosX + 1.0, y + 1.2 - renderPosY, z - renderPosZ + 1.0))

            glEnable(GL_TEXTURE_2D)
            glEnable(GL_DEPTH_TEST)
            glDepthMask(true)
            glDisable(GL_BLEND)

            RenderUtils.renderNameTag("${thePlayer.getDistance(x + 0.5, y + 1.0, z + 0.5).roundToInt()}m", x + 0.5, y + 1.7, z + 0.5)

            RenderUtils.resetColor()
        }
    }

    @EventTarget
    fun onMove(event: MoveEvent)
    {
        if (modeValue.get().equals("AAC3.5.0", ignoreCase = true) && aac3_5_0_freeze) event.zeroXZ()
    }

    @EventTarget
    fun onPacket(event: PacketEvent)
    {
        val packet = event.packet
        val thePlayer = mc.thePlayer ?: return

        if (packet is C03PacketPlayer)
        {
            when (modeValue.get().lowercase(Locale.getDefault()))
            {
                "spoof" ->
                {
                    val pos = endPos ?: return
                    packet.x = pos.x + 0.5
                    packet.y = (pos.y + 1).toDouble()
                    packet.z = pos.z + 0.5

                    thePlayer.setPosition(pos.x + 0.5, (pos.y + 1).toDouble(), pos.z + 0.5)
                }

                "aac3.5.0" ->
                {
                    if (!flyTimer.hasTimePassed(60)) return

                    event.cancelEvent()

                    if (packet !is C04PacketPlayerPosition && packet !is C06PacketPlayerPosLook) return

                    packets.add(packet)
                }
            }
        }
    }

    override val tag: String
        get() = modeValue.get()
}
