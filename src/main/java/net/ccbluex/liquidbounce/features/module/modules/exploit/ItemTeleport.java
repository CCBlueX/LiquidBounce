/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit;

import net.ccbluex.liquidbounce.api.enums.MaterialType;
import net.ccbluex.liquidbounce.api.minecraft.block.state.IIBlockState;
import net.ccbluex.liquidbounce.api.minecraft.client.entity.IEntityPlayerSP;
import net.ccbluex.liquidbounce.api.minecraft.renderer.entity.IRenderManager;
import net.ccbluex.liquidbounce.api.minecraft.util.IMovingObjectPosition;
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos;
import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.Render3DEvent;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.ClientUtils;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.ccbluex.liquidbounce.utils.render.RenderUtils;
import net.ccbluex.liquidbounce.value.BoolValue;
import net.ccbluex.liquidbounce.value.ListValue;
import org.lwjgl.input.Mouse;

import javax.vecmath.Vector3f;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.lwjgl.opengl.GL11.*;

@ModuleInfo(name = "ItemTeleport", description = "Allows you to pick up items far away.", category = ModuleCategory.EXPLOIT)
public class ItemTeleport extends Module {

    private final ListValue modeValue = new ListValue("Mode", new String[]{"New", "Old"}, "New");
    private final BoolValue resetAfterTp = new BoolValue("ResetAfterTP", true);
    private final ListValue buttonValue = new ListValue("Button", new String[]{"Left", "Right", "Middle"}, "Middle");

    private int delay;
    private WBlockPos endPos;
    private IMovingObjectPosition objectPosition;

    @Override
    public void onDisable() {
        delay = 0;
        endPos = null;
        super.onDisable();
    }

    @EventTarget
    public void onUpdate(final UpdateEvent event) {
        if (mc.getCurrentScreen() == null && Mouse.isButtonDown(Arrays.asList(buttonValue.getValues()).indexOf(buttonValue.get())) && delay <= 0) {
            endPos = objectPosition.getBlockPos();

            IIBlockState state = BlockUtils.getState(endPos);

            if (state.getBlock().getMaterial(state) == classProvider.getMaterialEnum(MaterialType.AIR)) {
                endPos = null;
                return;
            }

            ClientUtils.displayChatMessage("§7[§8§lItemTeleport§7] §3Position was set to §8" + endPos.getX() + "§3, §8" + endPos.getY() + "§3, §8" + endPos.getZ());
            delay = 6;
        }

        if (delay > 0)
            --delay;

        IEntityPlayerSP thePlayer = mc.getThePlayer();

        if (thePlayer == null)
            return;

        if (endPos != null && thePlayer.isSneaking()) {
            if (!thePlayer.getOnGround()) {
                final double endX = (double) endPos.getX() + 0.5D;
                final double endY = (double) endPos.getY() + 1D;
                final double endZ = (double) endPos.getZ() + 0.5D;

                switch (modeValue.get().toLowerCase()) {
                    case "old":
                        for (final Vector3f vector3f : vanillaTeleportPositions(endX, endY, endZ, 4D))
                            mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.getX(), vector3f.getY(), vector3f.getZ(), false));
                        break;
                    case "new":
                        for (final Vector3f vector3f : vanillaTeleportPositions(endX, endY, endZ, 5D)) {
                            mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.getPosX(), thePlayer.getPosY(), thePlayer.getPosZ(), true));
                            mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true));
                            mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.getPosX(), thePlayer.getPosY(), thePlayer.getPosZ(), true));
                            mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(thePlayer.getPosX(), thePlayer.getPosY() + 4.0, thePlayer.getPosZ(), true));
                            mc.getNetHandler().addToSendQueue(classProvider.createCPacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true));
                            MovementUtils.forward(0.04);
                        }
                        break;
                }

                if (resetAfterTp.get())
                    endPos = null;

                ClientUtils.displayChatMessage("§7[§8§lItemTeleport§7] §3Tried to collect items");
            } else
                thePlayer.jump();
        }
    }

    @EventTarget
    public void onRender3D(final Render3DEvent event) {
        objectPosition = mc.getThePlayer().rayTrace(1000, event.getPartialTicks());

        if (objectPosition.getBlockPos() == null)
            return;

        final int x = objectPosition.getBlockPos().getX();
        final int y = objectPosition.getBlockPos().getY();
        final int z = objectPosition.getBlockPos().getZ();

        IIBlockState state = BlockUtils.getState(objectPosition.getBlockPos());

        if (!state.getBlock().getMaterial(state).equals(classProvider.getMaterialEnum(MaterialType.AIR))) {
            final IRenderManager renderManager = mc.getRenderManager();

            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            glEnable(GL_BLEND);
            glLineWidth(2F);
            glDisable(GL_TEXTURE_2D);
            glDisable(GL_DEPTH_TEST);
            glDepthMask(false);

            IIBlockState state1 = BlockUtils.getState(objectPosition.getBlockPos().up());

            RenderUtils.glColor(!state1.getBlock().getMaterial(state1).equals(classProvider.getMaterialEnum(MaterialType.AIR)) ? new Color(255, 0, 0, 90) : new Color(0, 255, 0, 90));
            RenderUtils.drawFilledBox(classProvider.createAxisAlignedBB(x - renderManager.getRenderPosX(), (y + 1) - renderManager.getRenderPosY(), z - renderManager.getRenderPosZ(), x - renderManager.getRenderPosX() + 1D, y + 1.2D - renderManager.getRenderPosY(), z - renderManager.getRenderPosZ() + 1D));
            glEnable(GL_TEXTURE_2D);
            glEnable(GL_DEPTH_TEST);
            glDepthMask(true);
            glDisable(GL_BLEND);

            RenderUtils.renderNameTag(Math.round(mc.getThePlayer().getDistance(x, y, z)) + "m", x + 0.5, y + 1.7, z + 0.5);
            classProvider.getGlStateManager().resetColor();
        }
    }

    private List<Vector3f> vanillaTeleportPositions(final double tpX, final double tpY, final double tpZ, final double speed) {
        final List<Vector3f> positions = new ArrayList<>();
        double posX = tpX - mc.getThePlayer().getPosX();
        double posZ = tpZ - mc.getThePlayer().getPosZ();
        float yaw = (float) ((Math.atan2(posZ, posX) * 180 / Math.PI) - 90F);
        double tmpX;
        double tmpY = mc.getThePlayer().getPosY();
        double tmpZ;
        double steps = 1;

        for (double d = speed; d < getDistance(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), tpX, tpY, tpZ); d += speed)
            steps++;

        for (double d = speed; d < getDistance(mc.getThePlayer().getPosX(), mc.getThePlayer().getPosY(), mc.getThePlayer().getPosZ(), tpX, tpY, tpZ); d += speed) {
            tmpX = mc.getThePlayer().getPosX() - (Math.sin(Math.toRadians(yaw)) * d);
            tmpZ = mc.getThePlayer().getPosZ() + Math.cos(Math.toRadians(yaw)) * d;
            tmpY -= (mc.getThePlayer().getPosY() - tpY) / steps;
            positions.add(new Vector3f((float) tmpX, (float) tmpY, (float) tmpZ));
        }

        positions.add(new Vector3f((float) tpX, (float) tpY, (float) tpZ));

        return positions;
    }

    private double getDistance(double x1, double y1, double z1, double x2, double y2, double z2) {
        double d0 = x1 - x2;
        double d1 = y1 - y2;
        double d2 = z1 - z2;
        return Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
    }

}
