/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue

// TODO: Maximum packets per ticks limit
@ModuleInfo(name = "Damage", description = "Deals damage to yourself.", category = ModuleCategory.EXPLOIT, canEnable = false)
class Damage : Module()
{
    private val modeValue = ListValue("Mode", arrayOf("NCP", "AAC", "Hypixel"), "NCP")
    private val damageValue = IntegerValue("Damage", 1, 1, 20)
    private val ncpMotionSizeValue = FloatValue("NCP-MotionSize", 0.049F, 0.000001F, 0.5F)

    companion object
    {
        fun ncpDamage(damage: Int = 1, motionSize: Double = 0.049)
        {
            val thePlayer = mc.thePlayer ?: return

            // We need at least 3.0125 blocks of falldistance to take fall damage
            var goalFallDistance = 3.0125 + (damage - 1)
            val x = thePlayer.posX
            val y = thePlayer.posY
            val z = thePlayer.posZ

            val networkManager = mc.netHandler.networkManager

            val provider = classProvider
            while (networkManager.channelOpen && goalFallDistance > 0F)
            {
                networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y + motionSize, z, false))
                networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y, z, false))
                goalFallDistance -= motionSize
            }

            networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y, z, true))
        }

        fun hypixelDamage(damage: Int = 1)
        {
            val thePlayer = mc.thePlayer ?: return

            var goalFallDistance = 3.0125 + (damage - 1) // add 0.0125 to ensure we get the fall dmg

            val motionSize = 0.0624986421
            val motionSize2 = 0.0625
            val motionSize3 = 0.0000013579

            val x = thePlayer.posX
            val y = thePlayer.posY
            val z = thePlayer.posZ

            val networkManager = mc.netHandler.networkManager

            val provider = classProvider

            repeat(10) {
                // Imagine flagging to NCP.
                networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y, z, true))
            }

            while (networkManager.channelOpen && goalFallDistance > 0)
            {
                networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y + motionSize, z, false))
                networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y + motionSize2, z, false))
                networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y + motionSize, z, false))
                networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y + motionSize3, z, false))
                goalFallDistance -= motionSize
            }

            networkManager.sendPacketWithoutEvent(CPacketPlayerPosition(x, y, z, true))
        }
    }

    override fun onEnable()
    {
        val thePlayer = mc.thePlayer ?: return

        val damage = damageValue.get()

        when (modeValue.get().toLowerCase())
        {
            "ncp" -> ncpDamage(damage, motionSize = ncpMotionSizeValue.get().toDouble())
            "aac" -> thePlayer.motionY = 5.0 * damage
            "hypixel" -> hypixelDamage(damage)
        }
    }
}
