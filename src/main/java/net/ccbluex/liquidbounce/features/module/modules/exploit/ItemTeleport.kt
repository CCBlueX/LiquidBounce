/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.Render3DEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils.displayChatMessage
import net.ccbluex.liquidbounce.utils.extensions.*
import net.ccbluex.liquidbounce.utils.render.ColorUtils
import net.ccbluex.liquidbounce.utils.render.RenderUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.block.material.Material
import net.minecraft.client.renderer.GlStateManager
import net.minecraft.entity.Entity
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import net.minecraft.util.MovingObjectPosition
import net.minecraft.util.Vec3
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11.*
import java.awt.Color
import javax.vecmath.Vector3d
import kotlin.math.atan2
import kotlin.math.roundToInt
import kotlin.math.sqrt

@ModuleInfo(name = "ItemTeleport", description = "Allows you to pick up items far away.", category = ModuleCategory.EXPLOIT)
class ItemTeleport : Module()
{
    private val modeValue = ListValue("Mode", arrayOf("AAC3.1.6", "AAC3.3.9"), "AAC3.3.9")
    private val resetAfterTpValue = BoolValue("ResetAfterTP", true)
    private val autoDisableValue = BoolValue("AutoDisable", true)
    private val pathDistanceValue = FloatValue("PathDistance", 5.0f, 0.1f, 10.0f)
    private val buttonValue = ListValue("Button", arrayOf("Left", "Right", "Middle"), "Middle")

    private val pathEspGroup = ValueGroup("PathESP")
    private val pathEspEnabledValue = BoolValue("Enabled", true, "PathESP")
    private val pathEspTimeValue = IntegerValue("KeepLength", 1000, 100, 3000, "PathESPTime")
    private val pathEspColorValue = RGBAColorValue("Color", 255, 179, 72, 255, listOf("PathESP-Red", "PathESP-Green", "PathESP-Blue", "PathESP-Alpha"))

    private val pathEspColorRainbowGroup = ValueGroup("Rainbow")
    private val pathEspColorRainbowEnabledValue = BoolValue("Enabled", false, "PathESP-Rainbow")
    private val pathEspColorRainbowSpeedValue = IntegerValue("Speed", 10, 1, 10, "PathESP-RainbowSpeed")
    private val pathEspColorRainbowSaturationValue = FloatValue("Saturation", 1.0f, 0.0f, 1.0f, "PathESP-RainbowHSB-Saturation")
    private val pathEspColorRainbowBrightnessValue = FloatValue("Brightness", 1.0f, 0.0f, 1.0f, "PathESP-RainbowHSB-Brightness")

    /**
     * Teleport Position Set Delay
     */
    private var delay = 0

    /**
     * Target Position
     */
    private var endPos: BlockPos? = null
    private var objectPosition: MovingObjectPosition? = null

    private val pathESPTimer = MSTimer()
    private var path = mutableListOf<Vec3>()

    init
    {
        pathEspColorRainbowGroup.addAll(pathEspColorRainbowEnabledValue, pathEspColorRainbowSpeedValue, pathEspColorRainbowSaturationValue, pathEspColorRainbowBrightnessValue)
        pathEspGroup.addAll(pathEspEnabledValue, pathEspTimeValue, pathEspColorValue, pathEspColorRainbowGroup)
    }

    override fun onDisable()
    {
        delay = 0
        endPos = null
        path.clear()
    }

    @EventTarget
    fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
    {
        val theWorld = mc.theWorld ?: return
        val thePlayer = mc.thePlayer ?: return

        if (mc.currentScreen == null && Mouse.isButtonDown(arrayOf(*buttonValue.values).indexOf(buttonValue.get())) && delay <= 0)
        {
            val endPos = ((objectPosition ?: return).blockPos ?: return).also { endPos = it }

            val state = theWorld.getBlockState(endPos)

            if (state.block.material == Material.air)
            {
                this.endPos = null
                displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was reset")
                return
            }

            displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was set to \u00A78" + endPos.x + "\u00A73, \u00A78" + endPos.y + "\u00A73, \u00A78" + endPos.z)
            delay = 6
        }

        if (delay > 0) --delay

        val pathDistance = pathDistanceValue.get()

        if (endPos != null && thePlayer.isSneaking) if (!thePlayer.onGround)
        {
            val endPos = endPos ?: return
            val endX = endPos.x + 0.5
            val endY = endPos.y + 1.0
            val endZ = endPos.z + 0.5

            val pathEsp = pathEspEnabledValue.get()

            val netHandler = mc.netHandler

            if (pathEsp)
            {
                path.clear()
                path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
            }

            when (modeValue.get().toLowerCase())
            {
                "aac3.1.6" -> vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble()).forEach { vector3f ->
                    netHandler.addToSendQueue(C04PacketPlayerPosition(vector3f.getX(), vector3f.getY(), vector3f.getZ(), false))
                    if (pathEsp) path.add(Vec3(endX, endY, endZ))
                }

                "aac3.3.9" -> vanillaTeleportPositions(thePlayer, endX, endY, endZ, pathDistance.toDouble()).forEach { vector3f ->
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(thePlayer.posX, thePlayer.posY + 4.0, thePlayer.posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(vector3f.x, vector3f.y, vector3f.z, true))

                    if (pathEsp)
                    {
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(vector3f.x, vector3f.y, vector3f.z))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ))
                        path.add(Vec3(thePlayer.posX, thePlayer.posY + 4, thePlayer.posZ))
                        path.add(Vec3(vector3f.x, vector3f.y, vector3f.z))
                    }

                    thePlayer.forward(0.04)
                }
            }

            pathESPTimer.reset()

            if (resetAfterTpValue.get())
            {
                this.endPos = null
                displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Position was reset")
            }
            else if (autoDisableValue.get() && thePlayer.posX.toInt() == endX.toInt() && thePlayer.posY.toInt() == endY.toInt() && thePlayer.posZ.toInt() == endZ.toInt()) // Check Teleported and Notify
            {
                displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73You were teleported to \u00A78$endX\u00A73, \u00A78$endY\u00A73, \u00A78$endZ")
                this.endPos = null
                state = false
            }
            else displayChatMessage(thePlayer, "\u00A77[\u00A78\u00A7lItemTeleport\u00A77] \u00A73Teleport try...")
        }
        else thePlayer.jump()
    }

    @EventTarget
    fun onRender3D(event: Render3DEvent)
    {
        val theWorld = mc.theWorld ?: return
        val thePlayer = mc.thePlayer ?: return

        val renderManager = mc.renderManager
        val viewerPosX = renderManager.viewerPosX
        val viewerPosY = renderManager.viewerPosY
        val viewerPosZ = renderManager.viewerPosZ

        val renderPosX = renderManager.renderPosX
        val renderPosY = renderManager.renderPosY
        val renderPosZ = renderManager.renderPosZ

        // Draw Path ESP
        if (pathEspEnabledValue.get() && path.isNotEmpty() && !pathESPTimer.hasTimePassed(pathEspTimeValue.get().toLong()))
        {
            val customColor = pathEspColorValue.get()

            val color = if (pathEspColorRainbowEnabledValue.get()) ColorUtils.rainbowRGB(pathEspColorValue.getAlpha(), speed = pathEspColorRainbowSpeedValue.get(), saturation = pathEspColorRainbowSaturationValue.get(), brightness = pathEspColorRainbowBrightnessValue.get()) else customColor

            glPushMatrix()
            glDisable(GL_TEXTURE_2D)
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            glEnable(GL_LINE_SMOOTH)
            glEnable(GL_BLEND)
            glDisable(GL_DEPTH_TEST)
            mc.entityRenderer.disableLightmap()

            glBegin(GL_LINE_STRIP)
            RenderUtils.glColor(color)

            for (path in path) glVertex3d(path.xCoord - viewerPosX, path.yCoord - viewerPosY, path.zCoord - viewerPosZ)

            RenderUtils.resetColor()
            glEnd()

            glEnable(GL_DEPTH_TEST)
            glDisable(GL_LINE_SMOOTH)
            glDisable(GL_BLEND)
            glEnable(GL_TEXTURE_2D)
            glPopMatrix()
        }

        objectPosition = thePlayer.rayTrace(1000.0, event.partialTicks)
        val hitPos = objectPosition?.blockPos ?: return
        val x = hitPos.x
        val y = hitPos.y
        val z = hitPos.z

        val state = theWorld.getBlockState(hitPos)

        if (state.block.material != Material.air)
        {
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
            glEnable(GL_BLEND)
            glLineWidth(2.0f)
            glDisable(GL_TEXTURE_2D)
            glDisable(GL_DEPTH_TEST)
            glDepthMask(false)

            val upState = theWorld.getBlockState(hitPos.up())

            RenderUtils.glColor(if (upState.block.material == Material.air) Color(0, 255, 0, 90) else Color(255, 0, 0, 90))
            RenderUtils.drawFilledBox(AxisAlignedBB(x - renderPosX, y + 1 - renderPosY, z - renderPosZ, x - renderPosX + 1.0, y + 1.2 - renderPosY, z - renderPosZ + 1.0))

            glEnable(GL_TEXTURE_2D)
            glEnable(GL_DEPTH_TEST)
            glDepthMask(true)
            glDisable(GL_BLEND)

            RenderUtils.renderNameTag("${thePlayer.getDistance(x.toDouble(), y.toDouble(), z.toDouble()).roundToInt()}m", x + 0.5, y + 1.7, z + 0.5)

            GlStateManager.resetColor()
        }
    }

    override val tag: String
        get() = modeValue.get()

    companion object
    {
        private fun vanillaTeleportPositions(thePlayer: Entity, tpX: Double, tpY: Double, tpZ: Double, speed: Double): List<Vector3d>
        {
            val posX = tpX - thePlayer.posX
            val posZ = tpZ - thePlayer.posZ

            val yaw = ((atan2(posZ, posX).toFloat()).toDegrees - 90.0f).toRadians
            var tmpY = thePlayer.posY
            var steps = 1.0

            run {
                var d = speed
                val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

                while (d < d2)
                {
                    steps++
                    d += speed
                }
            }

            val positions: MutableList<Vector3d> = ArrayList()
            var d = speed
            val d2 = getDistance(thePlayer.posX, thePlayer.posY, thePlayer.posZ, tpX, tpY, tpZ)

            while (d < d2)
            {
                val tmpX = thePlayer.posX - yaw.sin * d
                val tmpZ = thePlayer.posZ + yaw.cos * d
                tmpY -= (thePlayer.posY - tpY) / steps

                positions.add(Vector3d(tmpX, tmpY, tmpZ))
                d += speed
            }

            positions.add(Vector3d(tpX, tpY, tpZ))

            return positions
        }

        private fun getDistance(x1: Double, y1: Double, z1: Double, x2: Double, y2: Double, z2: Double): Double
        {
            val xDelta = x1 - x2
            val yDelta = y1 - y2
            val zDelta = z1 - z2
            return sqrt(xDelta * xDelta + yDelta * yDelta + zDelta * zDelta)
        }
    }
}
