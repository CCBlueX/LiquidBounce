/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.utils.MovementUtils.direction
import net.ccbluex.liquidbounce.utils.MovementUtils.isMoving
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPackets
import net.ccbluex.liquidbounce.utils.block.BlockUtils.collideBlockIntersects
import net.ccbluex.liquidbounce.utils.extensions.getBlock
import net.ccbluex.liquidbounce.utils.extensions.step
import net.ccbluex.liquidbounce.utils.timing.TickTimer
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.Block
import net.minecraft.init.Blocks.air
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import kotlin.math.cos
import kotlin.math.sin

object Phase : Module("Phase", Category.EXPLOIT) {
    private val mode by ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex", "FullBlock"), "Vanilla")

    private val tickTimer = TickTimer()
    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()
    private var shouldContinue = false
    private var clipState = 0
    private var yaw = 0.0
    private var value = 0.0

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        if (mode == "FullBlock") {
            return
        }

        val isInsideBlock = collideBlockIntersects(player.entityBoundingBox) { block: Block? -> block !== air }

        if (isInsideBlock && mode != "Mineplex") {
            player.noClip = true
            player.motionY = 0.0
            player.onGround = false
        }

        when (mode) {
            "Vanilla" -> { 
                if (player.onGround && tickTimer.hasTimePassed(2) && player.isCollidedHorizontally && (!isInsideBlock || player.isSneaking)) {
                    sendPackets(
                        C04PacketPlayerPosition(player.posX, player.posY, player.posZ, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(player.posX, player.posY, player.posZ, true),
                        C04PacketPlayerPosition(player.posX, player.posY + 0.2, player.posZ, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(player.posX + 0.5, player.posY, player.posZ + 0.5, true)
                    )

                    val yaw = Math.toRadians(player.rotationYaw.toDouble())
                    val x = -sin(yaw) * 0.04
                    val z = cos(yaw) * 0.04

                    player.setPosition(player.posX + x, player.posY, player.posZ + z)
                    tickTimer.reset()
                }
            }
            "Skip" -> {
                if (player.onGround && tickTimer.hasTimePassed(2) && player.isCollidedHorizontally && (!isInsideBlock || player.isSneaking)) {
                    val direction = direction
                    val posX = -sin(direction) * 0.3
                    val posZ = cos(direction) * 0.3

                    for (i in 0..2) {
                        sendPackets(
                            C04PacketPlayerPosition(player.posX, player.posY + 0.06, player.posZ, true),
                            C04PacketPlayerPosition(player.posX + posX * i, player.posY, player.posZ + posZ * i, true)
                        )
                    }

                    player.entityBoundingBox = player.entityBoundingBox.offset(posX, 0.0, posZ)
                    player.setPositionAndUpdate(player.posX + posX, player.posY, player.posZ + posZ)
                    tickTimer.reset()
                }
            }
            "Spartan" -> { 
                if (player.onGround && tickTimer.hasTimePassed(2) && player.isCollidedHorizontally && (!isInsideBlock || player.isSneaking)) {
                    sendPackets(
                        C04PacketPlayerPosition(player.posX, player.posY, player.posZ, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(player.posX, player.posY, player.posZ, true),
                        C04PacketPlayerPosition(player.posX, player.posY - 0.2, player.posZ, true),
                        C04PacketPlayerPosition(0.5, 0.0, 0.5, true),
                        C04PacketPlayerPosition(player.posX + 0.5, player.posY, player.posZ + 0.5, true)
                    )

                    val yaw = Math.toRadians(player.rotationYaw.toDouble())
                    val x = -sin(yaw) * 0.04
                    val z = cos(yaw) * 0.04

                    player.setPosition(player.posX + x, player.posY, player.posZ + z)
                    tickTimer.reset()
                }
            }
            "Clip" -> {
                if (tickTimer.hasTimePassed(2) && player.isCollidedHorizontally && (!isInsideBlock || player.isSneaking)) {
                    val yaw = Math.toRadians(player.rotationYaw.toDouble())
                    val oldX = player.posX
                    val oldZ = player.posZ

                    for (i in 1..10) {
                        val x = -sin(yaw) * i
                        val z = cos(yaw) * i

                        if (BlockPos(oldX + x, player.posY, oldZ + z).getBlock() === air && BlockPos(oldX + x, player.posY + 1, oldZ + z).getBlock() === air) {
                            player.setPosition(oldX + x, player.posY, oldZ + z)
                            break
                        }
                    }
                    tickTimer.reset()
                }
            }
            "AAC3.5.0" -> {
                if (tickTimer.hasTimePassed(2) && player.isCollidedHorizontally && (!isInsideBlock || player.isSneaking)) {
                    val yaw = Math.toRadians(player.rotationYaw.toDouble())
                    val oldX = player.posX
                    val oldZ = player.posZ
                    val x = -sin(yaw)
                    val z = cos(yaw)

                    player.setPosition(oldX + x, player.posY, oldZ + z)
                    tickTimer.reset()
                }
            }
        }
        tickTimer.update()
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent) {
        if (mode == "FullBlock" || mode == "Mineplex") {
            return
        }

        if (player != null && collideBlockIntersects(player.entityBoundingBox) { block: Block? -> block !== air } && event.boundingBox != null && event.boundingBox!!.maxY > player.entityBoundingBox.minY) {
            val axisAlignedBB = event.boundingBox

            event.boundingBox = AxisAlignedBB.fromBounds(axisAlignedBB!!.maxX, player.entityBoundingBox.minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ)
        }
    }

    override fun onEnable() {
        shouldContinue = false
        clipState = 0
        value = 0.0
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (packet is C03PacketPlayer) {
            if (mode == "AAC3.5.0") {
                val yaw = direction.toFloat()

                packet.x -= sin(yaw.toDouble()) * 0.00000001
                packet.z += cos(yaw.toDouble()) * 0.00000001
            }
        }
    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        when (mode) {
            "Mineplex" -> {
                if (player.isCollidedHorizontally)
                    mineplexClip = true

                if (!mineplexClip)
                    return

                mineplexTickTimer.update()

                event.x = 0.0
                event.z = 0.0

                if (mineplexTickTimer.hasTimePassed(3)) {
                    mineplexTickTimer.reset()
                    mineplexClip = false
                } else if (mineplexTickTimer.hasTimePassed(1)) {
                    val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                    val direction = direction

                    player.setPosition(player.posX + (-sin(direction) * offset), player.posY, player.posZ + (cos(direction) * offset))
                }
            }
            "FullBlock" -> {
                if (player.isCollidedHorizontally)
                    clipState++

                when (clipState) {
                    1 -> {
                        val direction = direction
                        val cos = cos(direction)
                        val sin = sin(direction)

                        for (i in 0.025..2.0 step 0.025) {
                            shouldContinue = false
                            if (!isMoving || mc.theWorld.getCollidingBoundingBoxes(
                                    player,
                                    player.entityBoundingBox
                                        .offset(
                                            -sin * i,
                                            0.0,
                                            cos * i
                                        )
                                ).isNotEmpty()
                            ) continue

                            player.setPositionAndUpdate(
                                player.posX - sin * 0.06,
                                player.posY,
                                player.posZ + cos * 0.06
                            )

                            if (i > 0.06) {
                                value = i
                                yaw = direction
                                shouldContinue = true
                            }

                            event.zeroXZ()
                            break
                        }

                        clipState++
                        if (!shouldContinue)
                            clipState = 0
                    }

                    2 -> {
                        val value = if (isMoving) value else -0.06
                        player.setPositionAndUpdate(
                            player.posX - (sin(yaw) * value),
                            player.posY,
                            player.posZ + (cos(yaw) * value)
                        )
                        clipState = 0
                    }
                }
            }
        }
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent) {
        event.cancelEvent()
    }

    override val tag get() = mode
}