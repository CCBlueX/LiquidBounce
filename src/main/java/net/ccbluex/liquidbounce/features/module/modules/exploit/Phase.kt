/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.movement

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.modules.movement.phasemodes.vanilla.Vanilla
import net.ccbluex.liquidbounce.features.module.modules.movement.phasemodes.aac.AAC350
import net.ccbluex.liquidbounce.features.module.modules.movement.phasemodes.mineplex.Mineplex
import net.ccbluex.liquidbounce.features.module.modules.movement.phasemodes.spartan.Spartan
import net.ccbluex.liquidbounce.features.module.modules.movement.phasemodes.other.*
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.extensions.stop
import net.ccbluex.liquidbounce.utils.extensions.stopXZ
import net.ccbluex.liquidbounce.utils.timing.TickTimer
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.AxisAlignedBB
import org.lwjgl.input.Keyboard

object Phase : Module("Phase", ModuleCategory.EXPLOIT, hideModule = false) {
    private val phaseModes = arrayOf(
        Vanilla,

        // AAC
        AAC350,

        // Mineplex
        Mineplex,

        // Spartan
        Spartan,

        // Other
        Skip, Clip, FullBlock
    )

    private val modes = phaseModes.map { it.modeName }.toTypedArray()

    val mode by ListValue("Mode", modes, "Vanilla")

    var tickTimer = TickTimer()

    var shouldContinue = false
    var clipState = 0
    var yaw = 0.0
    var value = 0.0

    override fun onEnable() {
        val thePlayer = mc.thePlayer ?: return

        shouldContinue = false
        clipState = 0
        value = 0.0

        modeModule.onEnable()
    }

    override fun onDisable() {
        val thePlayer = mc.thePlayer ?: return

        modeModule.onDisable()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        if (mode == "FullBlock") {
            return
        }

        val isInsideBlock = collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !== air }

        if (isInsideBlock && mode != "Mineplex") {
            mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = false
        }

        tickTimer.update()

        modeModule.onUpdate()
    }

    @EventTarget
    fun onRender3D(event: Render3DEvent) {
        modeModule.onRender3D(event)
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        mc.thePlayer ?: return

        modeModule.onPacket(event)
    }

    @EventTarget
    fun onBB(event: BlockBBEvent) {
        mc.thePlayer ?: return

        if (mode == "FullBlock" || mode == "Mineplex") {
            return
        }

        if (mc.thePlayer != null && collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block: Block? -> block !== air } && event.boundingBox != null && event.boundingBox!!.maxY > mc.thePlayer.entityBoundingBox.minY) {
            val axisAlignedBB = event.boundingBox

            event.boundingBox = AxisAlignedBB.fromBounds(axisAlignedBB!!.maxX, mc.thePlayer.entityBoundingBox.minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ)
        }

        modeModule.onBB(event)
    }

    @EventTarget
    fun onJump(event: JumpEvent) {
        modeModule.onJump(event)
    }

    @EventTarget
    fun onStep(event: StepEvent) {
        modeModule.onStep(event)
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        modeModule.onMotion(event)
    }

    @EventTarget
    fun onMove(event: MoveEvent) {
        modeModule.onMove(event)
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent) {
        event.cancelEvent()
    }

    override val tag
        get() = mode

    private val modeModule
        get() = phaseModes.find { it.modeName == mode }!!
}
