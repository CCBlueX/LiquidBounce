/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.extensions.*
import net.ccbluex.liquidbounce.utils.timer.TickTimer
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.BlockAir
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos

@ModuleInfo(name = "Phase", description = "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT)
class Phase : Module()
{
    private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex", "AAC4-Cage", "RedeSky-Cage"), "Vanilla")

    private val tickTimer = TickTimer()

    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()

    private var aac4Stage = 0

    override fun onEnable()
    {
        aac4Stage = 0
        if (modeValue.get().equals("AAC4-Cage", ignoreCase = true)) mc.timer.timerSpeed = 0.1F
    }

    override fun onDisable()
    {
        if (modeValue.get().equals("AAC4-Cage", ignoreCase = true)) mc.timer.timerSpeed = 1F
    }

    @EventTarget
    fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
    {
        val theWorld = mc.theWorld ?: return
        val thePlayer = mc.thePlayer ?: return

        val mode = modeValue.get().lowercase()

        // AAC4, RedeSky Cage phase from FDPClient (https://github.com/Project-EZ4H/FDPClient)
        when (mode)
        {
            "aac4-cage" ->
            {
                when (aac4Stage)
                {
                    1 ->
                    {
                        thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 0.00000001, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
                        thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 1, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
                    }

                    3 -> state = false
                }

                aac4Stage++

                return
            }

            "redesky-cage" ->
            {
                when (aac4Stage)
                {
                    0 ->
                    {
                        thePlayer.setPosition(thePlayer.posX, thePlayer.posY - 0.00000001, thePlayer.posZ)
                        thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 0.00000001, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
                    }

                    1 ->
                    {
                        thePlayer.setPosition(thePlayer.posX, thePlayer.posY - 1, thePlayer.posZ)
                        thePlayer.sendQueue.addToSendQueue(C06PacketPlayerPosLook(thePlayer.posX, thePlayer.posY - 1, thePlayer.posZ, thePlayer.rotationYaw, thePlayer.rotationPitch, false))
                    }

                    3 -> state = false
                }
                aac4Stage++

                return
            }

            else ->
            {
            }
        }

        val isInsideBlock = theWorld.collideBlockIntersects(thePlayer.entityBoundingBox) { it.block !is BlockAir && !theWorld.isReplaceable(it) }
        if (isInsideBlock && !modeValue.get().equals("Mineplex", ignoreCase = true))
        {
            thePlayer.noClip = true
            thePlayer.motionY = 0.0
            thePlayer.onGround = false
        }

        val netHandler = mc.netHandler

        val dir = thePlayer.moveDirectionRadians
        val sin = -dir.sin
        val cos = dir.cos

        val posX = thePlayer.posX
        val posY = thePlayer.posY
        val posZ = thePlayer.posZ
        val onGround = thePlayer.onGround

        if (tickTimer.hasTimePassed(2) && thePlayer.isCollidedHorizontally && (!isInsideBlock || thePlayer.isSneaking)) when (mode)
        {
            "vanilla" -> if (onGround)
            {
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX, posY, posZ, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX, posY, posZ, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX, posY + 0.2, posZ, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX + 0.5, posY, posZ + 0.5, true))

                val x = sin * 0.04
                val z = cos * 0.04

                thePlayer.setPosition(posX + x, posY, posZ + z)
                tickTimer.reset()
            }

            "skip" -> if (onGround)
            {

                val x = sin * 0.3
                val z = cos * 0.3

                repeat(3) {
                    netHandler.addToSendQueue(C04PacketPlayerPosition(posX, posY + 0.06, posZ, true))
                    netHandler.addToSendQueue(C04PacketPlayerPosition(posX + x * it, posY, posZ + z * it, true))
                }

                thePlayer.entityBoundingBox = thePlayer.entityBoundingBox.offset(x, 0.0, z)
                thePlayer.setPositionAndUpdate(posX + x, posY, posZ + z)
                tickTimer.reset()
            }

            "spartan" -> if (onGround)
            {
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX, posY, posZ, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX, posY, posZ, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX, posY - 0.2, posZ, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(0.5, 0.0, 0.5, true))
                netHandler.addToSendQueue(C04PacketPlayerPosition(posX + 0.5, posY, posZ + 0.5, true))

                val x = sin * 0.04
                val z = cos * 0.04

                thePlayer.setPosition(posX + x, posY, posZ + z)
                tickTimer.reset()
            }

            "clip" ->
            {
                run {
                    (1..10).map { sin * it to cos * it }.firstOrNull { (x, z) ->
                        val pos = BlockPos(posX + x, posY, posZ + z)
                        val eyePos = BlockPos(posX + x, posY + 1, posZ + z)
                        theWorld.getBlock(pos) is BlockAir && theWorld.getBlock(eyePos) is BlockAir
                    }?.let { (x, z) -> thePlayer.setPosition(posX + x, posY, posZ + z) }
                }

                tickTimer.reset()
            }

            "aac3.5.0" ->
            {
                val x = posX + sin
                val z = posZ + cos

                thePlayer.setPosition(x, posY, z)
                tickTimer.reset()
            }
        }

        tickTimer.update()
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent)
    {
        val theWorld = mc.theWorld ?: return
        val thePlayer = mc.thePlayer ?: return

        if (theWorld.collideBlockIntersects(thePlayer.entityBoundingBox) { it.block !is BlockAir } && (event.boundingBox ?: return).maxY > thePlayer.entityBoundingBox.minY && !modeValue.get().equals("Mineplex", ignoreCase = true))
        {
            val axisAlignedBB = event.boundingBox ?: return

            event.boundingBox = AxisAlignedBB(axisAlignedBB.maxX, thePlayer.entityBoundingBox.minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ)
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent)
    {
        val packet = event.packet

        if (packet is C03PacketPlayer && modeValue.get().equals("AAC3.5.0", ignoreCase = true))
        {
            val thePlayer = mc.thePlayer ?: return

            val dir = thePlayer.moveDirectionRadians
            packet.x -= dir.sin * 0.00000001
            packet.z += dir.cos * 0.00000001
        }
    }

    @EventTarget
    private fun onMove(event: MoveEvent)
    {
        val thePlayer = mc.thePlayer ?: return

        if (modeValue.get().equals("Mineplex", ignoreCase = true))
        {
            if (thePlayer.isCollidedHorizontally) mineplexClip = true
            if (!mineplexClip) return

            mineplexTickTimer.update()
            event.x = 0.0
            event.z = 0.0

            if (mineplexTickTimer.hasTimePassed(3))
            {
                mineplexTickTimer.reset()
                mineplexClip = false
            }
            else if (mineplexTickTimer.hasTimePassed(1))
            {
                val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                val dir = thePlayer.moveDirectionRadians

                thePlayer.setPosition(thePlayer.posX - dir.sin * offset, thePlayer.posY, thePlayer.posZ + dir.cos * offset)
            }
        }
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent)
    {
        event.cancelEvent()
    }

    override val tag: String
        get() = modeValue.get()
}
