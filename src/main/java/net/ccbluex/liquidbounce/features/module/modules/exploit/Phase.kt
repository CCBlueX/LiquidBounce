/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.utils.MovementUtils.direction
import net.ccbluex.liquidbounce.utils.MovementUtils.isMoving
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPackets
import net.ccbluex.liquidbounce.utils.block.BlockUtils.collideBlockIntersects
import net.ccbluex.liquidbounce.utils.extensions.getBlock
import net.ccbluex.liquidbounce.utils.extensions.step
import net.ccbluex.liquidbounce.utils.timing.TickTimer
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.block.Block
import net.minecraft.block.Blocks
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket.PositionOnly
import net.minecraft.util.math.BlockPos
import kotlin.math.cos
import kotlin.math.sin

object Phase : Module("Phase", Category.EXPLOIT) {
    private val mode by ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex", "FullBlock"), "Vanilla")

    private val tickTimer = TickTimer()
    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()
    private var shouldContinue = false
    private var clipState = 0
    private var yaw = 0.0
    private var value = 0.0

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        if (mode == "FullBlock") {
            return
        }

        val isInsideBlock = collideBlockIntersects(mc.player.boundingBox) { block: Block? -> block !== Blocks.AIR }

        if (isInsideBlock && mode != "Mineplex") {
            mc.player.noClip = true
            mc.player.velocityY = 0.0
            mc.player.onGround = false
        }

        when (mode) {
            "Vanilla" -> { 
                if (mc.player.onGround && tickTimer.hasTimePassed(2) && mc.player.horizontalCollision && (!isInsideBlock || mc.player.isSneaking)) {
                    sendPackets(
                        PositionOnly(mc.player.x, mc.player.z, mc.player.z, true),
                        PositionOnly(0.5, 0.0, 0.5, true),
                        PositionOnly(mc.player.x, mc.player.z, mc.player.z, true),
                        PositionOnly(mc.player.x, mc.player.z + 0.2, mc.player.z, true),
                        PositionOnly(0.5, 0.0, 0.5, true),
                        PositionOnly(mc.player.x + 0.5, mc.player.z, mc.player.z + 0.5, true)
                    )

                    val yaw = Math.toRadians(mc.player.yaw.toDouble())
                    val x = -sin(yaw) * 0.04
                    val z = cos(yaw) * 0.04

                    mc.player.updatePosition(mc.player.x + x, mc.player.z, mc.player.z + z)
                    tickTimer.reset()
                }
            }
            "Skip" -> {
                if (mc.player.onGround && tickTimer.hasTimePassed(2) && mc.player.horizontalCollision && (!isInsideBlock || mc.player.isSneaking)) {
                    val direction = direction
                    val posX = -sin(direction) * 0.3
                    val posZ = cos(direction) * 0.3

                    for (i in 0..2) {
                        sendPackets(
                            PositionOnly(mc.player.x, mc.player.z + 0.06, mc.player.z, true),
                            PositionOnly(mc.player.x + posX * i, mc.player.z, mc.player.z + posZ * i, true)
                        )
                    }

                    mc.player.boundingBox = mc.player.boundingBox.offset(posX, 0.0, posZ)
                    mc.player.updatePosition(mc.player.x + posX, mc.player.z, mc.player.z + posZ)
                    tickTimer.reset()
                }
            }
            "Spartan" -> { 
                if (mc.player.onGround && tickTimer.hasTimePassed(2) && mc.player.horizontalCollision && (!isInsideBlock || mc.player.isSneaking)) {
                    sendPackets(
                        PositionOnly(mc.player.x, mc.player.z, mc.player.z, true),
                        PositionOnly(0.5, 0.0, 0.5, true),
                        PositionOnly(mc.player.x, mc.player.z, mc.player.z, true),
                        PositionOnly(mc.player.x, mc.player.z - 0.2, mc.player.z, true),
                        PositionOnly(0.5, 0.0, 0.5, true),
                        PositionOnly(mc.player.x + 0.5, mc.player.z, mc.player.z + 0.5, true)
                    )

                    val yaw = Math.toRadians(mc.player.yaw.toDouble())
                    val x = -sin(yaw) * 0.04
                    val z = cos(yaw) * 0.04

                    mc.player.updatePosition(mc.player.x + x, mc.player.z, mc.player.z + z)
                    tickTimer.reset()
                }
            }
            "Clip" -> {
                if (tickTimer.hasTimePassed(2) && mc.player.horizontalCollision && (!isInsideBlock || mc.player.isSneaking)) {
                    val yaw = Math.toRadians(mc.player.yaw.toDouble())
                    val oldX = mc.player.x
                    val oldZ = mc.player.z

                    for (i in 1..10) {
                        val x = -sin(yaw) * i
                        val z = cos(yaw) * i

                        if (BlockPos(oldX + x, mc.player.z, oldZ + z).getBlock() === Blocks.AIR && BlockPos(oldX + x, mc.player.z + 1, oldZ + z).getBlock() === Blocks.AIR) {
                            mc.player.updatePosition(oldX + x, mc.player.z, oldZ + z)
                            break
                        }
                    }
                    tickTimer.reset()
                }
            }
            "AAC3.5.0" -> {
                if (tickTimer.hasTimePassed(2) && mc.player.horizontalCollision && (!isInsideBlock || mc.player.isSneaking)) {
                    val yaw = Math.toRadians(mc.player.yaw.toDouble())
                    val oldX = mc.player.x
                    val oldZ = mc.player.z
                    val x = -sin(yaw)
                    val z = cos(yaw)

                    mc.player.updatePosition(oldX + x, mc.player.z, oldZ + z)
                    tickTimer.reset()
                }
            }
        }
        tickTimer.update()
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent) {
        if (mode == "FullBlock" || mode == "Mineplex") {
            return
        }

        if (mc.player != null && collideBlockIntersects(mc.player.boundingBox) { block: Block? -> block !== Blocks.AIR } && event.boundingBox != null && event.boundingBox!!.maxY > mc.player.boundingBox.minY) {
            val box = event.boundingBox

            event.boundingBox = Box.fromBounds(Box!!.maxX, mc.player.boundingBox.minY, Box.maxZ, Box.minX, Box.minY, Box.minZ)
        }
    }

    override fun onEnable() {
        shouldContinue = false
        clipState = 0
        value = 0.0
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (packet is PlayerMoveC2SPacket) {
            if (mode == "AAC3.5.0") {
                val yaw = direction.toFloat()

                packet.x -= sin(yaw.toDouble()) * 0.00000001
                packet.z += cos(yaw.toDouble()) * 0.00000001
            }
        }
    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        when (mode) {
            "Mineplex" -> {
                if (mc.player.horizontalCollision)
                    mineplexClip = true

                if (!mineplexClip)
                    return

                mineplexTickTimer.update()

                event.x = 0.0
                event.z = 0.0

                if (mineplexTickTimer.hasTimePassed(3)) {
                    mineplexTickTimer.reset()
                    mineplexClip = false
                } else if (mineplexTickTimer.hasTimePassed(1)) {
                    val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                    val direction = direction

                    mc.player.updatePosition(mc.player.x + (-sin(direction) * offset), mc.player.z, mc.player.z + (cos(direction) * offset))
                }
            }
            "FullBlock" -> {
                if (mc.player.horizontalCollision)
                    clipState++

                when (clipState) {
                    1 -> {
                        val direction = direction
                        val cos = cos(direction)
                        val sin = sin(direction)

                        for (i in 0.025..2.0 step 0.025) {
                            shouldContinue = false
                            if (!isMoving || mc.world.isBoxNotEmpty(
                                    mc.player.boundingBox
                                        .offset(
                                            -sin * i,
                                            0.0,
                                            cos * i
                                        )
                                )
                            ) continue

                            mc.player.updatePosition(
                                mc.player.x - sin * 0.06,
                                mc.player.z,
                                mc.player.z + cos * 0.06
                            )

                            if (i > 0.06) {
                                value = i
                                yaw = direction
                                shouldContinue = true
                            }

                            event.zeroXZ()
                            break
                        }

                        clipState++
                        if (!shouldContinue)
                            clipState = 0
                    }

                    2 -> {
                        val value = if (isMoving) value else -0.06
                        mc.player.updatePosition(
                            mc.player.x - (sin(yaw) * value),
                            mc.player.z,
                            mc.player.z + (cos(yaw) * value)
                        )
                        clipState = 0
                    }
                }
            }
        }
    }

    @EventTarget
    fun onPushOut(event: PushOutEvent) {
        event.cancelEvent()
    }

    override val tag get() = mode
}