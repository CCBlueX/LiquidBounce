package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.api.minecraft.client.entity.EntityPlayerSP
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.runAsyncDelayed
import net.ccbluex.liquidbounce.value.*

@ModuleInfo(name = "AntiCAPTCHA", description = "Automatically solve CAPTCHAs based on chat/title.", category = ModuleCategory.EXPLOIT)
class AntiCAPTCHA : Module()
{
    private val delayValue = IntegerRangeValue("Delay", 0, 0, 0, 2000)

    private val captchaTextGroup = ValueGroup("CaptchaTextDetection")
    private val captchaTextContainsCount = IntegerValue("Count", 2, 1, 5)
    private val captchaTextContains1Value = object : TextValue("1", "Please type")
    {
        override fun showCondition(): Boolean = captchaTextContainsCount.get() >= 1
    }
    private val captchaTextContains2Value = object : TextValue("2", "to continue sending")
    {
        override fun showCondition(): Boolean = captchaTextContainsCount.get() >= 2
    }
    private val captchaTextContains3Value = object : TextValue("3", "")
    {
        override fun showCondition(): Boolean = captchaTextContainsCount.get() >= 3
    }
    private val captchaTextContains4Value = object : TextValue("4", "")
    {
        override fun showCondition(): Boolean = captchaTextContainsCount.get() >= 3
    }
    private val captchaTextContains5Value = object : TextValue("5", "")
    {
        override fun showCondition(): Boolean = captchaTextContainsCount.get() >= 4
    }

    private val highlightTypeValue = ListValue("HighlightType", arrayOf("Quotes", "Brackets", "Braces", "Parentheses", "Chevrons", "Custom"), "Quotes")
    private val customHighlightGroup = object : ValueGroup("CustomHighlight")
    {
        override fun showCondition(): Boolean = highlightTypeValue.get().equals("Custom", ignoreCase = true)
    }
    private val customHighlightStartValue = TextValue("StartsWith", "type '")
    private val customHighlightEndValue = TextValue("EndsWith", "' to")

    private val responceType = ListValue("ResponceMode", arrayOf("Chat", "Command"), "Chat")
    private val responceCommandValue = object : TextValue("ResponceCommand", "/captcha")
    {
        override fun showCondition(): Boolean = responceType.get().equals("Command", ignoreCase = true)
    }

    init
    {
        captchaTextGroup.addAll(captchaTextContainsCount, captchaTextContains1Value, captchaTextContains2Value, captchaTextContains3Value, captchaTextContains4Value, captchaTextContains5Value)
        customHighlightGroup.addAll(customHighlightStartValue, customHighlightEndValue)
    }

    override val tag: String
        get() = highlightTypeValue.get()

    private val captchaTexts = arrayOf(captchaTextContains1Value.get(), captchaTextContains2Value.get(), captchaTextContains3Value.get(), captchaTextContains4Value.get(), captchaTextContains5Value.get()).take(captchaTextContainsCount.get())

    private val highlight: Pair<Array<String>, Array<String>>
        get()
        {
            return when (highlightTypeValue.get().toLowerCase())
            {
                "quotes" -> arrayOf("'", "\"", "\u2018", "\u201C", "「", "『") to arrayOf("'", "\"", "\u2019", "\u201D", "」", "』")
                "brackets" -> arrayOf("[", "【") to arrayOf("]", "】")
                "braces" -> arrayOf("{") to arrayOf("}")
                "parentheses" -> arrayOf("(") to arrayOf(")")
                "chevrons" -> arrayOf(">", "<", "〉", "〈", "》", "《") to arrayOf(">", "<", "〉", "〈", "》", "《")
                else -> arrayOf(customHighlightStartValue.get()) to arrayOf(customHighlightEndValue.get())
            }
        }

    private fun isCAPTCHA(unformattedText: String): Boolean = captchaTexts.all { unformattedText.contains(it, ignoreCase = true) }

    private fun extractCAPTCHACode(unformattedText: String): String?
    {
        val highlight = highlight
        val firstIndex = highlight.first.map { unformattedText.indexOf(it) }.firstOrNull { it > 0 } ?: return null

        val subString = unformattedText.substring(firstIndex + 1)
        val secondIndex = highlight.second.map { subString.indexOf(it) }.firstOrNull { it > 0 } ?: return null

        return unformattedText.substring(firstIndex + 1, firstIndex + secondIndex + 1)
    }

    private fun responce(thePlayer: EntityPlayerSP, code: String)
    {
        val task = {
            when (responceType.get().toLowerCase())
            {
                "chat" -> thePlayer.sendChatMessage(code)
                "command" -> thePlayer.sendChatMessage("${responceCommandValue.get()} $code")
            }
        }

        if (delayValue.getMax() > 0) runAsyncDelayed(delayValue.getRandomLong(), task) else task.invoke()
    }

    @EventTarget
    fun onPacket(event: PacketEvent)
    {
        val thePlayer = mc.thePlayer ?: return

        if (event.packet is SPacketChat)
        {
            val chat = event.packet.asSPacketChat().chatComponent.unformattedText

            if (isCAPTCHA(chat)) extractCAPTCHACode(chat)?.let { responce(thePlayer, it) }
        }
        else if (event.packet is SPacketTitle)
        {
            val title = event.packet.asSPacketTitle().message?.unformattedText ?: return

            if (isCAPTCHA(title)) extractCAPTCHACode(title)?.let { responce(thePlayer, it) }
        }
    }
}
