/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit;

import net.ccbluex.liquidbounce.event.*;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.utils.ClientUtils;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.ccbluex.liquidbounce.utils.timing.TickTimer;
import net.ccbluex.liquidbounce.value.ListValue;
import net.minecraft.init.Blocks;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;

import static net.ccbluex.liquidbounce.utils.PacketUtils.sendPackets;
import static net.ccbluex.liquidbounce.utils.extensions.BlockExtensionKt.getBlock;
import static net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition;

public class Phase extends Module {

    public Phase() {
        super("Phase", ModuleCategory.EXPLOIT);
    }

    private final ListValue modeValue = new ListValue("Mode", new String[] {"Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex", "FullBlock"}, "Vanilla");

    private final TickTimer tickTimer = new TickTimer();

    private boolean mineplexClip;
    private final TickTimer mineplexTickTimer = new TickTimer();

    private boolean shouldContinue;

    private int clipState;

    private double yaw;

    private double value;
    @EventTarget
    public void onUpdate(final UpdateEvent event) {
        if (modeValue.get().equals("FullBlock")) return;
        final boolean isInsideBlock = BlockUtils.INSTANCE.collideBlockIntersects(mc.thePlayer.getEntityBoundingBox(), block -> block != Blocks.air);

        if(isInsideBlock && !modeValue.get().equals("Mineplex")) {
            mc.thePlayer.noClip = true;
            mc.thePlayer.motionY = 0;
            mc.thePlayer.onGround = false;
        }

        switch(modeValue.get().toLowerCase()) {
            case "vanilla": {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking()))
                    break;

                sendPackets(
                    new C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true),
                    new C04PacketPlayerPosition(0.5, 0, 0.5, true),
                    new C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true),
                    new C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.2, mc.thePlayer.posZ, true),
                    new C04PacketPlayerPosition(0.5, 0, 0.5, true),
                    new C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true)
                );
                final double yaw = Math.toRadians(mc.thePlayer.rotationYaw);
                final double x = -Math.sin(yaw) * 0.04;
                final double z = Math.cos(yaw) * 0.04;
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z);
                tickTimer.reset();
                break;
            }
            case "skip": {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking()))
                    break;

                final double direction = MovementUtils.INSTANCE.getDirection();
                final double posX = -Math.sin(direction) * 0.3;
                final double posZ = Math.cos(direction) * 0.3;

                for (int i = 0; i < 3; ++i) {
                    sendPackets(
                        new C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.06, mc.thePlayer.posZ, true),
                        new C04PacketPlayerPosition(mc.thePlayer.posX + posX * i, mc.thePlayer.posY, mc.thePlayer.posZ + posZ * i, true)
                    );
                }

                mc.thePlayer.setEntityBoundingBox(mc.thePlayer.getEntityBoundingBox().offset(posX, 0, posZ));
                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX + posX, mc.thePlayer.posY, mc.thePlayer.posZ + posZ);
                tickTimer.reset();
                break;
            }
            case "spartan": {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking()))
                    break;

                sendPackets(
                    new C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true),
                    new C04PacketPlayerPosition(0.5, 0, 0.5, true),
                    new C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true),
                    new C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 0.2, mc.thePlayer.posZ, true),
                    new C04PacketPlayerPosition(0.5, 0, 0.5, true),
                    new C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true)
                );
                final double yaw = Math.toRadians(mc.thePlayer.rotationYaw);
                final double x = -Math.sin(yaw) * 0.04;
                final double z = Math.cos(yaw) * 0.04;
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z);
                tickTimer.reset();
                break;
            }
            case "clip": {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking()))
                    break;

                final double yaw = Math.toRadians(mc.thePlayer.rotationYaw);
                final double oldX = mc.thePlayer.posX;
                final double oldZ = mc.thePlayer.posZ;

                for (int i = 1; i <= 10; i++) {
                    final double x = -Math.sin(yaw) * i;
                    final double z = Math.cos(yaw) * i;

                    if (getBlock(new BlockPos(oldX + x, mc.thePlayer.posY, oldZ + z)) == Blocks.air && getBlock(new BlockPos(oldX + x, mc.thePlayer.posY + 1, oldZ + z)) == Blocks.air) {
                        mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z);
                        break;
                    }
                }
                tickTimer.reset();
                break;
            }
            case "aac3.5.0": {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking()))
                    break;

                final double yaw = Math.toRadians(mc.thePlayer.rotationYaw);
                final double oldX = mc.thePlayer.posX;
                final double oldZ = mc.thePlayer.posZ;
                final double x = -Math.sin(yaw);
                final double z = Math.cos(yaw);

                mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z);
                tickTimer.reset();
                break;
            }
        }

        tickTimer.update();
    }

    @EventTarget
    public void onBlockBB(final BlockBBEvent event) {
        if (modeValue.get().equals("FullBlock") || modeValue.get().equals("Mineplex")) return;
        if (mc.thePlayer != null && BlockUtils.INSTANCE.collideBlockIntersects(mc.thePlayer.getEntityBoundingBox(), block -> block != Blocks.air) && event.getBoundingBox() != null && event.getBoundingBox().maxY > mc.thePlayer.getEntityBoundingBox().minY) {
            final AxisAlignedBB axisAlignedBB = event.getBoundingBox();

            event.setBoundingBox(AxisAlignedBB.fromBounds(axisAlignedBB.maxX, mc.thePlayer.getEntityBoundingBox().minY, axisAlignedBB.maxZ, axisAlignedBB.minX, axisAlignedBB.minY, axisAlignedBB.minZ));
        }
    }

    @Override
    public void onEnable() {
        shouldContinue = false;
        clipState = 0;
        value = 0;
    }
    @EventTarget
    public void onPacket(final PacketEvent event) {
        if (modeValue.get().equals("FullBlock")) return;
        final Packet packet = event.getPacket();

        if (packet instanceof C03PacketPlayer) {
            C03PacketPlayer packetPlayer = (C03PacketPlayer) packet;

            if (modeValue.get().equals("AAC3.5.0")) {
                final float yaw = (float) MovementUtils.INSTANCE.getDirection();

                packetPlayer.x = packetPlayer.x - Math.sin(yaw) * 0.00000001;
                packetPlayer.z = packetPlayer.z + Math.cos(yaw) * 0.00000001;
            }
        }
    }

    @EventTarget
    private void onMove(final MoveEvent event) {
        if (modeValue.get().equals("Mineplex")) {
            if (mc.thePlayer.isCollidedHorizontally)
                mineplexClip = true;
            if (!mineplexClip)
                return;

            mineplexTickTimer.update();

            event.setX(0);
            event.setZ(0);

            if (mineplexTickTimer.hasTimePassed(3)) {
                mineplexTickTimer.reset();
                mineplexClip = false;
            } else if (mineplexTickTimer.hasTimePassed(1)) {
                final double offset = mineplexTickTimer.hasTimePassed(2) ? 1.6 : 0.06;
                final double direction = MovementUtils.INSTANCE.getDirection();

                mc.thePlayer.setPosition(mc.thePlayer.posX + (-Math.sin(direction) * offset), mc.thePlayer.posY, mc.thePlayer.posZ + (Math.cos(direction) * offset));
            }
        }
        else if (modeValue.get().equals("FullBlock")) {
            if (mc.thePlayer.isCollidedHorizontally) {
                clipState++;
            }
            switch (clipState) {
                case 1:
                    double i = 0;
                    double moveYaw = MovementUtils.INSTANCE.getDirection();
                    while ((i += 0.025) <= 2) {
                        if (mc.theWorld.getCollidingBoundingBoxes(mc.thePlayer, mc.thePlayer.getEntityBoundingBox().offset(-(Math.sin(moveYaw) * i), 0, (Math.cos(moveYaw) * i)).expand(0, 0, 0)).isEmpty() && (mc.thePlayer.movementInput.moveForward != 0 || mc.thePlayer.movementInput.moveStrafe != 0)) {
                            if (i <= 0.06) {
                                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX - (Math.sin(moveYaw) * 0.06), mc.thePlayer.posY, mc.thePlayer.posZ + (Math.cos(moveYaw) * 0.06));
                                shouldContinue = false;
                                event.setX(0);
                                event.setZ(0);
                                break;
                            } else {
                                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX - (Math.sin(moveYaw) * 0.06), mc.thePlayer.posY, mc.thePlayer.posZ + (Math.cos(moveYaw) * 0.06));
                                value = i;
                                yaw = moveYaw;
                                shouldContinue = true;
                                event.setX(0);
                                event.setZ(0);
                                break;
                            }
                        } else {
                            shouldContinue = false;
                        }
                    }
                    clipState++;
                    if (!shouldContinue) {
                        clipState = 0;
                    }
                    break;
                case 2:
                    if (mc.thePlayer.movementInput.moveForward != 0 || mc.thePlayer.movementInput.moveStrafe != 0) {
                        mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX - (Math.sin(yaw) * value), mc.thePlayer.posY, mc.thePlayer.posZ + (Math.cos(yaw) * value));
                    } else {
                        mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX - (Math.sin(yaw) * -0.06), mc.thePlayer.posY, mc.thePlayer.posZ + (Math.cos(yaw) * -0.06));
                    }
                    clipState = 0;
                    break;
            }
        }
    }

    @EventTarget
    public void onPushOut(PushOutEvent event) {
        event.cancelEvent();
    }

    @Override
    public String getTag() {
        return modeValue.get();
    }
}
