/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.TickEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.utils.PacketUtils.handlePacket
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.Packet
import net.minecraft.network.play.server.S00PacketKeepAlive
import net.minecraft.network.play.server.S32PacketConfirmTransaction
import java.util.concurrent.ConcurrentHashMap

object PingSpoof : Module("PingSpoof", ModuleCategory.EXPLOIT) {

    private val delay by IntegerValue("Delay", 500, 0..25000)

    private val packetQueue = ConcurrentHashMap<Packet<*>, Pair<Long, Long>>()

    override fun onEnable() {
    }

    override fun onDisable() {
        reset()
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (event.isCancelled)
            return

        if (mc.thePlayer == null) {
            return
        }

        if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive) {
            event.cancelEvent()

            // Use nano time for the registration time since there are chances
            // the packets can be under the same milliseconds and mess up the order
            packetQueue[packet] = System.currentTimeMillis() to System.nanoTime()
        }
    }

    @EventTarget
    fun onTick(event: TickEvent) {
        sendPacketsByOrder(false)
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        packetQueue.clear()
    }

    private fun sendPacketsByOrder(all: Boolean) {
        // Accept packets that have passed the requested delay, then sort by registration time
        val filtered = packetQueue.filter { entry -> all || entry.value.first <= (System.currentTimeMillis() - delay) }.entries.sortedBy { it.value.second }.map { it.key }

        for (packet in filtered) {
            handlePacket(packet)
            packetQueue.remove(packet)
        }
    }

    private fun reset() {
        sendPacketsByOrder(true)

        packetQueue.clear()
    }
}
