/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.modules.combat.Velocity
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.Packet
import net.minecraft.network.packet.c2s.play.PlayerInteractEntityC2SPacket
import net.minecraft.network.packet.c2s.play.PlayerInputC2SPacket
import net.minecraft.network.packet.c2s.play.ConfirmGuiActionC2SPacket
import net.minecraft.network.packet.s2c.play.*
import net.minecraft.network.packet.s2c.play.S14PacketEntity.S16PacketEntityLook
import java.util.LinkedHashMap

object PingSpoof : Module("PingSpoof", Category.EXPLOIT, hideModule = false) {

    private val pingOnly by BoolValue("PingOnly", false)

    private val spoofDelay by IntegerValue("SpoofDelay", 500, 0..25000)

    private val packetQueue = LinkedHashMap<Packet<*>, Long>()

    override fun onDisable() = reset()

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (event.isCancelled || mc.player == null)
            return

        if (pingOnly) {
            if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive) {
                event.cancelEvent()

                // Use nano time for the registration time since there are chances
                // the packets can be under the same milliseconds and mess up the order
                synchronized(packetQueue) {
                    packetQueue[packet] = System.currentTimeMillis()
                }
            }
        } else {
            // This should bypass simulation AntiCheat better.
            // Example: GrimAC
            if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive
                || packet is EntityStatusS2CPacket || (packet is S12PacketEntityVelocity && !Velocity.delayMode)
                || packet is PlayerPositionLookS2CPacket ||  packet is PlayerInputC2SPacket) {
                event.cancelEvent()

                // Use nano time for the registration time since there are chances
                // the packets can be under the same milliseconds and mess up the order
                synchronized(packetQueue) {
                    packetQueue[packet] = System.currentTimeMillis()
                }
            }
        }
    }

    @EventTarget
    fun onGameLoop(event: GameLoopEvent) = sendPacketsByOrder(false)

    @EventTarget
    fun onWorld(event: WorldEvent) = packetQueue.clear()

    // Accept packets that have passed the requested delay, then sort by registration time
    private fun sendPacketsByOrder(all: Boolean) =
        synchronized(packetQueue) {
            packetQueue.entries.removeAll { (packet, timestamp) ->
                if (all || timestamp <= (System.currentTimeMillis() - spoofDelay)) {
                    PacketUtils.queuedPackets.add(packet)
                    true
                } else false
            }
        }

    private fun reset() {
        sendPacketsByOrder(true)

        packetQueue.clear()
    }
}
