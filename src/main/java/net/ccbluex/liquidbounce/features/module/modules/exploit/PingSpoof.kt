/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.modules.exploit.PingSpoof.sendPacketsByOrder
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.PacketUtils.handlePacket
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.Packet
import net.minecraft.network.play.server.S00PacketKeepAlive
import net.minecraft.network.play.server.S32PacketConfirmTransaction
import java.util.LinkedHashMap

object PingSpoof : Module("PingSpoof", ModuleCategory.EXPLOIT) {

    private val delay by IntegerValue("Delay", 500, 0..25000)

    private val packetQueue = LinkedHashMap<Packet<*>, Long>()

    override fun onDisable() = reset()

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (event.isCancelled || mc.thePlayer == null)
            return

        if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive) {
            event.cancelEvent()

            // Use nano time for the registration time since there are chances
            // the packets can be under the same milliseconds and mess up the order
            synchronized(packetQueue) {
                packetQueue[packet] = System.currentTimeMillis()
            }
        }
    }

    @EventTarget
    fun onGameLoop(event: GameLoopEvent) = sendPacketsByOrder(false)

    @EventTarget
    fun onWorld(event: WorldEvent) = packetQueue.clear()

    // Accept packets that have passed the requested delay, then sort by registration time
    private fun sendPacketsByOrder(all: Boolean) =
        synchronized(packetQueue) {
            packetQueue.entries.removeAll { (packet, timestamp) ->
                if (all || timestamp <= (System.currentTimeMillis() - delay)) {
                    PacketUtils.queuedPackets.add(packet)
                    true
                } else false
            }
        }

    private fun reset() {
        sendPacketsByOrder(true)

        packetQueue.clear()
    }
}
