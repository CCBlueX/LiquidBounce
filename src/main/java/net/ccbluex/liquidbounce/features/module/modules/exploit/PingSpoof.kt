/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotificationIcon
import net.ccbluex.liquidbounce.utils.extensions.sendPacketWithoutEvent
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerRangeValue
import net.ccbluex.liquidbounce.value.ListValue
import net.ccbluex.liquidbounce.value.ValueGroup
import net.minecraft.network.Packet
import net.minecraft.network.play.client.C00PacketKeepAlive
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.client.C16PacketClientStatus
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue

@ModuleInfo(name = "PingSpoof", description = "Spoofs your ping to a given value. You can bypass most anti-cheats by spoofing ping to higher value.", category = ModuleCategory.EXPLOIT)
class PingSpoof : Module()
{
    /**
     * Options
     */
    private val keepAliveGroup = ValueGroup("KeepAlive")
    val keepAliveModeValue = ListValue("Mode", arrayOf("Ignore", "Delay", "TamperKey", "Cancel"), "Delay", "KeepAlive")
    val keepAliveDelayValue = IntegerRangeValue("Delay", 500, 1000, 0, 5000, "KeepAlive-MaxDelay" to "KeepAlive-MinDelay")
    val keepAliveTamperKeyValue = IntegerRangeValue("TamperKey", 1000, Int.MAX_VALUE, Int.MIN_VALUE, Int.MAX_VALUE, "KeepAlive-TamperKey-Bound" to "KeepAlive-TamperKey-Origin")
    private val keepAliveSendOnNextValue = BoolValue("SendOnNextKeepAliveReceived", false, "KeepAlive-SendOnNextKeepAliveReceived")

    private val clientStatusGroup = ValueGroup("ClientStatus")
    private val clientStatusModeValue = ListValue("Mode", arrayOf("Ignore", "Delay"), "Delay", "ClientStatus")
    private val clientStatusDelayValue = IntegerRangeValue("Delay", 500, 1000, 0, 5000, "ClientStatus-MaxDelay" to "ClientStatus-MinDelay")

    // Some anticheats(Verus, Spartan, WatchDog, etc.) sends C0FPacketConfirmTransaction packet to check ping instead of C00PacketKeepAlive to detect most ping-spoofers. So we need to spoof C0FPacketConfirmTransaction together to bypass them.
    private val confirmTransactionGroup = ValueGroup("ConfirmTransaction")
    val confirmTransactionModeValue = ListValue("Mode", arrayOf("Ignore", "Delay", "Cancel"), "Delay", "ConfirmTransactionPackets")
    val confirmTransactionDelayValue = IntegerRangeValue("Delay", 500, 1000, 0, 5000, "ConfirmTransaction-MaxDelay" to "ConfirmTransaction-MinDelay")
    private val confirmTransactionSendOnNextValue = BoolValue("SendOnNextConfirmTransactionReceived", false, "ConfirmTransaction-SendOnNextConfirmTransactionReceived")

    private val verboseNotification = BoolValue("VerboseNotification", false)

    /**
     * Queues
     */
    private val packetQueue = ConcurrentHashMap<Packet<*>, Long>()

    private val keepAliveQueue = ConcurrentLinkedQueue<Packet<*>>()
    private val confirmTransactionQueue = ConcurrentLinkedQueue<Packet<*>>()

    init
    {
        keepAliveGroup.addAll(keepAliveModeValue, keepAliveDelayValue, keepAliveTamperKeyValue, keepAliveSendOnNextValue)
        clientStatusGroup.addAll(clientStatusModeValue, clientStatusDelayValue)
        confirmTransactionGroup.addAll(confirmTransactionModeValue, confirmTransactionDelayValue, confirmTransactionSendOnNextValue)
    }

    override fun onDisable()
    {
        packetQueue.clear()
    }

    @EventTarget
    fun onPacket(event: PacketEvent)
    {
        if (event.isCancelled) return

        val thePlayer = mc.thePlayer ?: return
        val networkManager = mc.netHandler.networkManager

        val packet = event.packet

        var delay = 0L

        val keepAliveMode = keepAliveModeValue.get()
        if (!keepAliveMode.equals("Ignore", ignoreCase = true) && packet is C00PacketKeepAlive)
        {
            val sendKeepAlive = {
                if (keepAliveSendOnNextValue.get())
                {
                    while (keepAliveQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(keepAliveQueue.poll())

                    keepAliveQueue.offer(packet)

                    event.cancelEvent()
                }
                else delay = keepAliveDelayValue.getRandomLong()
            }

            when (keepAliveMode.lowercase())
            {
                "delay" ->
                {
                    sendKeepAlive()
                    verbose { arrayOf("C00PacketKeepAlive", "key=${packet.key}", "behavior=delay") }
                }

                "tamperkey" ->
                {
                    val prevKey = packet.key
                    packet.key = keepAliveTamperKeyValue.getRandom()
                    sendKeepAlive()
                    verbose { arrayOf("C00PacketKeepAlive", "oldKey=${prevKey}", "behavior=tamper + delay", "newKey=${packet.key}") }
                }

                else ->
                {
                    event.cancelEvent()
                    verbose { arrayOf("C00PacketKeepAlive", "oldKey=${packet.key}", "behavior=cancel") }
                }
            }
        }

        if (!clientStatusModeValue.get().equals("Ignore", ignoreCase = true) && packet is C16PacketClientStatus && !thePlayer.isDead && thePlayer.health > 0)
        {
            delay = clientStatusDelayValue.getRandomLong()
            verbose { arrayOf("CPacketClientStatus", "status=${packet.status}", "behavior=${if (event.isCancelled) "cancel" else "delay"}") }
        }

        val confirmTransactionMode = confirmTransactionModeValue.get()
        if (!confirmTransactionMode.equals("Ignore", ignoreCase = true) && packet is C0FPacketConfirmTransaction)
        {
            when (confirmTransactionMode.lowercase())
            {
                "delay" ->
                {
                    if (confirmTransactionSendOnNextValue.get())
                    {
                        while (confirmTransactionQueue.isNotEmpty()) networkManager.sendPacketWithoutEvent(confirmTransactionQueue.poll())

                        confirmTransactionQueue.offer(packet)

                        event.cancelEvent()
                    }
                    else delay = confirmTransactionDelayValue.getRandomLong()
                }

                "cancel" -> event.cancelEvent()
            }

            verbose {
                arrayOf("C0FPacketConfirmTransaction", "windowId=${packet.windowId}", "uid=${packet.uid}", "accepted=${packet.accepted}}", "behavior=${if (event.isCancelled) "cancel" else "delay"}")
            }
        }

        if (delay > 0L)
        {
            packetQueue[packet] = System.currentTimeMillis() + delay
            event.cancelEvent()
        }
    }

    private fun verbose(messageSupplier: () -> Array<String>)
    {
        if (verboseNotification.get()) LiquidBounce.hud.addNotification(Notification(NotificationIcon.VERBOSE, "PingSpoof", messageSupplier(), 1000L))
    }

    @EventTarget
    fun onUpdate(@Suppress("UNUSED_PARAMETER") event: UpdateEvent)
    {
        val networkManager = mc.netHandler.networkManager

        val currentTime = System.currentTimeMillis()

        if (packetQueue.isNotEmpty()) packetQueue.filter { it.value >= currentTime }.forEach { (packet, time) ->
            networkManager.sendPacketWithoutEvent(packet)
            packetQueue.remove(packet, time)
        }
    }
}
